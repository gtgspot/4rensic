<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forensic Legal Analyzer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- OCR and PDF Processing Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Configure PDF.js worker
      if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    </script>
    <style>
        /* CSS Custom Properties for Theme System */
        :root {
            /* Color Palette */
            --color-primary: #2563eb;
            --color-primary-dark: #1d4ed8;
            --color-primary-light: #eff6ff;
            --color-secondary: #f59e0b;
            --color-secondary-light: #fef3c7;
            --color-success: #16a34a;
            --color-success-light: #dcfce7;
            --color-warning: #f59e0b;
            --color-warning-light: #fef3c7;
            --color-error: #dc2626;
            --color-error-light: #fee2e2;
            --color-info: #0284c7;
            --color-info-light: #e0f2fe;

            /* Neutral Colors */
            --color-gray-50: #f9fafb;
            --color-gray-100: #f3f4f6;
            --color-gray-200: #e5e7eb;
            --color-gray-300: #d1d5db;
            --color-gray-400: #9ca3af;
            --color-gray-500: #6b7280;
            --color-gray-600: #4b5563;
            --color-gray-700: #374151;
            --color-gray-800: #1f2937;
            --color-gray-900: #111827;

            /* Severity Colors */
            --color-critical: #fecaca;
            --color-critical-text: #991b1b;
            --color-high: #fcd34d;
            --color-high-text: #92400e;
            --color-medium: #a5f3fc;
            --color-medium-text: #0e7490;
            --color-low: #bbf7d0;
            --color-low-text: #166534;

            /* Spacing System */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;

            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            --radius-full: 9999px;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.15);

            /* Typography */
            --font-size-xs: 11px;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 24px;
            --font-size-3xl: 30px;
            --font-size-4xl: 36px;

            /* Transitions */
            --transition-fast: 150ms ease-in-out;
            --transition-base: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;

            /* Z-index Scale */
            --z-dropdown: 1000;
            --z-modal: 2000;
            --z-tooltip: 3000;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-size: var(--font-size-base);
            color: var(--color-gray-900);
        }

        #root {
            width: 100%;
            min-height: 100vh;
        }

        /* Icon styles - using Unicode symbols instead of Lucide */
        .icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: middle;
        }

        /* Smooth Transitions */
        button, a, .card, .section {
            transition: all var(--transition-base);
        }

        /* Focus Styles for Accessibility */
        button:focus-visible,
        a:focus-visible,
        input:focus-visible {
            outline: 3px solid var(--color-primary);
            outline-offset: 2px;
        }

        /* Hover Effects */
        button:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        button:not(:disabled):active {
            transform: translateY(0);
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -1000px 0;
            }
            100% {
                background-position: 1000px 0;
            }
        }

        .fade-in {
            animation: fadeIn var(--transition-base);
        }

        .slide-in {
            animation: slideIn var(--transition-base);
        }

        .pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .spin {
            animation: spin 1s linear infinite;
        }

        /* Skeleton Loading States */
        .skeleton {
            background: linear-gradient(
                90deg,
                var(--color-gray-200) 0%,
                var(--color-gray-100) 50%,
                var(--color-gray-200) 100%
            );
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
            border-radius: var(--radius-md);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root {
                --font-size-3xl: 24px;
                --spacing-xl: 24px;
                --spacing-2xl: 32px;
            }

            body {
                font-size: var(--font-size-sm);
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white !important;
            }

            button, .no-print {
                display: none !important;
            }

            .card, .section {
                box-shadow: none !important;
                border: 1px solid var(--color-gray-300) !important;
                page-break-inside: avoid;
            }

            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-gray-100);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--color-gray-400);
            border-radius: var(--radius-full);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--color-gray-500);
        }

        /* Utility Classes */
        .text-center {
            text-align: center;
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef } = React;

        // Simple icon components using Unicode symbols
        const Icon = ({ name, className = "", ...props }) => {
            const icons = {
                Upload: "‚¨ÜÔ∏è",
                FileText: "üìÑ",
                AlertCircle: "‚ö†Ô∏è",
                CheckCircle: "‚úÖ",
                Loader: "‚åõ",
                Download: "‚¨áÔ∏è",
                Eye: "üëÅÔ∏è",
                ChevronDown: "‚ñº",
                ChevronRight: "‚ñ∂"
            };
            
            return <span className={`icon ${className}`} {...props}>{icons[name] || "‚Ä¢"}</span>;
        };

        // Persistent Intelligence Layer - Enhanced Storage Manager
        const AnalysisMemory = {
          storage: null,
          dbPromise: null,
          DB_VERSION: 2,

          init() {
            if (this.dbPromise) return this.dbPromise;

            this.dbPromise = new Promise((resolve, reject) => {
              const request = window.indexedDB.open('ForensicAnalysisDB', this.DB_VERSION);

              request.onupgradeneeded = (e) => {
                const db = e.target.result;
                const oldVersion = e.oldVersion;

                // Table 1: analyses (complete analysis records)
                if (!db.objectStoreNames.contains('analyses')) {
                  const analysesStore = db.createObjectStore('analyses', { keyPath: 'id', autoIncrement: true });
                  analysesStore.createIndex('timestamp', 'timestamp', { unique: false });
                  analysesStore.createIndex('fileAName', 'fileAName', { unique: false });
                  analysesStore.createIndex('fileBName', 'fileBName', { unique: false });
                }

                // Table 2: defect_patterns (recurring defect tracking)
                if (!db.objectStoreNames.contains('defect_patterns')) {
                  const patternsStore = db.createObjectStore('defect_patterns', { keyPath: 'pattern_id', autoIncrement: true });
                  patternsStore.createIndex('defect_type', 'defect_type', { unique: false });
                  patternsStore.createIndex('occurrence_count', 'occurrence_count', { unique: false });
                  patternsStore.createIndex('last_seen', 'last_seen', { unique: false });
                }

                // Table 3: statutory_references (statute compliance tracking)
                if (!db.objectStoreNames.contains('statutory_references')) {
                  const statutesStore = db.createObjectStore('statutory_references', { keyPath: 'reference' });
                  statutesStore.createIndex('times_encountered', 'times_encountered', { unique: false });
                  statutesStore.createIndex('compliance_rate', 'compliance_rate', { unique: false });
                }

                // Remove old 'patterns' store if exists
                if (oldVersion < 2 && db.objectStoreNames.contains('patterns')) {
                  db.deleteObjectStore('patterns');
                }
              };

              request.onsuccess = (e) => {
                this.storage = e.target.result;
                resolve(this.storage);
              };

              request.onerror = (e) => {
                console.error('Failed to initialize IndexedDB:', e.target.error);
                reject(e.target.error);
              };
            });

            return this.dbPromise;
          },

          async getDB() {
            if (!this.storage) {
              await this.init();
            }
            return this.storage;
          },

          // AUTO-SAVE: Complete analysis with all metadata
          async saveAnalysis(results, files, fileContents) {
            try {
              const db = await this.getDB();
              const defects = this.extractDefects(results);
              const severity = this.calculateSeveritySummary(defects);
              const statutes = this.extractStatutoryReferences(results);

              const analysis = {
                timestamp: new Date().toISOString(),
                fileAName: files.fileA?.name || 'Unknown',
                fileBName: files.fileB?.name || 'Unknown',
                fileAContent: fileContents?.fileA || '',
                fileBContent: fileContents?.fileB || '',
                findings: results,
                defects: defects,
                severity_summary: severity,
                statutory_references: statutes,
                crossReferences: this.buildCrossReferences(results)
              };

              // Save to analyses table
              const tx = db.transaction('analyses', 'readwrite');
              const analysisId = await new Promise((resolve, reject) => {
                const request = tx.objectStore('analyses').add(analysis);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
              });

              // Update defect patterns
              await this.updateDefectPatterns(defects);

              // Update statutory references
              await this.updateStatutoryReferences(statutes, defects);

              console.log(`‚úÖ Analysis #${analysisId} saved to persistent storage`);
              return analysisId;
            } catch (error) {
              console.error('Failed to save analysis:', error);
              throw error;
            }
          },

          // Extract all defects from analysis results
          extractDefects(results) {
            const defects = [];

            // Phase A defects from both files
            ['fileA', 'fileB'].forEach(fileKey => {
              if (results.phaseA && results.phaseA[fileKey]) {
                results.phaseA[fileKey].forEach(preset => {
                  const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                  if (Array.isArray(issues)) {
                    issues.forEach(issue => {
                      defects.push({
                        phase: 'A',
                        preset: preset.preset,
                        severity: issue.severity || 'MEDIUM',
                        type: issue.type || 'General Issue',
                        description: issue.description || issue,
                        file: fileKey,
                        timestamp: new Date().toISOString()
                      });
                    });
                  }
                });
              }
            });

            // Phase B discrepancies
            if (results.phaseB?.discrepancies) {
              results.phaseB.discrepancies.forEach(disc => {
                defects.push({
                  phase: 'B',
                  type: 'discrepancy',
                  severity: disc.severity || 'HIGH',
                  description: disc.description || disc,
                  timestamp: new Date().toISOString()
                });
              });
            }

            // Phase B omissions
            if (results.phaseB?.omissions) {
              results.phaseB.omissions.forEach(om => {
                defects.push({
                  phase: 'B',
                  type: 'omission',
                  severity: 'MEDIUM',
                  element: om.element,
                  status: om.status,
                  description: `Missing: ${om.element}`,
                  timestamp: new Date().toISOString()
                });
              });
            }

            return defects;
          },

          // Calculate severity summary
          calculateSeveritySummary(defects) {
            const summary = { HIGH: 0, MEDIUM: 0, LOW: 0, CRITICAL: 0 };
            defects.forEach(defect => {
              const severity = (defect.severity || 'MEDIUM').toUpperCase();
              if (summary.hasOwnProperty(severity)) {
                summary[severity]++;
              } else {
                summary[severity] = 1;
              }
            });
            return summary;
          },

          // Extract statutory references from results
          extractStatutoryReferences(results) {
            const statutes = new Set();

            ['fileA', 'fileB'].forEach(fileKey => {
              if (results.phaseA?.[fileKey]?.[0]?.findings?.legalReferences) {
                results.phaseA[fileKey][0].findings.legalReferences.forEach(ref => {
                  if (ref.text) statutes.add(ref.text);
                });
              }
            });

            return Array.from(statutes);
          },

          // Build cross-references between documents
          buildCrossReferences(results) {
            const refs = {
              statutory: [],
              procedural: [],
              temporal: [],
              evidential: []
            };

            ['fileA', 'fileB'].forEach(fileKey => {
              if (results.phaseA?.[fileKey]?.[0]?.findings?.legalReferences) {
                results.phaseA[fileKey][0].findings.legalReferences.forEach(ref => {
                  refs.statutory.push({
                    text: ref.text,
                    type: ref.type,
                    source: fileKey,
                    relatedDefects: this.findRelatedDefects(ref.text, results)
                  });
                });
              }
            });

            return refs;
          },

          findRelatedDefects(reference, results) {
            const related = [];
            const refLower = reference.toLowerCase();

            ['fileA', 'fileB'].forEach(fileKey => {
              if (results.phaseA?.[fileKey]) {
                results.phaseA[fileKey].forEach(preset => {
                  const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                  if (Array.isArray(issues)) {
                    issues.forEach(issue => {
                      const desc = issue.description || issue;
                      if (typeof desc === 'string' && desc.toLowerCase().includes(refLower)) {
                        related.push({
                          preset: preset.preset,
                          type: issue.type,
                          severity: issue.severity
                        });
                      }
                    });
                  }
                });
              }
            });

            return related;
          },

          // PATTERN RECOGNITION: Update defect patterns
          async updateDefectPatterns(defects) {
            try {
              const db = await this.getDB();
              const tx = db.transaction('defect_patterns', 'readwrite');
              const store = tx.objectStore('defect_patterns');

              for (const defect of defects) {
                const defectKey = `${defect.type}_${defect.severity}`;

                // Try to find existing pattern
                const allPatterns = await new Promise((resolve, reject) => {
                  const request = store.getAll();
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = () => reject(request.error);
                });

                const existingPattern = allPatterns.find(p =>
                  p.defect_type === defect.type && p.description.includes(defect.description.substring(0, 50))
                );

                if (existingPattern) {
                  // Update existing pattern
                  existingPattern.occurrence_count++;
                  existingPattern.last_seen = new Date().toISOString();
                  existingPattern.associated_statutes = Array.from(new Set([
                    ...(existingPattern.associated_statutes || []),
                    ...(defect.statutes || [])
                  ]));

                  // Generate recommendation for recurring issues (3+ times)
                  if (existingPattern.occurrence_count >= 3 && !existingPattern.recommendation) {
                    existingPattern.recommendation = this.generateRecommendation(existingPattern);
                  }

                  await new Promise((resolve, reject) => {
                    const request = store.put(existingPattern);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                  });
                } else {
                  // Create new pattern
                  const newPattern = {
                    defect_type: defect.type,
                    description: defect.description,
                    first_seen: new Date().toISOString(),
                    last_seen: new Date().toISOString(),
                    occurrence_count: 1,
                    associated_statutes: defect.statutes || [],
                    recommendation: null
                  };

                  await new Promise((resolve, reject) => {
                    const request = store.add(newPattern);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                  });
                }
              }
            } catch (error) {
              console.error('Failed to update defect patterns:', error);
            }
          },

          // Generate recommendations for recurring defects
          generateRecommendation(pattern) {
            const recommendations = {
              'Missing s.55D directions': 'Systematic issue with preliminary test procedure documentation. Create checklist requiring explicit documentation of: oral directions given, written directions provided, subject\'s response to directions.',
              'Missing s.49(1) reason to believe': 'Document officer\'s subjective belief formation at time of demand. Include specific observations that led to reasonable belief.',
              'discrepancy': 'Cross-reference detected inconsistency. Verify timeline and ensure all document versions align.',
              'omission': 'Critical element missing from documentation. Implement mandatory field checklist for all required elements.',
              'admissibility': 'Evidence admissibility concerns detected. Review procedural compliance and statutory requirements.',
              'procedural': 'Procedural defect identified. Ensure strict adherence to statutory procedure timeline and requirements.'
            };

            for (const [key, recommendation] of Object.entries(recommendations)) {
              if (pattern.description.toLowerCase().includes(key.toLowerCase())) {
                return `${recommendation} (Occurred ${pattern.occurrence_count} times)`;
              }
            }

            return `This issue has occurred ${pattern.occurrence_count} times. Review procedural compliance and create systematic documentation checklist.`;
          },

          // Update statutory reference statistics
          async updateStatutoryReferences(statutes, defects) {
            try {
              const db = await this.getDB();
              const tx = db.transaction('statutory_references', 'readwrite');
              const store = tx.objectStore('statutory_references');

              for (const statute of statutes) {
                const existing = await new Promise((resolve, reject) => {
                  const request = store.get(statute);
                  request.onsuccess = () => resolve(request.result);
                  request.onerror = () => reject(request.error);
                });

                // Find defects related to this statute
                const relatedDefects = defects.filter(d =>
                  d.description.toLowerCase().includes(statute.toLowerCase())
                ).map(d => d.type);

                if (existing) {
                  // Update existing reference
                  existing.times_encountered++;
                  existing.associated_defects = Array.from(new Set([
                    ...(existing.associated_defects || []),
                    ...relatedDefects
                  ]));

                  // Calculate compliance rate (higher rate = fewer defects)
                  const totalDefects = relatedDefects.length;
                  existing.compliance_rate = Math.max(0, 100 - (totalDefects * 10));

                  await new Promise((resolve, reject) => {
                    const request = store.put(existing);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                  });
                } else {
                  // Create new reference
                  const newRef = {
                    reference: statute,
                    statute_name: this.parseStatuteName(statute),
                    times_encountered: 1,
                    associated_defects: relatedDefects,
                    compliance_rate: relatedDefects.length > 0 ? 90 : 100
                  };

                  await new Promise((resolve, reject) => {
                    const request = store.add(newRef);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                  });
                }
              }
            } catch (error) {
              console.error('Failed to update statutory references:', error);
            }
          },

          parseStatuteName(reference) {
            // Extract statute name from reference (e.g., "s.49(1) RSA" -> "Road Safety Act")
            const statuteMap = {
              'RSA': 'Road Safety Act 1986',
              'Crimes Act': 'Crimes Act 1958',
              'Evidence Act': 'Evidence Act 2008',
              'Magistrates': 'Magistrates\' Court Act'
            };

            for (const [key, name] of Object.entries(statuteMap)) {
              if (reference.includes(key)) return name;
            }

            return reference;
          },

          // Get all analyses
          async getAllAnalyses() {
            try {
              const db = await this.getDB();
              const tx = db.transaction('analyses', 'readonly');
              const store = tx.objectStore('analyses');

              return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
              });
            } catch (error) {
              console.error('Failed to retrieve analyses:', error);
              return [];
            }
          },

          // Get all defect patterns
          async getAllDefectPatterns() {
            try {
              const db = await this.getDB();
              const tx = db.transaction('defect_patterns', 'readonly');
              const store = tx.objectStore('defect_patterns');

              return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
              });
            } catch (error) {
              console.error('Failed to retrieve defect patterns:', error);
              return [];
            }
          },

          // Get all statutory references
          async getAllStatutoryReferences() {
            try {
              const db = await this.getDB();
              const tx = db.transaction('statutory_references', 'readonly');
              const store = tx.objectStore('statutory_references');

              return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
              });
            } catch (error) {
              console.error('Failed to retrieve statutory references:', error);
              return [];
            }
          },

          // CROSS-ANALYSIS INTELLIGENCE: Compare new analysis to history
          async getIntelligenceForAnalysis(currentDefects) {
            try {
              const allPatterns = await this.getAllDefectPatterns();
              const intelligence = [];

              for (const defect of currentDefects) {
                const matchingPattern = allPatterns.find(p =>
                  p.defect_type === defect.type &&
                  p.description.includes(defect.description.substring(0, 50))
                );

                if (matchingPattern) {
                  intelligence.push({
                    defect: defect,
                    isRecurring: matchingPattern.occurrence_count >= 3,
                    previousOccurrences: matchingPattern.occurrence_count,
                    firstSeen: matchingPattern.first_seen,
                    lastSeen: matchingPattern.last_seen,
                    recommendation: matchingPattern.recommendation,
                    isNovel: false
                  });
                } else {
                  intelligence.push({
                    defect: defect,
                    isRecurring: false,
                    previousOccurrences: 0,
                    isNovel: true,
                    recommendation: '‚ö†Ô∏è NEW ISSUE: This type of defect has not been encountered before.'
                  });
                }
              }

              return intelligence;
            } catch (error) {
              console.error('Failed to generate intelligence:', error);
              return [];
            }
          },

          // LEARNING INSIGHTS: Generate system intelligence summary
          async generateLearningInsights() {
            try {
              const analyses = await this.getAllAnalyses();
              const patterns = await this.getAllDefectPatterns();
              const statutes = await this.getAllStatutoryReferences();

              if (analyses.length === 0) {
                return {
                  totalAnalyses: 0,
                  totalDefects: 0,
                  mostCommonIssue: null,
                  recurringPatterns: [],
                  statuteCompliance: [],
                  temporalTrends: null,
                  recommendations: []
                };
              }

              // Calculate total defects
              const totalDefects = analyses.reduce((sum, a) => sum + (a.defects?.length || 0), 0);

              // Find most common issue
              const mostCommon = patterns.sort((a, b) => b.occurrence_count - a.occurrence_count)[0];

              // Find recurring patterns (3+ occurrences)
              const recurring = patterns.filter(p => p.occurrence_count >= 3);

              // Calculate temporal trends (comparing recent vs older analyses)
              const temporal = this.calculateTemporalTrends(analyses);

              // Generate process improvement recommendations
              const recommendations = this.generateProcessRecommendations(patterns, statutes);

              return {
                totalAnalyses: analyses.length,
                totalDefects: totalDefects,
                mostCommonIssue: mostCommon ? {
                  type: mostCommon.defect_type,
                  count: mostCommon.occurrence_count,
                  percentage: ((mostCommon.occurrence_count / totalDefects) * 100).toFixed(1)
                } : null,
                recurringPatterns: recurring,
                statuteCompliance: statutes.sort((a, b) => a.compliance_rate - b.compliance_rate).slice(0, 5),
                temporalTrends: temporal,
                recommendations: recommendations,
                newIssuesThisAnalysis: 0 // This will be set by the analyzer
              };
            } catch (error) {
              console.error('Failed to generate learning insights:', error);
              return null;
            }
          },

          // Calculate temporal trends
          calculateTemporalTrends(analyses) {
            if (analyses.length < 2) return null;

            const sorted = analyses.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const midpoint = Math.floor(sorted.length / 2);
            const older = sorted.slice(0, midpoint);
            const recent = sorted.slice(midpoint);

            const olderDefectCount = older.reduce((sum, a) => sum + (a.defects?.length || 0), 0);
            const recentDefectCount = recent.reduce((sum, a) => sum + (a.defects?.length || 0), 0);

            const olderAvg = older.length > 0 ? olderDefectCount / older.length : 0;
            const recentAvg = recent.length > 0 ? recentDefectCount / recent.length : 0;

            const trend = recentAvg < olderAvg ? 'improving' : recentAvg > olderAvg ? 'worsening' : 'stable';
            const changePercent = olderAvg > 0 ? (((recentAvg - olderAvg) / olderAvg) * 100).toFixed(1) : 0;

            return {
              trend: trend,
              changePercent: Math.abs(changePercent),
              direction: recentAvg < olderAvg ? 'decrease' : 'increase',
              olderAverage: olderAvg.toFixed(1),
              recentAverage: recentAvg.toFixed(1)
            };
          },

          // Generate process improvement recommendations
          generateProcessRecommendations(patterns, statutes) {
            const recommendations = [];

            // Recurring defect recommendations
            patterns.filter(p => p.occurrence_count >= 3).forEach(pattern => {
              if (pattern.recommendation) {
                recommendations.push({
                  type: 'recurring_defect',
                  priority: pattern.occurrence_count >= 5 ? 'HIGH' : 'MEDIUM',
                  issue: pattern.defect_type,
                  occurrences: pattern.occurrence_count,
                  recommendation: pattern.recommendation
                });
              }
            });

            // Low compliance statute recommendations
            statutes.filter(s => s.compliance_rate < 70).forEach(statute => {
              recommendations.push({
                type: 'statute_compliance',
                priority: 'HIGH',
                statute: statute.reference,
                complianceRate: statute.compliance_rate,
                recommendation: `${statute.reference} has low compliance (${statute.compliance_rate}%). Review procedural requirements and create targeted training.`
              });
            });

            return recommendations;
          }
        };

        // Enhanced Timeline Visualization Component with Filtering
        const DefectTimeline = ({ analyses }) => {
          const [selectedDefect, setSelectedDefect] = useState(null);
          const [filters, setFilters] = useState({
            dateRange: 'all', // all, last7, last30, last90
            defectType: 'all',
            severity: 'all',
            statute: 'all'
          });
          const [expandedAnalysis, setExpandedAnalysis] = useState(null);

          // Extract unique values for filters
          const filterOptions = React.useMemo(() => {
            if (!analyses || analyses.length === 0) return { types: [], severities: [], statutes: [] };

            const types = new Set();
            const severities = new Set();
            const statutes = new Set();

            analyses.forEach(analysis => {
              if (analysis.defects) {
                analysis.defects.forEach(defect => {
                  types.add(defect.type);
                  severities.add(defect.severity);
                });
              }
              if (analysis.statutory_references) {
                analysis.statutory_references.forEach(ref => statutes.add(ref));
              }
            });

            return {
              types: Array.from(types),
              severities: Array.from(severities),
              statutes: Array.from(statutes)
            };
          }, [analyses]);

          // Filter analyses based on selected filters
          const filteredAnalyses = React.useMemo(() => {
            if (!analyses || analyses.length === 0) return [];

            let filtered = [...analyses];

            // Date range filter
            if (filters.dateRange !== 'all') {
              const now = new Date();
              const daysMap = { last7: 7, last30: 30, last90: 90 };
              const days = daysMap[filters.dateRange];
              const cutoff = new Date(now - days * 24 * 60 * 60 * 1000);

              filtered = filtered.filter(a => new Date(a.timestamp) >= cutoff);
            }

            // Defect type filter
            if (filters.defectType !== 'all') {
              filtered = filtered.filter(a =>
                a.defects?.some(d => d.type === filters.defectType)
              );
            }

            // Severity filter
            if (filters.severity !== 'all') {
              filtered = filtered.filter(a =>
                a.defects?.some(d => d.severity === filters.severity)
              );
            }

            // Statute filter
            if (filters.statute !== 'all') {
              filtered = filtered.filter(a =>
                a.statutory_references?.includes(filters.statute)
              );
            }

            return filtered.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
          }, [analyses, filters]);

          if (!analyses || analyses.length === 0) {
            return (
              <div style={{ padding: '20px', backgroundColor: '#f9fafb', textAlign: 'center' }}>
                <p style={{ color: '#6b7280' }}>No historical analysis data available yet. Complete analyses will appear here over time.</p>
              </div>
            );
          }

          const getSeverityColor = (severity) => {
            const colors = {
              'CRITICAL': '#dc2626',
              'HIGH': '#f59e0b',
              'MEDIUM': '#3b82f6',
              'LOW': '#10b981'
            };
            return colors[severity?.toUpperCase()] || '#6b7280';
          };

          return (
            <div style={{ padding: '20px', backgroundColor: '#f9fafb' }}>
              <h3 style={{ marginBottom: '16px' }}>üìä Chronological Analysis Timeline</h3>

              {/* Filters */}
              <div style={{
                marginBottom: '20px',
                padding: '16px',
                backgroundColor: 'white',
                borderRadius: '8px',
                boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
              }}>
                <h4 style={{ marginBottom: '12px', fontSize: '14px' }}>Filter Results</h4>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '12px' }}>
                  {/* Date Range */}
                  <div>
                    <label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}>
                      Date Range
                    </label>
                    <select
                      value={filters.dateRange}
                      onChange={(e) => setFilters({...filters, dateRange: e.target.value})}
                      style={{
                        width: '100%',
                        padding: '6px 8px',
                        borderRadius: '4px',
                        border: '1px solid #d1d5db',
                        fontSize: '13px'
                      }}
                    >
                      <option value="all">All Time</option>
                      <option value="last7">Last 7 Days</option>
                      <option value="last30">Last 30 Days</option>
                      <option value="last90">Last 90 Days</option>
                    </select>
                  </div>

                  {/* Defect Type */}
                  <div>
                    <label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}>
                      Defect Type
                    </label>
                    <select
                      value={filters.defectType}
                      onChange={(e) => setFilters({...filters, defectType: e.target.value})}
                      style={{
                        width: '100%',
                        padding: '6px 8px',
                        borderRadius: '4px',
                        border: '1px solid #d1d5db',
                        fontSize: '13px'
                      }}
                    >
                      <option value="all">All Types</option>
                      {filterOptions.types.map(type => (
                        <option key={type} value={type}>{type}</option>
                      ))}
                    </select>
                  </div>

                  {/* Severity */}
                  <div>
                    <label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}>
                      Severity Level
                    </label>
                    <select
                      value={filters.severity}
                      onChange={(e) => setFilters({...filters, severity: e.target.value})}
                      style={{
                        width: '100%',
                        padding: '6px 8px',
                        borderRadius: '4px',
                        border: '1px solid #d1d5db',
                        fontSize: '13px'
                      }}
                    >
                      <option value="all">All Severities</option>
                      {filterOptions.severities.map(sev => (
                        <option key={sev} value={sev}>{sev}</option>
                      ))}
                    </select>
                  </div>

                  {/* Statute */}
                  <div>
                    <label style={{ display: 'block', fontSize: '12px', marginBottom: '4px', color: '#6b7280' }}>
                      Statute Referenced
                    </label>
                    <select
                      value={filters.statute}
                      onChange={(e) => setFilters({...filters, statute: e.target.value})}
                      style={{
                        width: '100%',
                        padding: '6px 8px',
                        borderRadius: '4px',
                        border: '1px solid #d1d5db',
                        fontSize: '13px'
                      }}
                    >
                      <option value="all">All Statutes</option>
                      {filterOptions.statutes.map(stat => (
                        <option key={stat} value={stat}>{stat}</option>
                      ))}
                    </select>
                  </div>
                </div>

                <div style={{ marginTop: '12px', fontSize: '12px', color: '#6b7280' }}>
                  Showing {filteredAnalyses.length} of {analyses.length} analyses
                </div>
              </div>

              {/* Timeline Items */}
              <div style={{ position: 'relative' }}>
                {/* Timeline line */}
                <div style={{
                  position: 'absolute',
                  left: '20px',
                  top: '0',
                  bottom: '0',
                  width: '2px',
                  backgroundColor: '#d1d5db'
                }} />

                {filteredAnalyses.map((analysis, idx) => {
                  const isExpanded = expandedAnalysis === analysis.id;
                  const defectCount = analysis.defects?.length || 0;
                  const severitySummary = analysis.severity_summary || {};

                  return (
                    <div key={analysis.id || idx} style={{
                      position: 'relative',
                      marginLeft: '40px',
                      marginBottom: '20px',
                      padding: '16px',
                      backgroundColor: 'white',
                      borderRadius: '8px',
                      boxShadow: '0 1px 3px rgba(0,0,0,0.1)',
                      cursor: 'pointer',
                      transition: 'all 0.2s'
                    }}
                    onClick={() => setExpandedAnalysis(isExpanded ? null : analysis.id)}
                    onMouseEnter={(e) => e.currentTarget.style.boxShadow = '0 4px 6px rgba(0,0,0,0.15)'}
                    onMouseLeave={(e) => e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)'}
                    >
                      {/* Timeline dot */}
                      <div style={{
                        position: 'absolute',
                        left: '-31px',
                        top: '20px',
                        width: '12px',
                        height: '12px',
                        borderRadius: '50%',
                        backgroundColor: defectCount > 5 ? '#dc2626' : defectCount > 2 ? '#f59e0b' : '#10b981',
                        border: '2px solid white',
                        boxShadow: '0 0 0 2px #d1d5db'
                      }} />

                      {/* Analysis Header */}
                      <div style={{ marginBottom: '12px' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                          <div>
                            <div style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                              {new Date(analysis.timestamp).toLocaleString()}
                            </div>
                            <div style={{ fontWeight: '600', fontSize: '14px' }}>
                              Analysis #{analysis.id}
                            </div>
                          </div>
                          <div style={{ textAlign: 'right' }}>
                            <div style={{ fontSize: '24px', fontWeight: 'bold', color: defectCount > 5 ? '#dc2626' : '#6b7280' }}>
                              {defectCount}
                            </div>
                            <div style={{ fontSize: '11px', color: '#6b7280' }}>defects</div>
                          </div>
                        </div>

                        <div style={{ fontSize: '13px', color: '#4b5563', marginTop: '8px' }}>
                          <div>üìÑ {analysis.fileAName}</div>
                          <div>üìÑ {analysis.fileBName}</div>
                        </div>
                      </div>

                      {/* Severity Summary */}
                      <div style={{ display: 'flex', gap: '8px', marginTop: '8px' }}>
                        {Object.entries(severitySummary).map(([severity, count]) => (
                          count > 0 && (
                            <span key={severity} style={{
                              padding: '2px 8px',
                              borderRadius: '12px',
                              fontSize: '11px',
                              backgroundColor: getSeverityColor(severity) + '20',
                              color: getSeverityColor(severity),
                              fontWeight: '600'
                            }}>
                              {severity}: {count}
                            </span>
                          )
                        ))}
                      </div>

                      {/* Expanded Details */}
                      {isExpanded && (
                        <div style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid #e5e7eb' }}>
                          <h5 style={{ marginBottom: '8px', fontSize: '13px', fontWeight: '600' }}>Defects Found:</h5>
                          {analysis.defects?.map((defect, didx) => (
                            <div key={didx} style={{
                              padding: '8px',
                              marginBottom: '6px',
                              backgroundColor: '#f9fafb',
                              borderRadius: '4px',
                              borderLeft: `3px solid ${getSeverityColor(defect.severity)}`,
                              fontSize: '12px'
                            }}>
                              <div style={{ fontWeight: '600', color: getSeverityColor(defect.severity) }}>
                                {defect.severity} - {defect.type}
                              </div>
                              <div style={{ color: '#4b5563', marginTop: '4px' }}>
                                {defect.description}
                              </div>
                            </div>
                          ))}

                          {analysis.statutory_references && analysis.statutory_references.length > 0 && (
                            <div style={{ marginTop: '12px' }}>
                              <h5 style={{ marginBottom: '6px', fontSize: '13px', fontWeight: '600' }}>Statutes Referenced:</h5>
                              <div style={{ fontSize: '12px', color: '#6b7280' }}>
                                {analysis.statutory_references.join(', ')}
                              </div>
                            </div>
                          )}
                        </div>
                      )}

                      <div style={{ fontSize: '11px', color: '#9ca3af', marginTop: '8px', textAlign: 'right' }}>
                        Click to {isExpanded ? 'collapse' : 'expand'} details
                      </div>
                    </div>
                  );
                })}
              </div>

              {filteredAnalyses.length === 0 && (
                <div style={{ textAlign: 'center', padding: '40px', color: '#6b7280' }}>
                  No analyses match the selected filters.
                </div>
              )}
            </div>
          );
        };

        // Learning Insights Panel Component
        const LearningInsightsPanel = ({ insights, currentDefects }) => {
          if (!insights) {
            return (
              <div style={{
                padding: '20px',
                backgroundColor: '#f9fafb',
                borderRadius: '8px',
                textAlign: 'center',
                color: '#6b7280'
              }}>
                <p>Loading intelligence summary...</p>
              </div>
            );
          }

          if (insights.totalAnalyses === 0) {
            return (
              <div style={{
                padding: '20px',
                backgroundColor: '#e0f2fe',
                borderRadius: '8px',
                border: '1px solid #0284c7'
              }}>
                <h3 style={{ marginBottom: '12px', color: '#0284c7' }}>üìä System Intelligence Summary</h3>
                <p style={{ color: '#0c4a6e' }}>
                  No historical data yet. This system will learn from each analysis and provide intelligent insights over time.
                </p>
              </div>
            );
          }

          const { temporalTrends } = insights;
          const trendIcon = temporalTrends?.trend === 'improving' ? 'üìà‚úÖ' : temporalTrends?.trend === 'worsening' ? 'üìâ‚ö†Ô∏è' : '‚û°Ô∏è';
          const trendColor = temporalTrends?.trend === 'improving' ? '#10b981' : temporalTrends?.trend === 'worsening' ? '#dc2626' : '#6b7280';

          return (
            <div style={{
              padding: '24px',
              backgroundColor: 'white',
              borderRadius: '12px',
              boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
              marginBottom: '24px'
            }}>
              <h3 style={{
                marginBottom: '20px',
                fontSize: '20px',
                fontWeight: '700',
                color: '#1f2937',
                borderBottom: '2px solid #e5e7eb',
                paddingBottom: '12px'
              }}>
                üìä System Intelligence Summary
              </h3>

              {/* Summary Stats */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))',
                gap: '16px',
                marginBottom: '24px'
              }}>
                <div style={{
                  padding: '16px',
                  backgroundColor: '#eff6ff',
                  borderRadius: '8px',
                  borderLeft: '4px solid #3b82f6'
                }}>
                  <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#1e40af' }}>
                    {insights.totalAnalyses}
                  </div>
                  <div style={{ fontSize: '12px', color: '#1e40af', marginTop: '4px' }}>
                    Total Analyses
                  </div>
                </div>

                <div style={{
                  padding: '16px',
                  backgroundColor: '#fef3c7',
                  borderRadius: '8px',
                  borderLeft: '4px solid #f59e0b'
                }}>
                  <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#92400e' }}>
                    {insights.totalDefects}
                  </div>
                  <div style={{ fontSize: '12px', color: '#92400e', marginTop: '4px' }}>
                    Total Defects Found
                  </div>
                </div>

                {currentDefects && (
                  <div style={{
                    padding: '16px',
                    backgroundColor: '#f0fdf4',
                    borderRadius: '8px',
                    borderLeft: '4px solid #10b981'
                  }}>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#065f46' }}>
                      {currentDefects.filter(d => d.isNovel).length}
                    </div>
                    <div style={{ fontSize: '12px', color: '#065f46', marginTop: '4px' }}>
                      New Issues This Analysis
                    </div>
                  </div>
                )}

                {temporalTrends && (
                  <div style={{
                    padding: '16px',
                    backgroundColor: temporalTrends.trend === 'improving' ? '#f0fdf4' : temporalTrends.trend === 'worsening' ? '#fee2e2' : '#f9fafb',
                    borderRadius: '8px',
                    borderLeft: `4px solid ${trendColor}`
                  }}>
                    <div style={{ fontSize: '22px', fontWeight: 'bold', color: trendColor }}>
                      {trendIcon} {temporalTrends.changePercent}%
                    </div>
                    <div style={{ fontSize: '12px', color: trendColor, marginTop: '4px' }}>
                      {temporalTrends.trend.charAt(0).toUpperCase() + temporalTrends.trend.slice(1)} Trend
                    </div>
                  </div>
                )}
              </div>

              {/* Most Common Issue */}
              {insights.mostCommonIssue && (
                <div style={{
                  padding: '16px',
                  backgroundColor: '#fef2f2',
                  borderRadius: '8px',
                  marginBottom: '20px',
                  border: '1px solid #fecaca'
                }}>
                  <h4 style={{ fontSize: '14px', fontWeight: '600', color: '#991b1b', marginBottom: '8px' }}>
                    ‚ö†Ô∏è Most Common Issue
                  </h4>
                  <div style={{ fontSize: '13px', color: '#7f1d1d' }}>
                    <strong>{insights.mostCommonIssue.type}</strong>
                    <div style={{ marginTop: '4px' }}>
                      Occurred {insights.mostCommonIssue.count} times ({insights.mostCommonIssue.percentage}% of all defects)
                    </div>
                  </div>
                </div>
              )}

              {/* Recurring Patterns */}
              {insights.recurringPatterns && insights.recurringPatterns.length > 0 && (
                <div style={{ marginBottom: '20px' }}>
                  <h4 style={{ fontSize: '15px', fontWeight: '600', color: '#1f2937', marginBottom: '12px' }}>
                    üîÑ Recurring Patterns (3+ occurrences)
                  </h4>
                  {insights.recurringPatterns.slice(0, 3).map((pattern, idx) => (
                    <div key={idx} style={{
                      padding: '12px',
                      backgroundColor: '#fff7ed',
                      borderRadius: '6px',
                      marginBottom: '10px',
                      borderLeft: '3px solid #f59e0b'
                    }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                        <div style={{ flex: 1 }}>
                          <div style={{ fontSize: '13px', fontWeight: '600', color: '#92400e' }}>
                            {pattern.defect_type}
                          </div>
                          <div style={{ fontSize: '12px', color: '#78350f', marginTop: '4px' }}>
                            {pattern.description.substring(0, 100)}{pattern.description.length > 100 ? '...' : ''}
                          </div>
                          {pattern.recommendation && (
                            <div style={{
                              marginTop: '8px',
                              padding: '8px',
                              backgroundColor: '#fffbeb',
                              borderRadius: '4px',
                              fontSize: '12px',
                              color: '#78350f'
                            }}>
                              <strong>üí° Recommendation:</strong> {pattern.recommendation}
                            </div>
                          )}
                        </div>
                        <div style={{
                          marginLeft: '12px',
                          padding: '4px 12px',
                          backgroundColor: '#f59e0b',
                          color: 'white',
                          borderRadius: '12px',
                          fontSize: '12px',
                          fontWeight: '600',
                          whiteSpace: 'nowrap'
                        }}>
                          {pattern.occurrence_count}x
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Statute Compliance */}
              {insights.statuteCompliance && insights.statuteCompliance.length > 0 && (
                <div style={{ marginBottom: '20px' }}>
                  <h4 style={{ fontSize: '15px', fontWeight: '600', color: '#1f2937', marginBottom: '12px' }}>
                    ‚öñÔ∏è Statute Compliance Rates (Lowest First)
                  </h4>
                  {insights.statuteCompliance.map((statute, idx) => (
                    <div key={idx} style={{
                      padding: '10px',
                      backgroundColor: statute.compliance_rate < 70 ? '#fef2f2' : '#f0fdf4',
                      borderRadius: '6px',
                      marginBottom: '8px',
                      display: 'flex',
                      justifyContent: 'space-between',
                      alignItems: 'center',
                      border: statute.compliance_rate < 70 ? '1px solid #fecaca' : '1px solid #bbf7d0'
                    }}>
                      <div>
                        <div style={{ fontSize: '13px', fontWeight: '600', color: statute.compliance_rate < 70 ? '#991b1b' : '#065f46' }}>
                          {statute.reference}
                        </div>
                        <div style={{ fontSize: '11px', color: '#6b7280', marginTop: '2px' }}>
                          {statute.statute_name}
                        </div>
                      </div>
                      <div style={{
                        padding: '4px 12px',
                        backgroundColor: statute.compliance_rate < 70 ? '#dc2626' : statute.compliance_rate < 85 ? '#f59e0b' : '#10b981',
                        color: 'white',
                        borderRadius: '12px',
                        fontSize: '12px',
                        fontWeight: '600'
                      }}>
                        {statute.compliance_rate}%
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Process Improvement Recommendations */}
              {insights.recommendations && insights.recommendations.length > 0 && (
                <div style={{
                  padding: '16px',
                  backgroundColor: '#e0f2fe',
                  borderRadius: '8px',
                  border: '1px solid #0284c7'
                }}>
                  <h4 style={{ fontSize: '15px', fontWeight: '600', color: '#075985', marginBottom: '12px' }}>
                    üí° Recommended Process Improvements
                  </h4>
                  {insights.recommendations.map((rec, idx) => (
                    <div key={idx} style={{
                      padding: '10px',
                      backgroundColor: 'white',
                      borderRadius: '6px',
                      marginBottom: '8px',
                      borderLeft: `3px solid ${rec.priority === 'HIGH' ? '#dc2626' : '#f59e0b'}`
                    }}>
                      <div style={{ display: 'flex', alignItems: 'start', gap: '8px' }}>
                        <span style={{
                          padding: '2px 6px',
                          backgroundColor: rec.priority === 'HIGH' ? '#dc2626' : '#f59e0b',
                          color: 'white',
                          borderRadius: '4px',
                          fontSize: '10px',
                          fontWeight: '600',
                          marginTop: '2px'
                        }}>
                          {rec.priority}
                        </span>
                        <div style={{ flex: 1 }}>
                          <div style={{ fontSize: '12px', fontWeight: '600', color: '#1f2937', marginBottom: '4px' }}>
                            {rec.issue || rec.statute}
                            {rec.occurrences && ` (${rec.occurrences}x)`}
                            {rec.complianceRate && ` - ${rec.complianceRate}% compliance`}
                          </div>
                          <div style={{ fontSize: '12px', color: '#4b5563' }}>
                            {rec.recommendation}
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {/* Temporal Trends Detail */}
              {temporalTrends && (
                <div style={{
                  marginTop: '20px',
                  padding: '12px',
                  backgroundColor: '#f9fafb',
                  borderRadius: '6px',
                  fontSize: '12px',
                  color: '#4b5563'
                }}>
                  <strong>üìà Trend Analysis:</strong> {' '}
                  {temporalTrends.trend === 'improving' && (
                    `Compliance improvement detected. Recent analyses average ${temporalTrends.recentAverage} defects vs ${temporalTrends.olderAverage} previously (${temporalTrends.changePercent}% improvement). Continue current documentation practices.`
                  )}
                  {temporalTrends.trend === 'worsening' && (
                    `Compliance decline detected. Recent analyses average ${temporalTrends.recentAverage} defects vs ${temporalTrends.olderAverage} previously (${temporalTrends.changePercent}% increase). Review recent procedural changes.`
                  )}
                  {temporalTrends.trend === 'stable' && (
                    `Compliance rates remain stable. Recent and historical defect rates are consistent.`
                  )}
                </div>
              )}
            </div>
          );
        };

        // Cross-Analysis Intelligence Display Component
        const CrossAnalysisIntelligence = ({ intelligence }) => {
          if (!intelligence || intelligence.length === 0) {
            return null;
          }

          const recurringIssues = intelligence.filter(i => i.isRecurring);
          const novelIssues = intelligence.filter(i => i.isNovel);

          return (
            <div style={{
              padding: '20px',
              backgroundColor: '#f9fafb',
              borderRadius: '8px',
              marginBottom: '20px'
            }}>
              <h3 style={{ marginBottom: '16px', fontSize: '18px', fontWeight: '600' }}>
                üîç Cross-Analysis Intelligence
              </h3>

              {novelIssues.length > 0 && (
                <div style={{ marginBottom: '16px' }}>
                  <h4 style={{ fontSize: '14px', fontWeight: '600', color: '#0284c7', marginBottom: '8px' }}>
                    ‚ö†Ô∏è NEW: {novelIssues.length} Novel Issue{novelIssues.length > 1 ? 's' : ''} Detected
                  </h4>
                  {novelIssues.map((item, idx) => (
                    <div key={idx} style={{
                      padding: '12px',
                      backgroundColor: '#e0f2fe',
                      borderRadius: '6px',
                      marginBottom: '8px',
                      border: '1px solid #0284c7'
                    }}>
                      <div style={{ fontSize: '13px', fontWeight: '600', color: '#075985' }}>
                        {item.defect.type} - {item.defect.severity}
                      </div>
                      <div style={{ fontSize: '12px', color: '#0c4a6e', marginTop: '4px' }}>
                        {item.defect.description}
                      </div>
                      <div style={{ fontSize: '12px', color: '#0369a1', marginTop: '6px', fontStyle: 'italic' }}>
                        üí° {item.recommendation}
                      </div>
                    </div>
                  ))}
                </div>
              )}

              {recurringIssues.length > 0 && (
                <div>
                  <h4 style={{ fontSize: '14px', fontWeight: '600', color: '#dc2626', marginBottom: '8px' }}>
                    üîÑ RECURRING: {recurringIssues.length} Previously Seen Issue{recurringIssues.length > 1 ? 's' : ''}
                  </h4>
                  {recurringIssues.map((item, idx) => (
                    <div key={idx} style={{
                      padding: '12px',
                      backgroundColor: '#fef2f2',
                      borderRadius: '6px',
                      marginBottom: '8px',
                      border: '1px solid #fecaca'
                    }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
                        <div style={{ flex: 1 }}>
                          <div style={{ fontSize: '13px', fontWeight: '600', color: '#991b1b' }}>
                            {item.defect.type} - {item.defect.severity}
                          </div>
                          <div style={{ fontSize: '12px', color: '#7f1d1d', marginTop: '4px' }}>
                            {item.defect.description}
                          </div>
                          <div style={{ fontSize: '11px', color: '#991b1b', marginTop: '6px' }}>
                            üìä Previously occurred <strong>{item.previousOccurrences}</strong> time{item.previousOccurrences > 1 ? 's' : ''}
                            <br />
                            First seen: {new Date(item.firstSeen).toLocaleDateString()}
                            <br />
                            Last seen: {new Date(item.lastSeen).toLocaleDateString()}
                          </div>
                          {item.recommendation && (
                            <div style={{
                              marginTop: '8px',
                              padding: '8px',
                              backgroundColor: '#fff7ed',
                              borderRadius: '4px',
                              fontSize: '12px',
                              color: '#92400e',
                              border: '1px solid #fed7aa'
                            }}>
                              <strong>üí° Systematic Recommendation:</strong> {item.recommendation}
                            </div>
                          )}
                        </div>
                        <span style={{
                          padding: '4px 10px',
                          backgroundColor: '#dc2626',
                          color: 'white',
                          borderRadius: '12px',
                          fontSize: '12px',
                          fontWeight: '600',
                          whiteSpace: 'nowrap',
                          marginLeft: '12px'
                        }}>
                          {item.previousOccurrences}x
                        </span>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          );
        };

        // Pattern Recognition Engine
        const PatternDetector = {
          async analyze(currentAnalysis, historicalAnalyses) {
            const patterns = {
              recurring: [],
              emerging: [],
              resolved: []
            };

            // Find recurring defects
            const defectCounts = {};
            historicalAnalyses.forEach(analysis => {
              if (analysis.defects) {
                analysis.defects.forEach(defect => {
                  const key = `${defect.type}|${defect.description}`;
                  defectCounts[key] = (defectCounts[key] || 0) + 1;
                });
              }
            });

            // Identify patterns
            Object.entries(defectCounts).forEach(([key, count]) => {
              if (count >= 3) {
                const [type, description] = key.split('|');
                patterns.recurring.push({
                  type,
                  description,
                  frequency: count,
                  firstSeen: this.findFirstOccurrence(type, description, historicalAnalyses),
                  lastSeen: this.findLastOccurrence(type, description, historicalAnalyses),
                  recommendation: this.generateRecommendation(type, description, count)
                });
              }
            });

            return patterns;
          },

          findFirstOccurrence(type, description, analyses) {
            for (let analysis of analyses) {
              if (analysis.defects) {
                const found = analysis.defects.find(d => d.type === type && d.description === description);
                if (found) return analysis.timestamp;
              }
            }
            return null;
          },

          findLastOccurrence(type, description, analyses) {
            for (let i = analyses.length - 1; i >= 0; i--) {
              if (analyses[i].defects) {
                const found = analyses[i].defects.find(d => d.type === type && d.description === description);
                if (found) return analyses[i].timestamp;
              }
            }
            return null;
          },

          generateRecommendation(type, description, frequency) {
            const recommendations = {
              'Missing Statutory Reference': `After ${frequency} occurrences, consider creating a checklist template that includes all required statutory references for this document type.`,
              'Mixed Mandatory/Discretionary Language': `This language ambiguity has appeared ${frequency} times. Recommend standardizing document language to use either "must/shall" OR "may" consistently, with clear section separation.`,
              'Insufficient Detail': `Documents consistently lack detail. Create minimum content guidelines specifying required sections and minimum line/word counts.`,
              'Acknowledged Defect': `Errors acknowledged ${frequency} times suggests a review process gap. Implement mandatory peer review before document finalization.`,
              'Missing Primary Legislation': `After ${frequency} occurrences, consider creating a checklist template that includes all required statutory references for this document type.`,
              'Insufficient Substantive Content': `Documents consistently lack detail. Create minimum content guidelines specifying required sections and minimum line/word counts.`
            };

            return recommendations[type] || `Recurring issue (${frequency}x). Systematic review and process improvement recommended.`;
          }
        };

        // Helper function: Get color for severity
        const getColorForSeverity = (severity) => {
          const colors = {
            'critical': '#fecaca',
            'high': '#fed7aa',
            'medium': '#fef3c7',
            'low': '#dbeafe'
          };
          return colors[severity] || '#f3f4f6';
        };

        // Helper function: Find defects related to a reference
        const findDefectsForReference = (reference, analysis) => {
          const related = [];
          const refLower = reference.toLowerCase();

          ['fileA', 'fileB'].forEach(fileKey => {
            if (analysis.phaseA && analysis.phaseA[fileKey]) {
              analysis.phaseA[fileKey].forEach(preset => {
                const potentialIssues = preset.findings.potentialIssues;
                const issues = potentialIssues.issues || potentialIssues;

                if (Array.isArray(issues)) {
                  issues.forEach(issue => {
                    if (issue.description && issue.description.toLowerCase().includes(refLower)) {
                      related.push({
                        type: issue.type,
                        severity: issue.severity,
                        description: issue.description
                      });
                    }
                  });
                }
              });
            }
          });

          return related;
        };

        // Helper function: Build matrix
        const buildMatrix = (analysis) => {
          const matrix = [];

          // Get all statutory references
          const refs = [];
          if (analysis.phaseA) {
            ['fileA', 'fileB'].forEach(fileKey => {
              if (analysis.phaseA[fileKey] && analysis.phaseA[fileKey][0] &&
                  analysis.phaseA[fileKey][0].findings &&
                  analysis.phaseA[fileKey][0].findings.legalReferences) {
                refs.push(...analysis.phaseA[fileKey][0].findings.legalReferences);
              }
            });
          }

          // Remove duplicates
          const uniqueRefs = [];
          const seen = new Set();
          refs.forEach(ref => {
            const key = `${ref.type}:${ref.text}`.toLowerCase();
            if (!seen.has(key)) {
              seen.add(key);
              uniqueRefs.push(ref);
            }
          });

          uniqueRefs.forEach(ref => {
            const relatedDefects = findDefectsForReference(ref.text, analysis);
            const highSeverity = relatedDefects.filter(d =>
              d.severity === 'high' || d.severity === 'critical'
            );
            const compliant = highSeverity.length === 0;

            matrix.push({
              statute: ref.text,
              section: ref.type,
              defects: relatedDefects.slice(0, 5), // Limit to 5 for display
              compliant: compliant,
              action: determineAction(relatedDefects, compliant)
            });
          });

          return matrix;
        };

        // Helper function: Determine action
        const determineAction = (defects, compliant) => {
          if (compliant) return 'No action required - monitoring';

          const highSeverity = defects.filter(d =>
            d.severity === 'high' || d.severity === 'critical'
          );
          if (highSeverity.length > 0) {
            return '‚ö†Ô∏è URGENT: Review and address high-severity issues immediately';
          }

          return 'üìã Review medium/low issues and plan remediation';
        };

        // Helper function: Detect patterns from historical data
        const detectPatterns = (historicalAnalyses) => {
          if (!historicalAnalyses || historicalAnalyses.length === 0) return [];

          const patternCounts = {};

          historicalAnalyses.forEach(analysis => {
            if (analysis.defects) {
              analysis.defects.forEach(defect => {
                const key = `${defect.type}|${defect.severity}`;
                if (!patternCounts[key]) {
                  patternCounts[key] = {
                    type: defect.type,
                    severity: defect.severity,
                    count: 0,
                    descriptions: []
                  };
                }
                patternCounts[key].count++;
                if (patternCounts[key].descriptions.length < 3) {
                  patternCounts[key].descriptions.push(defect.description);
                }
              });
            }
          });

          return Object.values(patternCounts).filter(p => p.count >= 2);
        };

        // Cross-Reference Matrix Component
        const CrossReferenceMatrix = ({ analysis }) => {
          const matrix = React.useMemo(() => buildMatrix(analysis), [analysis]);

          if (!matrix || matrix.length === 0) {
            return (
              <div style={{ padding: '20px', backgroundColor: '#f9fafb', textAlign: 'center' }}>
                <p style={{ color: '#6b7280' }}>No statutory references found to create cross-reference matrix.</p>
              </div>
            );
          }

          return (
            <div style={{ padding: '20px' }}>
              <h3>üîó Cross-Reference Matrix</h3>
              <p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '16px' }}>
                Relationships between statutory references and identified defects
              </p>

              <table style={{
                width: '100%',
                borderCollapse: 'collapse',
                backgroundColor: 'white',
                boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
                borderRadius: '8px',
                overflow: 'hidden'
              }}>
                <thead>
                  <tr style={{ backgroundColor: '#f3f4f6' }}>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Statutory Reference</th>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Related Defects</th>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Compliance Status</th>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Action Required</th>
                  </tr>
                </thead>
                <tbody>
                  {matrix.map((row, idx) => (
                    <tr key={idx} style={{ borderBottom: '1px solid #e5e7eb' }}>
                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                        <strong style={{ fontSize: '14px' }}>{row.statute}</strong>
                        <br />
                        <span style={{ fontSize: '12px', color: '#666' }}>
                          {row.section}
                        </span>
                      </td>
                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                        {row.defects.length > 0 ? (
                          row.defects.map((d, i) => (
                            <div key={i} style={{
                              padding: '4px 8px',
                              marginBottom: '4px',
                              backgroundColor: getColorForSeverity(d.severity),
                              borderRadius: '4px',
                              fontSize: '12px',
                              border: '1px solid #e5e7eb'
                            }}>
                              <strong>[{d.severity.toUpperCase()}]</strong> {d.type}
                            </div>
                          ))
                        ) : (
                          <span style={{ fontSize: '12px', color: '#6b7280' }}>No related defects</span>
                        )}
                      </td>
                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                        <span style={{
                          padding: '4px 12px',
                          borderRadius: '12px',
                          fontSize: '12px',
                          fontWeight: '600',
                          backgroundColor: row.compliant ? '#d1fae5' : '#fee2e2',
                          color: row.compliant ? '#065f46' : '#991b1b'
                        }}>
                          {row.compliant ? '‚úÖ Compliant' : '‚ö†Ô∏è Non-Compliant'}
                        </span>
                      </td>
                      <td style={{ padding: '12px', fontSize: '13px', verticalAlign: 'top' }}>
                        {row.action}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          );
        };

        // Contextual Intelligence Enhancement
        const ContextualIntelligence = {
          async enhanceFindings(currentAnalysis, historicalAnalyses) {
            return {
              ...currentAnalysis,
              contextualInsights: {
                // Compare current to historical average
                severity: this.compareSeverity(currentAnalysis, historicalAnalyses),

                // Identify if issues are worsening or improving
                trend: this.analyzeTrend(currentAnalysis, historicalAnalyses),

                // Suggest specific actions based on patterns
                recommendations: this.generateSmartRecommendations(currentAnalysis, historicalAnalyses),

                // Highlight new issue types never seen before
                novelIssues: this.identifyNovelIssues(currentAnalysis, historicalAnalyses)
              }
            };
          },

          countSeverity(analysis, severity) {
            let count = 0;
            if (analysis.findings && analysis.findings.phaseA) {
              ['fileA', 'fileB'].forEach(fileKey => {
                if (analysis.findings.phaseA[fileKey]) {
                  analysis.findings.phaseA[fileKey].forEach(preset => {
                    const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                    if (Array.isArray(issues)) {
                      count += issues.filter(i => i.severity === severity).length;
                    }
                  });
                }
              });
            } else if (analysis.defects) {
              count = analysis.defects.filter(d => d.severity === severity).length;
            }
            return count;
          },

          compareSeverity(current, historical) {
            if (!historical || historical.length === 0) {
              return {
                status: 'baseline',
                message: 'This is your first analysis - establishing baseline metrics'
              };
            }

            const currentHigh = this.countSeverity({ findings: current }, 'high');
            const currentCritical = this.countSeverity({ findings: current }, 'critical');
            const currentTotal = currentHigh + currentCritical;

            const avgHigh = historical.reduce((sum, a) =>
              sum + this.countSeverity(a, 'high'), 0) / historical.length;
            const avgCritical = historical.reduce((sum, a) =>
              sum + this.countSeverity(a, 'critical'), 0) / historical.length;
            const avgTotal = avgHigh + avgCritical;

            if (avgTotal === 0) {
              return {
                status: 'baseline',
                message: 'Insufficient historical data for comparison'
              };
            }

            if (currentTotal > avgTotal * 1.5) {
              return {
                status: 'worse',
                message: `‚ö†Ô∏è Current analysis shows ${Math.round((currentTotal / avgTotal - 1) * 100)}% more high-severity issues than historical average`,
                data: { current: currentTotal, average: avgTotal.toFixed(1) }
              };
            } else if (currentTotal < avgTotal * 0.5 && avgTotal > 0) {
              return {
                status: 'better',
                message: `‚úÖ Significant improvement: ${Math.round((1 - currentTotal / avgTotal) * 100)}% fewer high-severity issues`,
                data: { current: currentTotal, average: avgTotal.toFixed(1) }
              };
            }

            return {
              status: 'stable',
              message: 'Issue severity within normal range',
              data: { current: currentTotal, average: avgTotal.toFixed(1) }
            };
          },

          analyzeTrend(current, historical) {
            if (!historical || historical.length < 2) {
              return {
                direction: 'insufficient_data',
                message: 'Need at least 2 historical analyses to detect trends'
              };
            }

            // Look at last 5 analyses
            const recent = historical.slice(-5);
            const counts = recent.map(a => this.countSeverity(a, 'high') + this.countSeverity(a, 'critical'));

            // Simple linear trend
            const trend = counts[counts.length - 1] - counts[0];

            if (trend > 2) {
              return {
                direction: 'worsening',
                message: 'üìà Issues increasing over recent analyses - systematic review recommended',
                data: { change: trend, samples: counts.length }
              };
            } else if (trend < -2) {
              return {
                direction: 'improving',
                message: 'üìâ Issues decreasing - current processes appear effective',
                data: { change: trend, samples: counts.length }
              };
            }

            return {
              direction: 'stable',
              message: 'No significant trend detected',
              data: { change: trend, samples: counts.length }
            };
          },

          generateSmartRecommendations(current, historical) {
            const recommendations = [];

            // Get current issues
            const currentIssues = [];
            if (current.phaseA) {
              ['fileA', 'fileB'].forEach(fileKey => {
                if (current.phaseA[fileKey]) {
                  current.phaseA[fileKey].forEach(preset => {
                    const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                    if (Array.isArray(issues)) {
                      currentIssues.push(...issues);
                    }
                  });
                }
              });
            }

            // Check for recurring high-severity issues
            const highSeverity = currentIssues.filter(i => i.severity === 'high' || i.severity === 'critical');
            if (highSeverity.length > 3) {
              recommendations.push({
                priority: 'high',
                category: 'Quality Control',
                recommendation: 'Multiple high-severity issues detected. Consider implementing a document review checklist before submission.',
                impact: 'Reduce critical defects by 40-60%'
              });
            }

            // Check for missing statutory references
            const missingRefs = currentIssues.filter(i =>
              i.type && (i.type.includes('Missing') || i.type.includes('Statute'))
            );
            if (missingRefs.length > 0) {
              recommendations.push({
                priority: 'medium',
                category: 'Statutory Compliance',
                recommendation: 'Create a statutory reference template for this document type to ensure all required references are included.',
                impact: 'Improve compliance by 30-50%'
              });
            }

            // Check for procedural issues
            const proceduralIssues = currentIssues.filter(i =>
              i.type && (i.type.includes('Procedural') || i.type.includes('Fairness'))
            );
            if (proceduralIssues.length > 0) {
              recommendations.push({
                priority: 'high',
                category: 'Procedural Compliance',
                recommendation: 'Review procedural requirements and implement mandatory peer review for procedural fairness.',
                impact: 'Reduce jurisdictional errors'
              });
            }

            if (recommendations.length === 0) {
              recommendations.push({
                priority: 'low',
                category: 'Monitoring',
                recommendation: 'Continue current document preparation processes - quality metrics are within acceptable range.',
                impact: 'Maintain current standards'
              });
            }

            return recommendations;
          },

          identifyNovelIssues(current, historical) {
            if (!historical || historical.length === 0) {
              return [];
            }

            // Get all historical issue types
            const historicalTypes = new Set();
            historical.forEach(analysis => {
              if (analysis.defects) {
                analysis.defects.forEach(defect => {
                  historicalTypes.add(defect.type);
                });
              }
            });

            // Find current issues that are new
            const novelIssues = [];
            if (current.phaseA) {
              ['fileA', 'fileB'].forEach(fileKey => {
                if (current.phaseA[fileKey]) {
                  current.phaseA[fileKey].forEach(preset => {
                    const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                    if (Array.isArray(issues)) {
                      issues.forEach(issue => {
                        if (!historicalTypes.has(issue.type)) {
                          novelIssues.push({
                            type: issue.type,
                            severity: issue.severity,
                            description: issue.description,
                            preset: preset.preset
                          });
                        }
                      });
                    }
                  });
                }
              });
            }

            return novelIssues;
          }
        };

        const ForensicLegalAnalyzer = () => {
          const [files, setFiles] = useState({ fileA: null, fileB: null });
          const [fileContents, setFileContents] = useState({ fileA: '', fileB: '' });
          const [analysisState, setAnalysisState] = useState('idle');
          const [currentPhase, setCurrentPhase] = useState('');
          const [analysisResults, setAnalysisResults] = useState(null);
          const [expandedSections, setExpandedSections] = useState({});
          const [historicalAnalyses, setHistoricalAnalyses] = useState([]);
          const [detectedPatterns, setDetectedPatterns] = useState(null);
          const [contextualInsights, setContextualInsights] = useState(null);
          const [uploadProgress, setUploadProgress] = useState({ fileA: 0, fileB: 0 });
          const [isUploading, setIsUploading] = useState({ fileA: false, fileB: false });
          const [analysisProgress, setAnalysisProgress] = useState(0);
          const fileInputA = useRef(null);
          const fileInputB = useRef(null);

          // Initialize persistent storage on component mount
          React.useEffect(() => {
            AnalysisMemory.init().then(() => {
              console.log('Persistent Intelligence Layer initialized');
              // Load historical analyses
              return AnalysisMemory.getAllAnalyses();
            }).then(analyses => {
              setHistoricalAnalyses(analyses || []);
              console.log(`Loaded ${analyses?.length || 0} historical analyses`);
            }).catch(err => {
              console.error('Failed to initialize storage:', err);
            });
          }, []);

          const interpretivePresets = [
            {
              name: 'Statutory Procedural Analysis',
              description: 'Examines compliance with statutory requirements, procedural mandates, and legislative frameworks',
              focus: ['compliance', 'procedure', 'statutory_requirements', 'jurisdictional_prerequisites']
            },
            {
              name: 'Contextual Analysis',
              description: 'Evaluates meaning within broader legislative, factual, and temporal context',
              focus: ['surrounding_circumstances', 'legislative_scheme', 'temporal_context', 'factual_matrix']
            },
            {
              name: 'Jurisprudential Analysis',
              description: 'Applies established legal principles, precedents, and interpretative doctrines',
              focus: ['precedent', 'common_law_principles', 'interpretative_doctrines', 'judicial_reasoning']
            },
            {
              name: 'Objective Textual Analysis',
              description: 'Focuses on plain meaning, literal interpretation, and grammatical construction',
              focus: ['plain_meaning', 'grammatical_analysis', 'ordinary_meaning', 'textual_structure']
            },
            {
              name: 'Subjective Intent Analysis',
              description: 'Considers apparent intentions, representations, and assertions within documents',
              focus: ['stated_intentions', 'apparent_purposes', 'declarations', 'subjective_assertions']
            },
            {
              name: 'Purposive Analysis',
              description: 'Examines legislative purpose, policy objectives, and intended outcomes',
              focus: ['legislative_purpose', 'policy_objectives', 'mischief_rule', 'intended_effect']
            },
            {
              name: 'Comparative Cross-Reference Analysis',
              description: 'Identifies inconsistencies, contradictions, and discrepancies between documents',
              focus: ['consistency', 'contradictions', 'omissions', 'discrepancies']
            },
            {
              name: 'Evidentiary Standards Analysis',
              description: 'Evaluates evidentiary sufficiency, admissibility, and probative value',
              focus: ['admissibility', 'relevance', 'probative_value', 'evidentiary_weight']
            }
          ];

          // Victorian Law Document Type Classifier
          const classifyDocumentType = (filename, content) => {
            const types = {
              'Statutory Legislation': /\bact\s+\d{4}\b|primary legislation|statute/i,
              'Delegated Legislation': /\bregulation|rules|order|instrument\b/i,
              'Victoria Police Manual': /\bvictoria police|vpm|police manual|operational procedure/i,
              'Disclosure Document': /\bdisclosure|discovery|prosecution brief/i,
              'Evidence Exhibit': /\bexhibit|evidentiary material|physical evidence/i,
              'Statement': /\bstatement of|witness statement|affidavit|statutory declaration/i,
              'Court Order': /\border of the court|court order|judicial order/i,
              'Evidentiary Certificate': /\bevidentiary certificate|certificate of|s\.\s*\d+\s+certificate/i,
              'Summons': /\bsummons|witness summons|subpoena/i,
              'Charge Sheet': /\bcharge sheet|charges|indictment|complaint/i,
              'Submission': /\bsubmission|written submission|legal submission/i,
              'Deposition': /\bdeposition|committal|preliminary hearing/i,
              'Case Law': /\b[A-Z][a-z]+\s+v\s+[A-Z][a-z]+|\[\d{4}\]|CLR|VR|VSC/,
              'Legal Narrative': /\bnarrativ|chronolog|fact pattern|sequence of events/i,
              'Court Documentation': /\bfiling|pleading|court document|notice of/i
            };

            for (const [type, pattern] of Object.entries(types)) {
              if (pattern.test(content) || pattern.test(filename)) {
                return type;
              }
            }
            return 'General Legal Document';
          };

          // Victorian Governing Framework Identifier
          const identifyVictorianFramework = (content, documentType) => {
            const framework = {
              primaryLegislation: [],
              subordinateInstrumentation: [],
              jurisdiction: 'Victoria, Australia',
              governingCourts: [],
              relevantPoliceProcedures: [],
              applicableEvidentRules: []
            };

            // Victorian Primary Legislation
            const vicActPatterns = [
              /Criminal\s+Procedure\s+Act\s+2009/gi,
              /Evidence\s+Act\s+2008/gi,
              /Crimes\s+Act\s+1958/gi,
              /Charter\s+of\s+Human\s+Rights\s+and\s+Responsibilities\s+Act\s+2006/gi,
              /Victoria\s+Police\s+Act\s+2013/gi,
              /Sentencing\s+Act\s+1991/gi,
              /Children,\s+Youth\s+and\s+Families\s+Act\s+2005/gi,
              /Supreme\s+Court\s+Act\s+1986/gi,
              /Magistrates[\'']?\s+Court\s+Act\s+1989/gi,
              /County\s+Court\s+Act\s+1958/gi,
              /Bail\s+Act\s+1977/gi,
              /Confiscation\s+Act\s+1997/gi
            ];

            vicActPatterns.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.primaryLegislation.push(...new Set(matches));
              }
            });

            // Victorian Subordinate Instruments
            const vicRegPatterns = [
              /Criminal\s+Procedure\s+Regulations/gi,
              /Evidence\s+\(Miscellaneous\s+Provisions\s*\)\s+Regulations/gi,
              /Victoria\s+Police\s+Regulations/gi,
              /Supreme\s+Court\s+\(General\s+Civil\s+Procedure\s*\)\s+Rules/gi,
              /Magistrates[\'']?\s+Court\s+General\s+Civil\s+Procedure\s+Rules/gi
            ];

            vicRegPatterns.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.subordinateInstrumentation.push(...new Set(matches));
              }
            });

            // Victorian Courts
            const courtPatterns = [
              /Supreme\s+Court\s+of\s+Victoria/gi,
              /County\s+Court\s+of\s+Victoria/gi,
              /Magistrates[\'']?\s+Court\s+of\s+Victoria/gi,
              /Children[\'']?s\s+Court\s+of\s+Victoria/gi,
              /Coroners\s+Court\s+of\s+Victoria/gi
            ];

            courtPatterns.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.governingCourts.push(...new Set(matches));
              }
            });

            // Victorian Police Procedures
            if (documentType === 'Victoria Police Manual' || content.match(/victoria\s+police/i)) {
              const vpmPatterns = [
                /VPM\s+[A-Z0-9-]+/g,
                /Operational\s+Procedure\s+\d+/gi,
                /Victoria\s+Police\s+Manual\s+Section\s+\d+/gi
              ];

              vpmPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                  framework.relevantPoliceProcedures.push(...new Set(matches));
                }
              });
            }

            // Victorian Evidence Rules
            const evidenceRules = [
              /s\.\s*\d+\s+Evidence\s+Act/gi,
              /section\s+\d+\s+of\s+the\s+Evidence\s+Act/gi,
              /Division\s+\d+\s+of\s+Part\s+\d+\s+of\s+the\s+Evidence\s+Act/gi
            ];

            evidenceRules.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.applicableEvidentRules.push(...new Set(matches));
              }
            });

            return framework;
          };

          // OCR Text Extraction Function
          const extractTextWithOCR = async (file, fileKey, onProgress) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();

              reader.onload = async (e) => {
                try {
                  console.log(`Starting OCR processing for ${file.name}...`);

                  const { data: { text } } = await Tesseract.recognize(
                    e.target.result,
                    'eng',
                    {
                      logger: (m) => {
                        if (m.status === 'recognizing text') {
                          const progress = Math.round(m.progress * 100);
                          if (onProgress) {
                            onProgress(progress);
                          }
                          console.log(`OCR Progress: ${progress}%`);
                        }
                      }
                    }
                  );

                  console.log(`OCR completed for ${file.name}. Extracted ${text.length} characters.`);
                  resolve(text);
                } catch (error) {
                  console.error('OCR extraction failed:', error);
                  reject(error);
                }
              };

              reader.onerror = () => reject(new Error('Failed to read file'));
              reader.readAsDataURL(file);
            });
          };

          // PDF Text Extraction Function
          const extractTextFromPDF = async (file, fileKey, onProgress) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();

              reader.onload = async (e) => {
                try {
                  console.log(`Starting PDF text extraction for ${file.name}...`);
                  const typedArray = new Uint8Array(e.target.result);

                  const loadingTask = pdfjsLib.getDocument(typedArray);
                  const pdf = await loadingTask.promise;

                  const numPages = pdf.numPages;
                  console.log(`PDF has ${numPages} pages`);

                  let fullText = '';

                  for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';

                    const progress = Math.round((pageNum / numPages) * 100);
                    if (onProgress) {
                      onProgress(progress);
                    }
                    console.log(`Processed page ${pageNum}/${numPages} (${progress}%)`);
                  }

                  console.log(`PDF extraction completed. Extracted ${fullText.length} characters from ${numPages} pages.`);
                  resolve(fullText);
                } catch (error) {
                  console.error('PDF extraction failed:', error);
                  reject(error);
                }
              };

              reader.onerror = () => reject(new Error('Failed to read PDF file'));
              reader.readAsArrayBuffer(file);
            });
          };

          const handleFileUpload = async (file, fileKey) => {
            if (!file) return;

            setIsUploading(prev => ({ ...prev, [fileKey]: true }));
            setUploadProgress(prev => ({ ...prev, [fileKey]: 0 }));

            try {
              let content = '';
              const fileType = file.type;
              const fileName = file.name.toLowerCase();

              // PHASE 1: OCR and Text Extraction (happens FIRST before any analysis)
              console.log(`Starting text extraction for ${file.name}...`);
              console.log(`File type: ${fileType}`);

              // Determine extraction method based on file type
              if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) {
                // PDF files: Extract text using PDF.js
                console.log('Detected PDF file - using PDF text extraction');
                setUploadProgress(prev => ({ ...prev, [fileKey]: 5 }));

                content = await extractTextFromPDF(file, fileKey, (progress) => {
                  // Map PDF extraction progress to 5-70% of overall progress
                  const mappedProgress = 5 + Math.round(progress * 0.65);
                  setUploadProgress(prev => ({ ...prev, [fileKey]: mappedProgress }));
                });

              } else if (fileType.startsWith('image/') ||
                         fileName.endsWith('.png') ||
                         fileName.endsWith('.jpg') ||
                         fileName.endsWith('.jpeg') ||
                         fileName.endsWith('.gif') ||
                         fileName.endsWith('.bmp') ||
                         fileName.endsWith('.tiff')) {
                // Image files: Extract text using OCR (Tesseract.js)
                console.log('Detected image file - using OCR text extraction');
                setUploadProgress(prev => ({ ...prev, [fileKey]: 5 }));

                content = await extractTextWithOCR(file, fileKey, (progress) => {
                  // Map OCR progress to 5-70% of overall progress
                  const mappedProgress = 5 + Math.round(progress * 0.65);
                  setUploadProgress(prev => ({ ...prev, [fileKey]: mappedProgress }));
                });

              } else {
                // Plain text files: Read directly
                console.log('Detected text file - reading as plain text');
                content = await new Promise((resolve, reject) => {
                  const reader = new FileReader();

                  reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                      const progress = 5 + Math.round((e.loaded / e.total) * 65);
                      setUploadProgress(prev => ({ ...prev, [fileKey]: progress }));
                    }
                  };

                  reader.onload = (e) => resolve(e.target.result);
                  reader.onerror = () => reject(new Error('Failed to read text file'));
                  reader.readAsText(file);
                });
              }

              // Verify we got content
              if (!content || content.trim().length === 0) {
                throw new Error('No text could be extracted from the file. The file may be empty or the format is not supported.');
              }

              console.log(`Text extraction completed. Extracted ${content.length} characters.`);
              setUploadProgress(prev => ({ ...prev, [fileKey]: 75 }));

              // PHASE 2: Document Classification and Framework Identification
              console.log('Classifying document and identifying legal framework...');
              const documentType = classifyDocumentType(file.name, content);
              const framework = identifyVictorianFramework(content, documentType);

              setUploadProgress(prev => ({ ...prev, [fileKey]: 90 }));

              // PHASE 3: Store Results
              const enhancedFile = {
                ...file,
                documentType: documentType,
                framework: framework,
                uploadTimestamp: new Date().toISOString(),
                extractionMethod: fileType === 'application/pdf' ? 'PDF Extraction' :
                                 fileType.startsWith('image/') ? 'OCR (Tesseract)' : 'Plain Text'
              };

              setFiles(prev => ({ ...prev, [fileKey]: enhancedFile }));
              setFileContents(prev => ({ ...prev, [fileKey]: content }));
              setUploadProgress(prev => ({ ...prev, [fileKey]: 100 }));

              console.log(`File ${fileKey} processed successfully:`);
              console.log(`- Classification: ${documentType}`);
              console.log(`- Extraction Method: ${enhancedFile.extractionMethod}`);
              console.log(`- Text Length: ${content.length} characters`);
              console.log(`- Governing Framework:`, framework);

              setTimeout(() => {
                setIsUploading(prev => ({ ...prev, [fileKey]: false }));
              }, 300);

            } catch (error) {
              console.error(`Error processing file ${file.name}:`, error);
              alert(`Failed to process file: ${error.message}\n\nSupported formats:\n- PDF documents (.pdf)\n- Images (.png, .jpg, .jpeg, .gif, .bmp, .tiff) - OCR will be performed\n- Text files (.txt, .doc, .docx)`);

              setIsUploading(prev => ({ ...prev, [fileKey]: false }));
              setUploadProgress(prev => ({ ...prev, [fileKey]: 0 }));
            }
          };

          const handleUrlUpload = async (url, fileKey) => {
            try {
              const response = await fetch(url);
              const content = await response.text();
              setFiles(prev => ({ ...prev, [fileKey]: { name: url.split('/').pop(), type: 'url' } }));
              setFileContents(prev => ({ ...prev, [fileKey]: content }));
            } catch (error) {
              alert('Failed to fetch document from URL. Please ensure the URL is accessible and points to a text document.');
            }
          };

          const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
          };

          const handleDrop = (e, fileKey) => {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file) handleFileUpload(file, fileKey);
          };

          const simulateAnalysis = async () => {
            setAnalysisState('analyzing');
            setAnalysisResults(null);
            setAnalysisProgress(0);

            setCurrentPhase('Phase A: Multi-Preset Forensic Examination');
            setAnalysisProgress(10);
            await new Promise(resolve => setTimeout(resolve, 2000));

            const phaseAResults = {
              fileA: interpretivePresets.map(preset => ({
                preset: preset.name,
                findings: generateFindings(fileContents.fileA, preset)
              })),
              fileB: interpretivePresets.map(preset => ({
                preset: preset.name,
                findings: generateFindings(fileContents.fileB, preset)
              }))
            };

            setAnalysisProgress(40);
            setCurrentPhase('Phase B: Victorian Criminal Compliance & Statutory Cross-Reference Analysis');
            await new Promise(resolve => setTimeout(resolve, 2000));

            const phaseBResults = performCrossReference(phaseAResults);
            setAnalysisProgress(65);

            setCurrentPhase('Phase C: Statutory Interpretation & Legislative Purpose Analysis');
            await new Promise(resolve => setTimeout(resolve, 2000));

            const phaseCResults = performStatutoryInterpretation(phaseAResults, phaseBResults);
            setAnalysisProgress(80);

            const finalResults = {
              phaseA: phaseAResults,
              phaseB: phaseBResults,
              phaseC: phaseCResults,
              summary: generateExecutiveSummary(phaseAResults, phaseBResults, phaseCResults)
            };

            setAnalysisResults(finalResults);
            setAnalysisProgress(90);

            // Save analysis to persistent storage with file contents
            const analysisId = await AnalysisMemory.saveAnalysis(finalResults, files, fileContents);
            console.log(`‚úÖ Analysis #${analysisId} saved with learning capability enabled`);

            // Reload historical analyses
            const updatedAnalyses = await AnalysisMemory.getAllAnalyses();
            setHistoricalAnalyses(updatedAnalyses || []);

            setAnalysisProgress(92);

            // Generate learning insights from all analyses
            const learningInsights = await AnalysisMemory.generateLearningInsights();
            console.log('üìä Learning insights generated:', learningInsights);

            setAnalysisProgress(94);

            // Extract current defects for cross-analysis intelligence
            const currentDefects = AnalysisMemory.extractDefects(finalResults);

            // Generate cross-analysis intelligence
            const crossIntelligence = await AnalysisMemory.getIntelligenceForAnalysis(currentDefects);
            setContextualInsights({
              learningInsights: learningInsights,
              crossIntelligence: crossIntelligence
            });
            console.log('üîç Cross-analysis intelligence:', crossIntelligence);

            setAnalysisProgress(96);

            // Run pattern detection (legacy support)
            if (updatedAnalyses && updatedAnalyses.length > 0) {
              const patterns = await PatternDetector.analyze(finalResults, updatedAnalyses);
              setDetectedPatterns(patterns);
              console.log('Pattern detection completed:', patterns);
            }

            setAnalysisProgress(100);
            setAnalysisState('complete');
            setCurrentPhase('Analysis Complete - Intelligence Insights Ready');
          };

          // Word-by-Word Linguistic Inspection Engine
          const performLinguisticInspection = (content, documentType, framework) => {
            const lines = content.split('\n');
            const linguisticReport = {
              totalWords: 0,
              totalLines: lines.length,
              lineByLineAnalysis: [],
              wordAccuracyIssues: [],
              grammaticalDefects: [],
              legalTerminologyIssues: [],
              victorianComplianceDefects: []
            };

            lines.forEach((line, lineIndex) => {
              const lineNumber = lineIndex + 1;
              const words = line.trim().split(/\s+/).filter(w => w.length > 0);
              linguisticReport.totalWords += words.length;

              const lineAnalysis = {
                lineNumber: lineNumber,
                content: line,
                wordCount: words.length,
                issues: [],
                wordByWordInspection: []
              };

              // Word-by-word inspection
              words.forEach((word, wordIndex) => {
                const wordPosition = wordIndex + 1;
                const cleanWord = word.replace(/[^\w\s'-]/g, '').toLowerCase();

                const wordInspection = {
                  position: wordPosition,
                  word: word,
                  issues: []
                };

                // Victorian legal terminology accuracy
                const victorianTermIssues = checkVictorianLegalTerminology(word, cleanWord, documentType);
                if (victorianTermIssues.length > 0) {
                  wordInspection.issues.push(...victorianTermIssues);
                  linguisticReport.legalTerminologyIssues.push({
                    line: lineNumber,
                    word: word,
                    position: wordPosition,
                    issues: victorianTermIssues
                  });
                }

                // Check for spelling and accuracy
                const spellingIssues = checkLegalSpelling(word, cleanWord);
                if (spellingIssues) {
                  wordInspection.issues.push(spellingIssues);
                  linguisticReport.wordAccuracyIssues.push({
                    line: lineNumber,
                    word: word,
                    position: wordPosition,
                    issue: spellingIssues
                  });
                }

                if (wordInspection.issues.length > 0) {
                  lineAnalysis.wordByWordInspection.push(wordInspection);
                }
              });

              // Line-level checks
              const lineIssues = performLineInspection(line, lineNumber, documentType, framework);
              lineAnalysis.issues.push(...lineIssues);

              if (lineIssues.length > 0) {
                linguisticReport.grammaticalDefects.push(...lineIssues.map(issue => ({
                  line: lineNumber,
                  content: line,
                  issue: issue
                })));
              }

              linguisticReport.lineByLineAnalysis.push(lineAnalysis);
            });

            return linguisticReport;
          };

          // Victorian Legal Terminology Checker
          const checkVictorianLegalTerminology = (originalWord, cleanWord, documentType) => {
            const issues = [];

            // Victorian-specific terminology that must be accurate
            const victorianTerms = {
              'informant': { correct: 'informant', common_errors: ['informent', 'informent'], context: 'Victorian police terminology' },
              'indictable': { correct: 'indictable', common_errors: ['indicatable', 'indictible'], context: 'Victorian criminal law' },
              'committals': { correct: 'committals', common_errors: ['commitals', 'commital'], context: 'Victorian court procedure' },
              'magistrate': { correct: 'magistrate', common_errors: ['magistrait', 'magistrat'], context: 'Victorian judicial officer' },
              'summons': { correct: 'summons', common_errors: ['summon', 'summonses'], context: 'Victorian court process' },
              'pursuant': { correct: 'pursuant', common_errors: ['persuan', 'persuant'], context: 'Legal terminology' },
              'defence': { correct: 'defence', american: 'defense', context: 'Australian spelling (not defense)' },
              'practitioner': { correct: 'practitioner', common_errors: ['practisioner', 'practioner'], context: 'Legal practitioner' },
              'recognised': { correct: 'recognised', american: 'recognized', context: 'Australian spelling (not recognized)' },
              'summarised': { correct: 'summarised', american: 'summarized', context: 'Australian spelling (not summarized)' }
            };

            for (const [term, info] of Object.entries(victorianTerms)) {
              if (info.common_errors && info.common_errors.includes(cleanWord)) {
                issues.push({
                  type: 'Victorian Legal Terminology Error',
                  severity: 'high',
                  description: `"${originalWord}" should be "${info.correct}" in ${info.context}`,
                  correct: info.correct,
                  context: info.context
                });
              }

              // Check for American spelling in Victorian context
              if (info.american && cleanWord === info.american) {
                issues.push({
                  type: 'Australian Spelling Required',
                  severity: 'medium',
                  description: `"${originalWord}" uses American spelling. Victorian documents require "${info.correct}"`,
                  correct: info.correct,
                  context: info.context
                });
              }
            }

            return issues;
          };

          // Legal Spelling Checker
          const checkLegalSpelling = (word, cleanWord) => {
            const commonLegalMisspellings = {
              'achive': 'achieve',
              'admissable': 'admissible',
              'alledge': 'allege',
              'arguement': 'argument',
              'benificial': 'beneficial',
              'calender': 'calendar',
              'comitted': 'committed',
              'complience': 'compliance',
              'defendent': 'defendant',
              'discreation': 'discretion',
              'existance': 'existence',
              'fourty': 'forty',
              'gaurd': 'guard',
              'guidence': 'guidance',
              'independant': 'independent',
              'judgement': 'judgment',  // Note: In Australian legal context, both are acceptable
              'liason': 'liaison',
              'maintainance': 'maintenance',
              'occassion': 'occasion',
              'occurance': 'occurrence',
              'persue': 'pursue',
              'preceed': 'precede',
              'priviledge': 'privilege',
              'proceedure': 'procedure',
              'recieve': 'receive',
              'seperate': 'separate',
              'statutory': 'statuary'  // Common typo
            };

            if (commonLegalMisspellings[cleanWord]) {
              return {
                type: 'Spelling Error',
                severity: 'medium',
                description: `"${word}" appears to be misspelled. Correct spelling: "${commonLegalMisspellings[cleanWord]}"`,
                suggestion: commonLegalMisspellings[cleanWord]
              };
            }

            return null;
          };

          // Line-Level Inspection
          const performLineInspection = (line, lineNumber, documentType, framework) => {
            const issues = [];

            // Check for incomplete statutory references
            if (/section\s+\d+\s*$/i.test(line) && !line.includes('Act')) {
              issues.push({
                type: 'Incomplete Statutory Reference',
                severity: 'high',
                description: 'Section reference without specifying the Act',
                defect: 'Section reference incomplete - must specify governing Act'
              });
            }

            // Check for incorrect conjunction usage in legal lists
            if (/,\s+and\s+,/.test(line)) {
              issues.push({
                type: 'Grammatical Error',
                severity: 'low',
                description: 'Incorrect comma placement with conjunction',
                defect: 'Oxford comma usage inconsistent or incorrect'
              });
            }

            // Check for passive voice in Victoria Police procedural documents
            if (documentType === 'Victoria Police Manual' && /was\s+\w+ed\b|were\s+\w+ed\b/i.test(line)) {
              issues.push({
                type: 'Passive Voice in Procedural Document',
                severity: 'low',
                description: 'Victoria Police procedures should use active voice',
                defect: 'Consider rephrasing in active voice for clarity'
              });
            }

            // Check for ambiguous temporal references
            if (/as soon as possible|ASAP|promptly|immediately/i.test(line)) {
              issues.push({
                type: 'Vague Temporal Reference',
                severity: 'medium',
                description: 'Imprecise time requirement - Victorian statutory compliance requires specific timeframes',
                defect: 'Replace with specific timeframe (e.g., "within 7 days", "within 24 hours")'
              });
            }

            // Check for missing mandatory elements in statements
            if (documentType === 'Statement' && lineNumber === 1) {
              if (!/statement\s+of/i.test(line)) {
                issues.push({
                  type: 'Missing Statement Header',
                  severity: 'high',
                  description: 'Statement documents should begin with "Statement of [name]"',
                  defect: 'Required header missing - Victoria Police disclosure requirements'
                });
              }
            }

            // Check for incorrect court references
            const incorrectCourtRefs = [
              { pattern: /Magistrates Court(?!\s+of\s+Victoria)/gi, correct: 'Magistrates\' Court of Victoria' },
              { pattern: /Supreme Court(?!\s+of\s+Victoria)/gi, correct: 'Supreme Court of Victoria' },
              { pattern: /County Court(?!\s+of\s+Victoria)/gi, correct: 'County Court of Victoria' }
            ];

            incorrectCourtRefs.forEach(ref => {
              if (ref.pattern.test(line)) {
                issues.push({
                  type: 'Incomplete Court Reference',
                  severity: 'high',
                  description: `Court reference should be "${ref.correct}" in Victorian documents`,
                  defect: 'Full court name required for Victorian jurisdiction'
                });
              }
            });

            return issues;
          };

          const generateFindings = (content, preset) => {
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const lines = content.split('\n').filter(l => l.trim().length > 0);

            // Extract legal references first so we can pass them to issue identification
            const legalReferences = extractLegalReferences(content);

            // Perform comprehensive linguistic inspection
            const linguisticInspection = performLinguisticInspection(content, 'General Legal Document', {});

            return {
              wordCount: words.length,
              lineCount: lines.length,
              linguisticInspection: linguisticInspection,
              keyTermsIdentified: extractKeyTerms(content, preset),
              proceduralElements: identifyProceduralElements(content, preset),
              legalReferences: legalReferences,
              potentialIssues: identifyPotentialIssues(content, preset, legalReferences),
              contextualMarkers: extractContextualMarkers(content, preset)
            };
          };

          const extractKeyTerms = (content, preset) => {
            const legalTerms = ['section', 'act', 'regulation', 'pursuant', 'provision', 'subsection', 
                                'statute', 'legislative', 'compliance', 'requirement', 'jurisdiction',
                                'evidence', 'exhibit', 'disclosure', 'preliminary', 'test', 'analysis',
                                'procedure', 'statutory', 'mandatory', 'discretionary', 'power'];
            
            const found = [];
            
            legalTerms.forEach(term => {
              const regex = new RegExp(`\\b${term}\\b`, 'gi');
              const matches = content.match(regex);
              if (matches) {
                found.push({
                  term: term,
                  occurrences: matches.length,
                  contexts: extractContexts(content, term, 50)
                });
              }
            });
            
            return found.slice(0, 10);
          };

          const extractContexts = (content, term, contextLength) => {
            const regex = new RegExp(`.{0,${contextLength}}\\b${term}\\b.{0,${contextLength}}`, 'gi');
            const matches = content.match(regex);
            return matches ? matches.slice(0, 3) : [];
          };

          const identifyProceduralElements = (content, preset) => {
            const proceduralIndicators = [
              { pattern: /section\s+\d+[A-Z]?/gi, type: 'Statutory Reference' },
              { pattern: /\b(must|shall|may|ought)\b/gi, type: 'Mandatory/Discretionary Language' },
              { pattern: /\b(pursuant to|in accordance with|under)\b/gi, type: 'Procedural Compliance Indicator' },
              { pattern: /\b(evidence|exhibit|disclosure|statement)\b/gi, type: 'Evidentiary Element' },
              { pattern: /\b(date|time|within|before|after)\b/gi, type: 'Temporal Element' }
            ];

            return proceduralIndicators.map(indicator => ({
              type: indicator.type,
              matches: (content.match(indicator.pattern) || []).length,
              examples: extractContexts(content, indicator.pattern.source.replace(/\\b|\(|\)|gi/g, ''), 40).slice(0, 2)
            })).filter(item => item.matches > 0);
          };

          const extractLegalReferences = (content) => {
            const references = [];
            
            const sectionMatches = content.match(/section\s+\d+[A-Z]?(?:\(\d+\))?(?:\([a-z]\))?/gi);
            if (sectionMatches) {
              references.push(...sectionMatches.map(m => ({ type: 'Section Reference', text: m })));
            }
            
            const actMatches = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Act\s+\d{4}/g);
            if (actMatches) {
              references.push(...actMatches.map(m => ({ type: 'Act Citation', text: m })));
            }
            
            return references.slice(0, 15);
          };

          // Enhanced issue identification with statutory compliance matrix
          const identifyPotentialIssues = (content, preset, legalReferences = []) => {
            const issues = [];

            // Extract statutory framework for this document
            const primaryActs = legalReferences.filter(r => r.type === 'Act Citation');
            const sectionRefs = legalReferences.filter(r => r.type === 'Section Reference');

            // Category 1: CRITICAL STATUTORY DEFECTS (High Severity)

            // 1.1 Acknowledged Errors or Corrections
            const errorPatterns = /\b(error|incorrect|mistake|erroneously|wrongly|inadvertent|oversight)\b/gi;
            const errorMatches = content.match(errorPatterns);
            if (errorMatches && errorMatches.length > 0) {
              issues.push({
                severity: 'critical',
                type: 'Acknowledged Defect',
                category: 'Statutory Compliance',
                description: `Document contains ${errorMatches.length} reference(s) to errors or incorrect information`,
                evidence: errorMatches.slice(0, 3).join(', '),
                statutoryImpact: 'May invalidate reliance on document under s15AA Acts Interpretation Act',
                weight: 10
              });
            }

            // 1.2 Jurisdiction Issues
            const jurisdictionPatterns = /\b(jurisdiction|ultra vires|beyond power|lack.*authority|void|invalid)\b/gi;
            const jurisdictionMatches = content.match(jurisdictionPatterns);
            if (jurisdictionMatches && jurisdictionMatches.length > 2) {
              issues.push({
                severity: 'critical',
                type: 'Jurisdictional Defect',
                category: 'Statutory Compliance',
                description: 'Document raises potential jurisdictional or validity concerns',
                evidence: jurisdictionMatches.slice(0, 3).join(', '),
                statutoryImpact: 'Jurisdictional defects may render decision void ab initio',
                weight: 10
              });
            }

            // 1.3 Procedural Fairness Violations
            const fairnessPatterns = /\b(natural justice|procedural fairness|bias|denied.*opportunity|no.*hearing|unfair)\b/gi;
            const fairnessMatches = content.match(fairnessPatterns);
            if (fairnessMatches && fairnessMatches.length > 0) {
              issues.push({
                severity: 'high',
                type: 'Procedural Fairness Issue',
                category: 'Statutory Compliance',
                description: 'Document indicates potential breach of procedural fairness',
                evidence: fairnessMatches.slice(0, 3).join(', '),
                statutoryImpact: 'Breach of natural justice may constitute jurisdictional error',
                weight: 9
              });
            }

            // Category 2: STATUTORY REFERENCE DEFECTS (High-Medium Severity)

            // 2.1 Missing Primary Legislation Reference
            if (primaryActs.length === 0) {
              issues.push({
                severity: 'high',
                type: 'Missing Primary Legislation',
                category: 'Statutory Framework',
                description: 'No primary Act citations identified - cannot determine governing legislative framework',
                statutoryImpact: 'Unable to assess compliance with enabling legislation',
                weight: 8
              });
            }

            // 2.2 Missing Section References
            if (sectionRefs.length === 0 && content.length > 500) {
              issues.push({
                severity: 'medium',
                type: 'Missing Specific Statutory Provisions',
                category: 'Statutory Framework',
                description: 'No specific section references identified despite substantive content',
                statutoryImpact: 'Lack of specificity may indicate insufficient statutory basis',
                weight: 6
              });
            }

            // 2.3 Inconsistent Citation Format
            const inconsistentCitations = checkCitationConsistency(content);
            if (inconsistentCitations.length > 0) {
              issues.push({
                severity: 'medium',
                type: 'Inconsistent Citation Format',
                category: 'Statutory Framework',
                description: 'Mixed or inconsistent citation formats detected',
                evidence: inconsistentCitations.join('; '),
                weight: 5
              });
            }

            // Category 3: SUBORDINATE INSTRUMENT ISSUES (Medium Severity)

            // 3.1 Identify subordinate instruments
            const subordinateInstruments = identifySubordinateInstruments(content);
            if (subordinateInstruments.regulations.length > 0 && primaryActs.length === 0) {
              issues.push({
                severity: 'medium',
                type: 'Orphaned Subordinate Instrument',
                category: 'Legislative Hierarchy',
                description: `${subordinateInstruments.regulations.length} subordinate instrument(s) cited without parent Act`,
                evidence: subordinateInstruments.regulations.slice(0, 3).join(', '),
                statutoryImpact: 'Subordinate instruments must be read subject to enabling Act',
                weight: 7
              });
            }

            // 3.2 Regulation vs Act conflict indicators
            const conflictPatterns = /\b(contrary to|inconsistent with|conflict|override|supersede)\b/gi;
            const conflictMatches = content.match(conflictPatterns);
            if (conflictMatches && subordinateInstruments.regulations.length > 0) {
              issues.push({
                severity: 'high',
                type: 'Potential Instrument Conflict',
                category: 'Legislative Hierarchy',
                description: 'Potential conflict between subordinate and primary legislation',
                evidence: conflictMatches.slice(0, 2).join(', '),
                statutoryImpact: 'Subordinate instruments cannot override primary legislation',
                weight: 8
              });
            }

            // Category 4: MANDATORY VS DISCRETIONARY LANGUAGE (Medium-Low Severity)

            const mustShallCount = (content.match(/\b(must|shall|required)\b/gi) || []).length;
            const mayCount = (content.match(/\b(may|discretion|permitted)\b/gi) || []).length;
            const couldCount = (content.match(/\b(could|might|possibly)\b/gi) || []).length;

            // 4.1 Ambiguous mandatory obligations
            if (mustShallCount > 0 && mayCount > 0) {
              const ratio = mayCount / mustShallCount;
              const severity = ratio > 0.5 ? 'medium' : 'low';
              issues.push({
                severity: severity,
                type: 'Mixed Mandatory/Discretionary Language',
                category: 'Interpretive Clarity',
                description: `Document contains both mandatory (${mustShallCount}) and discretionary (${mayCount}) obligations`,
                statutoryImpact: 'Mandatory obligations interpreted according to "must" vs "may" distinction',
                weight: ratio > 0.5 ? 5 : 3
              });
            }

            // 4.2 Weak or vague language in statutory context
            if (couldCount > mustShallCount && mustShallCount > 0) {
              issues.push({
                severity: 'medium',
                type: 'Vague Language in Statutory Context',
                category: 'Interpretive Clarity',
                description: `Predominance of uncertain language (${couldCount} instances) over mandatory obligations`,
                weight: 4
              });
            }

            // Category 5: EVIDENTIARY & PROCEDURAL SUFFICIENCY (Medium-Low Severity)

            // 5.1 Insufficient factual detail
            const lines = content.split('\n').filter(l => l.trim().length > 0);
            const words = content.split(/\s+/).length;
            if (lines.length < 5 && words < 100) {
              issues.push({
                severity: 'medium',
                type: 'Insufficient Substantive Content',
                category: 'Procedural Sufficiency',
                description: `Document appears to lack substantive detail (${lines.length} lines, ${words} words)`,
                statutoryImpact: 'Inadequate reasoning may constitute failure to discharge statutory duty',
                weight: 6
              });
            }

            // 5.2 Missing temporal references
            const temporalMarkers = content.match(/\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{4}-\d{2}-\d{2}|date|time|deadline|by|before|after|within \d+)\b/gi);
            if (!temporalMarkers && content.length > 500) {
              issues.push({
                severity: 'low',
                type: 'Missing Temporal References',
                category: 'Procedural Sufficiency',
                description: 'No specific dates or timeframes identified in substantive document',
                weight: 3
              });
            }

            // 5.3 Evidence markers
            const evidenceMarkers = content.match(/\b(evidence|exhibit|annexure|attachment|schedule|appendix)\b/gi);
            if (evidenceMarkers && evidenceMarkers.length > 3) {
              const evidenceVerification = content.match(/\b(refer|attached|enclosed|provided)\b/gi);
              if (!evidenceVerification || evidenceVerification.length < evidenceMarkers.length) {
                issues.push({
                  severity: 'medium',
                  type: 'Potential Missing Evidence',
                  category: 'Procedural Sufficiency',
                  description: `${evidenceMarkers.length} evidence references but insufficient verification of attachment`,
                  weight: 5
                });
              }
            }

            // Category 6: INTERPRETIVE PRINCIPLES (Low-Medium Severity)

            // 6.1 Specific vs General provisions (generalia specialibus non derogant)
            const generalTerms = content.match(/\b(general|overall|broadly|in general|generally)\b/gi);
            const specificTerms = content.match(/\b(specific|specifically|particular|precisely|expressly)\b/gi);
            if (generalTerms && specificTerms && generalTerms.length > specificTerms.length * 2) {
              issues.push({
                severity: 'low',
                type: 'Predominance of General over Specific',
                category: 'Interpretive Principles',
                description: 'Document relies heavily on general rather than specific provisions',
                statutoryImpact: 'Principle: Specific provisions prevail over general (generalia specialibus non derogant)',
                weight: 4
              });
            }

            // 6.2 Express inclusions/exclusions (expressio unius est exclusio alterius)
            const inclusionTerms = content.match(/\b(includes?|including|such as|means)\b/gi);
            const exclusionTerms = content.match(/\b(excludes?|excluding|except|other than|but not)\b/gi);
            if (inclusionTerms && !exclusionTerms && inclusionTerms.length > 3) {
              issues.push({
                severity: 'low',
                type: 'Express Inclusions without Exclusions',
                category: 'Interpretive Principles',
                description: 'Multiple express inclusions may imply exclusion of unstated items',
                statutoryImpact: 'Principle: Express mention excludes unstated items (expressio unius)',
                weight: 3
              });
            }

            // Calculate overall severity score
            const totalWeight = issues.reduce((sum, issue) => sum + (issue.weight || 0), 0);

            // Sort issues by weight (highest first)
            issues.sort((a, b) => (b.weight || 0) - (a.weight || 0));

            // Add metadata
            issues.forEach((issue, index) => {
              issue.id = `ISSUE-${index + 1}`;
              issue.governingFramework = primaryActs.length > 0 ? primaryActs[0].text : 'Unspecified';
            });

            return {
              issues: issues,
              summary: {
                totalIssues: issues.length,
                critical: issues.filter(i => i.severity === 'critical').length,
                high: issues.filter(i => i.severity === 'high').length,
                medium: issues.filter(i => i.severity === 'medium').length,
                low: issues.filter(i => i.severity === 'low').length,
                overallRiskScore: totalWeight,
                riskLevel: totalWeight > 40 ? 'CRITICAL' : totalWeight > 25 ? 'HIGH' : totalWeight > 15 ? 'MEDIUM' : 'LOW'
              }
            };
          };

          // Helper function: Check citation consistency
          const checkCitationConsistency = (content) => {
            const inconsistencies = [];

            // Check for mixed section reference styles
            const sectionStyle1 = content.match(/section \d+/gi);
            const sectionStyle2 = content.match(/s\.\d+/gi);
            const sectionStyle3 = content.match(/sec\. \d+/gi);

            const styles = [sectionStyle1, sectionStyle2, sectionStyle3].filter(s => s && s.length > 0);
            if (styles.length > 1) {
              inconsistencies.push('Mixed section reference formats (e.g., "section 5", "s.5", "sec. 5")');
            }

            // Check for mixed subsection styles
            const subsectionParen = content.match(/\(\d+\)/g);
            const subsectionBracket = content.match(/\[\d+\]/g);
            if (subsectionParen && subsectionBracket) {
              inconsistencies.push('Mixed subsection formats (parentheses vs brackets)');
            }

            return inconsistencies;
          };

          // Helper function: Identify subordinate instruments
          const identifySubordinateInstruments = (content) => {
            const regulations = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Regulations?\s+\d{4}/g) || [];
            const rules = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Rules\s+\d{4}/g) || [];
            const orders = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Orders?\s+\d{4}/g) || [];
            const instruments = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Instrument\s+\d{4}/g) || [];

            return {
              regulations: [...new Set(regulations)],
              rules: [...new Set(rules)],
              orders: [...new Set(orders)],
              instruments: [...new Set(instruments)],
              total: regulations.length + rules.length + orders.length + instruments.length
            };
          };

          const extractContextualMarkers = (content, preset) => {
            return {
              temporalMarkers: (content.match(/\b(before|after|within|during|on|at)\s+[a-zA-Z0-9\s,]+/gi) || []).slice(0, 5),
              conditionalMarkers: (content.match(/\b(if|unless|provided that|subject to)\b[^.]+/gi) || []).slice(0, 5),
              authorityMarkers: (content.match(/\b(officer|court|tribunal|authority|minister)\b[^.]+/gi) || []).slice(0, 5)
            };
          };

          // Enhanced Victorian Law Statutory Compliance Checker for Criminal Summary Matters
          const checkVictorianStatutoryCompliance = (content, documentType, legalReferences) => {
            const complianceIssues = [];

            // ====================================================================================
            // PART 1: DISCLOSURE REQUIREMENTS - Criminal Procedure Act 2009 Part 3.3
            // ====================================================================================

            if (documentType === 'Disclosure Document' || documentType === 'Statement') {
              // Check 1.1: Informant's statement present
              if (!/informant[\'']?s?\s+statement/i.test(content)) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Disclosure Requirements',
                  defect: 'Missing informant\'s statement in disclosure',
                  compliance: 'non-compliant',
                  remediation: 'Include informant\'s statement as required by CPA 2009 s.186(1)(a)'
                });
              }

              // Check 1.2: Witness statements
              const witnessStatementMatch = content.match(/witness\s+statement/gi);
              if (!witnessStatementMatch || witnessStatementMatch.length === 0) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Witness Statements',
                  defect: 'No witness statements identified',
                  compliance: 'unclear',
                  remediation: 'Verify all witness statements are disclosed per s.186(1)(b)'
                });
              }

              // Check 1.3: Prior convictions disclosed
              if (!/prior\s+(conviction|record|history)|criminal\s+(history|record)/i.test(content)) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Prior Convictions',
                  defect: 'No reference to prior convictions or criminal history',
                  compliance: 'unclear',
                  remediation: 'Disclose any prior convictions relevant to the case (s.186(1)(c))'
                });
              }

              // Check 1.4: Physical evidence list
              if (!/evidence\s+(list|schedule|inventory)|exhibit\s+(list|schedule|inventory)|physical\s+evidence/i.test(content)) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Physical Evidence',
                  defect: 'No physical evidence list or exhibit schedule identified',
                  compliance: 'non-compliant',
                  remediation: 'Provide list of all physical evidence per s.186(1)(d)'
                });
              }

              // Check 1.5: Statements signed and dated
              const hasSignature = /signed|signature/i.test(content);
              const hasDate = /dated|date\s*:/i.test(content);
              if (!hasSignature) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - Statement Formalities',
                  defect: 'No indication that statements are signed',
                  compliance: 'non-compliant',
                  remediation: 'All statements must be signed by declarant'
                });
              }
              if (!hasDate) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - Statement Formalities',
                  defect: 'No indication that statements are dated',
                  compliance: 'non-compliant',
                  remediation: 'All statements must be dated to establish timeline'
                });
              }

              // Check 1.6: s.186 timeframe compliance
              if (!/within\s+\d+\s+(days?|weeks?|months?)|disclosure\s+deadline/i.test(content)) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 's.186 - Disclosure Timing',
                  defect: 'No specific disclosure timeframe identified',
                  compliance: 'potentially non-compliant',
                  remediation: 'Ensure disclosure meets s.186 mandatory timeframes'
                });
              }

              // Check 1.7: Exhibits properly identified
              const exhibitReferences = content.match(/exhibit\s+[A-Z0-9]+/gi);
              if (exhibitReferences && exhibitReferences.length > 0) {
                const properIdentification = /exhibit\s+[A-Z0-9]+:\s*[\w\s]+/i.test(content);
                if (!properIdentification) {
                  complianceIssues.push({
                    severity: 'medium',
                    statute: 'Criminal Procedure Act 2009',
                    section: 'Part 3.3 - Exhibit Identification',
                    defect: 'Exhibits referenced but may lack proper descriptions',
                    compliance: 'unclear',
                    remediation: 'Each exhibit must have unique identifier and description'
                  });
                }
              }
            }

            // ====================================================================================
            // PART 2: PRELIMINARY TEST REQUIREMENTS - Road Safety Act 1986
            // ====================================================================================

            const isPreliminaryTest = /preliminary\s+(test|breath|drug)|roadside\s+test|screening\s+test/i.test(content);

            if (isPreliminaryTest) {
              // Check 2.1: Section 49(1) - "reason to believe"
              const hasReasonToBelieve = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)|believed|suspected/i.test(content);
              if (!hasReasonToBelieve) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Road Safety Act 1986',
                  section: 's.49(1) - Reason to Believe',
                  defect: 'No evidence that officer had "reason to believe" as required by s.49(1)',
                  compliance: 'non-compliant',
                  remediation: 'Document must show officer\'s subjective belief that driver had consumed alcohol/drugs'
                });
              }

              // Check 2.2: Section 55D(1) - test "in accordance with directions"
              const hasDirections = /in\s+accordance\s+with\s+directions?|directions?\s+(given|provided|issued)|followed\s+directions?/i.test(content);
              if (!hasDirections) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Road Safety Act 1986',
                  section: 's.55D(1) - Accordance with Directions',
                  defect: 'No evidence test was conducted "in accordance with directions"',
                  compliance: 'non-compliant',
                  remediation: 'Must specify that test was conducted in accordance with s.55D(1) directions'
                });
              }

              // Check 2.3: Section 55D(2) - oral directions if literate
              const hasOralDirections = /oral\s+directions?|verbal\s+(?:directions?|instructions?)|spoken\s+to|told\s+to|instructed\s+(?:to|that)/i.test(content);
              const hasLiteracyRef = /literate|able\s+to\s+read|read\s+and\s+understand/i.test(content);
              if (!hasOralDirections && !hasLiteracyRef) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Road Safety Act 1986',
                  section: 's.55D(2) - Oral Directions',
                  defect: 'No indication that oral directions were given if person literate',
                  compliance: 'unclear',
                  remediation: 'If person literate, oral directions must be given per s.55D(2)'
                });
              }

              // Check 2.4: Section 55E - "proper performance" indicators
              const properPerformanceIndicators = [
                /device\s+approval|approved\s+device|approved\s+(?:by|under)/i,
                /calibrat(?:ed|ion)|maintain(?:ed|ance)|servic(?:ed|ing)/i,
                /proper\s+(?:working\s+)?(?:order|condition|performance)/i,
                /tested\s+and\s+(?:certified|approved)/i
              ];
              const hasProperPerformance = properPerformanceIndicators.some(pattern => pattern.test(content));
              if (!hasProperPerformance) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Road Safety Act 1986',
                  section: 's.55E - Proper Performance',
                  defect: 'No indicators of device "proper performance" as required by s.55E',
                  compliance: 'non-compliant',
                  remediation: 'Must document: device approval number, calibration/maintenance records'
                });
              }

              // Check 2.5: Device approval number
              const hasApprovalNumber = /approval\s+(?:number|no\.?|#)\s*:?\s*[\w\d\-]+|device\s+(?:number|no\.?|#)\s*:?\s*[\w\d\-]+/i.test(content);
              if (!hasApprovalNumber) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Road Safety Act 1986',
                  section: 's.55E - Device Approval',
                  defect: 'No device approval number specified',
                  compliance: 'non-compliant',
                  remediation: 'Must specify approved device number per s.55E proper performance requirements'
                });
              }

              // Check 2.6: Calibration/maintenance records
              const hasMaintenanceRecords = /calibrat(?:ed|ion)\s+(?:on|date|record)|maintenance\s+(?:log|record)|service\s+(?:date|record)/i.test(content);
              if (!hasMaintenanceRecords) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Road Safety Act 1986',
                  section: 's.55E - Device Maintenance',
                  defect: 'No calibration or maintenance records referenced',
                  compliance: 'unclear',
                  remediation: 'Document calibration/maintenance to establish proper performance'
                });
              }

              // Check 2.7: Section 55(1) - evidentiary test compliance
              const hasEvidentinaryTest = /evidentiary\s+test|evidential\s+(?:test|breath)/i.test(content);
              if (hasEvidentinaryTest) {
                const hasCompliance = /complied\s+with|in\s+accordance\s+with|pursuant\s+to.*s(?:ection)?\s*55\(1\)/i.test(content);
                if (!hasCompliance) {
                  complianceIssues.push({
                    severity: 'high',
                    statute: 'Road Safety Act 1986',
                    section: 's.55(1) - Evidentiary Test',
                    defect: 'Evidentiary test mentioned but compliance not documented',
                    compliance: 'unclear',
                    remediation: 'Document compliance with s.55(1) evidentiary test requirements'
                  });
                }
              }

              // Check 2.8: Time of test vs time of driving
              const hasTestTime = /time\s+of\s+test|test\s+conducted\s+at|tested\s+at/i.test(content);
              const hasDrivingTime = /time\s+of\s+(?:driving|incident|offence)|drove\s+at|driving\s+at/i.test(content);
              if (hasTestTime && !hasDrivingTime) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Road Safety Act 1986',
                  section: 'Temporal Requirements',
                  defect: 'Test time documented but time of driving unclear',
                  compliance: 'unclear',
                  remediation: 'Establish temporal link between driving and test administration'
                });
              }
            }

            // ====================================================================================
            // PART 3: EVIDENCE ACT 2008 COMPLIANCE
            // ====================================================================================

            // Check 3.1: Hearsay issues (s.59)
            const hearsayIndicators = /(?:he|she|they)\s+(?:said|told|stated)|told\s+(?:me|us|the\s+officer)|stated\s+that|informed\s+(?:me|us)|reported\s+that/i;
            const hasHearsay = hearsayIndicators.test(content);
            if (hasHearsay) {
              complianceIssues.push({
                severity: 'high',
                statute: 'Evidence Act 2008 (Vic)',
                section: 's.59 - Hearsay Rule',
                defect: 'Potential hearsay evidence identified',
                compliance: 'unclear',
                remediation: 'Verify hearsay is admissible under exception (s.60-69) or consider s.59 exclusion'
              });

              // Check 3.2: If hearsay, is exception claimed? (s.60-69)
              const hearsayExceptions = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay|business\s+records|contemporaneous\s+statement/i;
              if (!hearsayExceptions.test(content)) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Evidence Act 2008 (Vic)',
                  section: 's.60-69 - Hearsay Exceptions',
                  defect: 'Hearsay evidence present but no exception claimed',
                  compliance: 'non-compliant',
                  remediation: 'Identify applicable hearsay exception under s.60-69 or exclude evidence'
                });
              }

              // Check 3.3: Business records exception (s.69)
              const businessRecords = /business\s+records?|s(?:ection)?\s*69|records?\s+(?:kept|made)\s+in\s+(?:the\s+)?course\s+of.*business/i;
              if (businessRecords.test(content)) {
                const hasFoundation = /person\s+with\s+knowledge|made\s+(?:by|at)|kept\s+in\s+(?:the\s+)?ordinary\s+course/i.test(content);
                if (!hasFoundation) {
                  complianceIssues.push({
                    severity: 'high',
                    statute: 'Evidence Act 2008 (Vic)',
                    section: 's.69 - Business Records',
                    defect: 'Business records exception invoked but foundation not established',
                    compliance: 'unclear',
                    remediation: 'Establish s.69 requirements: record made by competent person, in ordinary course'
                  });
                }
              }
            }

            // Check 3.4: Section 137 - probative vs prejudicial
            const highlyPrejudicial = /prior\s+(?:conviction|offence)|bad\s+character|previous\s+(?:criminal|bad)\s+(?:conduct|behaviour)|prejudicial/i;
            if (highlyPrejudicial.test(content)) {
              complianceIssues.push({
                severity: 'medium',
                statute: 'Evidence Act 2008 (Vic)',
                section: 's.137 - Probative vs Prejudicial',
                defect: 'Potentially prejudicial evidence - probative value may be outweighed',
                compliance: 'consider-exclusion',
                remediation: 'Court discretion under s.137: exclude if probative value < unfair prejudice'
              });
            }

            // Check 3.5: Section 138 - improperly obtained evidence
            const improperlyObtained = /obtained\s+(?:illegally|unlawfully|improperly)|breach\s+of|violated|without\s+(?:warrant|authority|consent)|unlawful\s+(?:search|seizure)/i;
            if (improperlyObtained.test(content)) {
              complianceIssues.push({
                severity: 'critical',
                statute: 'Evidence Act 2008 (Vic)',
                section: 's.138 - Improperly Obtained Evidence',
                defect: 'Evidence may have been improperly or illegally obtained',
                compliance: 'non-compliant',
                remediation: 'Court must consider s.138 discretionary exclusion for improperly obtained evidence'
              });
            }

            // ====================================================================================
            // PART 4: GENERAL VICTORIAN COMPLIANCE CHECKS
            // ====================================================================================

            // Check 4.1: Victoria Police Act 2013 compliance
            if (documentType === 'Victoria Police Manual' || /victoria\s+police/i.test(content)) {
              if (!/Victoria\s+Police\s+Act\s+2013/i.test(content)) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Victoria Police Act 2013',
                  section: 'General Compliance',
                  defect: 'Police procedures should reference Victoria Police Act 2013',
                  compliance: 'potentially non-compliant',
                  remediation: 'Add reference to Victoria Police Act 2013'
                });
              }
            }

            // Check 4.2: Charter of Human Rights compliance
            const humanRightsIndicators = /rights?|fairness|natural justice|discrimination|equality/i;
            if (humanRightsIndicators.test(content)) {
              if (!/Charter\s+of\s+Human\s+Rights/i.test(content)) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Charter of Human Rights and Responsibilities Act 2006',
                  section: 'Human rights considerations',
                  defect: 'Document discusses rights but does not reference Charter',
                  compliance: 'consider-charter',
                  remediation: 'Consider whether Charter of Human Rights and Responsibilities Act 2006 is engaged'
                });
              }
            }

            // Check 4.3: Court-specific compliance
            if (documentType === 'Court Order' || documentType === 'Court Documentation') {
              const hasCourtRef = /Supreme\s+Court|County\s+Court|Magistrates/i.test(content);
              const hasFullCourtName = /Supreme\s+Court\s+of\s+Victoria|County\s+Court\s+of\s+Victoria|Magistrates[\'']?\s+Court\s+of\s+Victoria/i.test(content);

              if (hasCourtRef && !hasFullCourtName) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Court rules and procedures',
                  section: 'Court identification',
                  defect: 'Court references must use full official name including "of Victoria"',
                  compliance: 'non-compliant',
                  remediation: 'Use full court names: "Supreme Court of Victoria", "County Court of Victoria", "Magistrates\' Court of Victoria"'
                });
              }
            }

            return complianceIssues;
          };

          // Cross-File Narrative and Timeline Evaluator
          const evaluateCrossFileNarrativeTimeline = (contentA, contentB, fileAMetadata, fileBMetadata) => {
            const narrativeAnalysis = {
              timelineDiscrepancies: [],
              narrativeInconsistencies: [],
              eventSequenceMismatch: [],
              factualContradictions: [],
              sequentialMapping: []
            };

            // Extract dates and temporal references from both files
            const datesA = extractDatesAndTimeline(contentA);
            const datesB = extractDatesAndTimeline(contentB);

            // Extract events and narrative elements
            const eventsA = extractNarrativeEvents(contentA);
            const eventsB = extractNarrativeEvents(contentB);

            // Compare timelines
            datesA.forEach(dateA => {
              const matchingDatesB = datesB.filter(dateB =>
                dateB.normalizedDate === dateA.normalizedDate
              );

              if (matchingDatesB.length > 0) {
                matchingDatesB.forEach(dateB => {
                  if (dateA.context !== dateB.context) {
                    narrativeAnalysis.timelineDiscrepancies.push({
                      date: dateA.normalizedDate,
                      fileA: { line: dateA.line, context: dateA.context },
                      fileB: { line: dateB.line, context: dateB.context },
                      severity: 'high',
                      defect: 'Same date referenced with different contexts',
                      mapping: `File A Line ${dateA.line} vs File B Line ${dateB.line}`
                    });
                  }
                });
              }
            });

            // Compare event sequences
            const commonTerms = findCommonNarrativeTerms(eventsA, eventsB);
            commonTerms.forEach(term => {
              const orderA = eventsA.findIndex(e => e.text.toLowerCase().includes(term.toLowerCase()));
              const orderB = eventsB.findIndex(e => e.text.toLowerCase().includes(term.toLowerCase()));

              if (orderA !== -1 && orderB !== -1) {
                const contextA = eventsA[orderA];
                const contextB = eventsB[orderB];

                // Check if surrounding context differs significantly
                if (contextA.surrounding !== contextB.surrounding) {
                  narrativeAnalysis.eventSequenceMismatch.push({
                    term: term,
                    fileA: { line: contextA.line, sequence: orderA, context: contextA.text },
                    fileB: { line: contextB.line, sequence: orderB, context: contextB.text },
                    severity: 'medium',
                    defect: 'Same event referenced but surrounding narrative differs',
                    mapping: `File A Line ${contextA.line} (Event #${orderA + 1}) vs File B Line ${contextB.line} (Event #${orderB + 1})`
                  });
                }
              }
            });

            // Look for direct contradictions
            const contradictions = findFactualContradictions(contentA, contentB);
            narrativeAnalysis.factualContradictions = contradictions;

            // Build sequential mapping of all cross-referenced elements
            narrativeAnalysis.sequentialMapping = buildSequentialMapping(
              datesA,
              datesB,
              eventsA,
              eventsB,
              contentA,
              contentB
            );

            return narrativeAnalysis;
          };

          // Extract dates and temporal references
          const extractDatesAndTimeline = (content) => {
            const dates = [];
            const lines = content.split('\n');

            const datePatterns = [
              /\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\b/g,  // DD/MM/YYYY or DD-MM-YYYY
              /\b(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})\b/g,    // YYYY/MM/DD
              /\b(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\b/gi,
              /\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{1,2}),?\s+(\d{4})\b/gi
            ];

            lines.forEach((line, index) => {
              datePatterns.forEach(pattern => {
                const matches = [...line.matchAll(pattern)];
                matches.forEach(match => {
                  dates.push({
                    line: index + 1,
                    original: match[0],
                    normalizedDate: match[0],  // Simplified - would normally parse to standard format
                    context: line.trim()
                  });
                });
              });

              // Temporal markers
              const temporalMarkers = [
                /\bbefore\s+[^.]+/gi,
                /\bafter\s+[^.]+/gi,
                /\bwithin\s+\d+\s+(days?|weeks?|months?|years?)/gi,
                /\bon\s+or\s+about\s+[^.]+/gi
              ];

              temporalMarkers.forEach(pattern => {
                const matches = [...line.matchAll(pattern)];
                matches.forEach(match => {
                  dates.push({
                    line: index + 1,
                    original: match[0],
                    normalizedDate: 'temporal-marker',
                    context: line.trim()
                  });
                });
              });
            });

            return dates;
          };

          // Extract narrative events
          const extractNarrativeEvents = (content) => {
            const events = [];
            const lines = content.split('\n');

            const eventIndicators = [
              /\b(occurred|happened|took place|transpired|witnessed|observed|attended|conducted|performed|executed)\b/gi,
              /\b(seized|arrested|detained|charged|interviewed|questioned)\b/gi,
              /\b(stated|declared|asserted|claimed|testified|deposed)\b/gi,
              /\b(found|discovered|located|identified|recovered)\b/gi
            ];

            lines.forEach((line, index) => {
              eventIndicators.forEach(pattern => {
                if (pattern.test(line)) {
                  const surrounding = lines.slice(Math.max(0, index - 1), Math.min(lines.length, index + 2)).join(' ');
                  events.push({
                    line: index + 1,
                    text: line.trim(),
                    surrounding: surrounding.trim()
                  });
                }
              });
            });

            return events;
          };

          // Find common narrative terms
          const findCommonNarrativeTerms = (eventsA, eventsB) => {
            const termsA = new Set(
              eventsA.flatMap(e => e.text.toLowerCase().match(/\b\w{4,}\b/g) || [])
            );
            const termsB = new Set(
              eventsB.flatMap(e => e.text.toLowerCase().match(/\b\w{4,}\b/g) || [])
            );

            return [...termsA].filter(term => termsB.has(term) && !['this', 'that', 'with', 'from', 'have', 'been', 'were', 'said'].includes(term));
          };

          // Find factual contradictions
          const findFactualContradictions = (contentA, contentB) => {
            const contradictions = [];

            // Simple contradiction patterns
            const contradictionPatterns = [
              { pattern: /\b(yes|no|true|false|did|did not|was|was not)\b/gi, type: 'affirmation/negation' },
              { pattern: /\b\d+\s+(person|people|officer|individual|item|exhibit)/gi, type: 'quantity' },
              { pattern: /\b(present|absent|available|unavailable)\b/gi, type: 'presence' }
            ];

            // This is a simplified version - full implementation would use NLP
            contradictionPatterns.forEach(({ pattern, type }) => {
              const matchesA = contentA.match(pattern) || [];
              const matchesB = contentB.match(pattern) || [];

              if (matchesA.length > 0 && matchesB.length > 0) {
                const uniqueA = new Set(matchesA.map(m => m.toLowerCase()));
                const uniqueB = new Set(matchesB.map(m => m.toLowerCase()));

                // Check for direct opposites
                uniqueA.forEach(a => {
                  if (a.includes('not') && uniqueB.has(a.replace(/not\s+/, ''))) {
                    contradictions.push({
                      type: type,
                      fileA: a,
                      fileB: a.replace(/not\s+/, ''),
                      severity: 'high',
                      defect: 'Direct contradiction between documents'
                    });
                  }
                });
              }
            });

            return contradictions;
          };

          // Build sequential mapping
          const buildSequentialMapping = (datesA, datesB, eventsA, eventsB, contentA, contentB) => {
            const mapping = [];

            // Map all dates sequentially
            datesA.forEach((dateA, indexA) => {
              mapping.push({
                sequenceNumber: mapping.length + 1,
                type: 'temporal',
                source: 'File A',
                line: dateA.line,
                element: dateA.original,
                context: dateA.context,
                crossReference: datesB.find(db => db.normalizedDate === dateA.normalizedDate) || null
              });
            });

            datesB.forEach((dateB, indexB) => {
              if (!mapping.find(m => m.source === 'File B' && m.line === dateB.line)) {
                mapping.push({
                  sequenceNumber: mapping.length + 1,
                  type: 'temporal',
                  source: 'File B',
                  line: dateB.line,
                  element: dateB.original,
                  context: dateB.context,
                  crossReference: datesA.find(da => da.normalizedDate === dateB.normalizedDate) || null
                });
              }
            });

            // Map all events sequentially
            eventsA.forEach(eventA => {
              mapping.push({
                sequenceNumber: mapping.length + 1,
                type: 'narrative-event',
                source: 'File A',
                line: eventA.line,
                element: eventA.text,
                context: eventA.surrounding,
                crossReference: null
              });
            });

            eventsB.forEach(eventB => {
              mapping.push({
                sequenceNumber: mapping.length + 1,
                type: 'narrative-event',
                source: 'File B',
                line: eventB.line,
                element: eventB.text,
                context: eventB.surrounding,
                crossReference: null
              });
            });

            return mapping.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
          };

          // Generate Comprehensive Omissions Report - Doc A vs Doc B
          const generateOmissionsReport = (contentA, contentB, phaseAResults) => {
            const report = {
              statutoryReferences: {
                inANotInB: [],
                inBNotInA: []
              },
              proceduralElements: {
                inANotInB: [],
                inBNotInA: []
              },
              factsAndAssertions: {
                inANotInB: [],
                inBNotInA: []
              },
              criticalOmissions: {
                victorianCriminalRequirements: []
              }
            };

            // Extract statutory references
            const refsA = new Set(phaseAResults.fileA[0].findings.legalReferences.map(r => r.text));
            const refsB = new Set(phaseAResults.fileB[0].findings.legalReferences.map(r => r.text));

            refsA.forEach(ref => {
              if (!refsB.has(ref)) {
                report.statutoryReferences.inANotInB.push({
                  element: ref,
                  category: 'Statutory Reference',
                  severity: 'high',
                  impact: 'Legal authority present in Doc A but not referenced in Doc B'
                });
              }
            });

            refsB.forEach(ref => {
              if (!refsA.has(ref)) {
                report.statutoryReferences.inBNotInA.push({
                  element: ref,
                  category: 'Statutory Reference',
                  severity: 'high',
                  impact: 'Legal authority present in Doc B but not referenced in Doc A'
                });
              }
            });

            // Extract procedural elements
            const proceduralA = phaseAResults.fileA[0].findings.proceduralElements || [];
            const proceduralB = phaseAResults.fileB[0].findings.proceduralElements || [];

            const procTypesA = new Set(proceduralA.map(p => p.type));
            const procTypesB = new Set(proceduralB.map(p => p.type));

            procTypesA.forEach(type => {
              if (!procTypesB.has(type)) {
                const examples = proceduralA.find(p => p.type === type)?.examples || [];
                report.proceduralElements.inANotInB.push({
                  element: type,
                  category: 'Procedural Element',
                  severity: 'medium',
                  examples: examples.slice(0, 2),
                  impact: 'Procedural step described in Doc A but omitted from Doc B'
                });
              }
            });

            procTypesB.forEach(type => {
              if (!procTypesA.has(type)) {
                const examples = proceduralB.find(p => p.type === type)?.examples || [];
                report.proceduralElements.inBNotInA.push({
                  element: type,
                  category: 'Procedural Element',
                  severity: 'medium',
                  examples: examples.slice(0, 2),
                  impact: 'Procedural step described in Doc B but omitted from Doc A'
                });
              }
            });

            // Critical Victorian Criminal Matter Omissions

            // Check: "in accordance with directions" language (s.55D RSA 1986)
            const hasDirectionsA = /in\s+accordance\s+with\s+directions?/i.test(contentA);
            const hasDirectionsB = /in\s+accordance\s+with\s+directions?/i.test(contentB);
            if (hasDirectionsA && !hasDirectionsB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: '"In accordance with directions" language',
                statute: 'Road Safety Act 1986 s.55D(1)',
                severity: 'critical',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Critical RSA 1986 s.55D(1) compliance requirement missing from Doc B'
              });
            }
            if (hasDirectionsB && !hasDirectionsA) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: '"In accordance with directions" language',
                statute: 'Road Safety Act 1986 s.55D(1)',
                severity: 'critical',
                inDocument: 'Doc B',
                omittedFrom: 'Doc A',
                impact: 'Critical RSA 1986 s.55D(1) compliance requirement missing from Doc A'
              });
            }

            // Check: Officer's subjective belief formation (s.49 RSA 1986)
            const hasReasonToBelieveA = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)/i.test(contentA);
            const hasReasonToBelieveB = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)/i.test(contentB);
            if (hasReasonToBelieveA && !hasReasonToBelieveB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Officer\'s "reason to believe" formation',
                statute: 'Road Safety Act 1986 s.49(1)',
                severity: 'critical',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Critical s.49(1) requirement - officer\'s subjective belief not documented in Doc B'
              });
            }
            if (hasReasonToBelieveB && !hasReasonToBelieveA) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Officer\'s "reason to believe" formation',
                statute: 'Road Safety Act 1986 s.49(1)',
                severity: 'critical',
                inDocument: 'Doc B',
                omittedFrom: 'Doc A',
                impact: 'Critical s.49(1) requirement - officer\'s subjective belief not documented in Doc A'
              });
            }

            // Check: Device approval number (s.55E RSA 1986)
            const hasApprovalA = /approval\s+(?:number|no\.?|#)|device\s+(?:number|no\.?|#)/i.test(contentA);
            const hasApprovalB = /approval\s+(?:number|no\.?|#)|device\s+(?:number|no\.?|#)/i.test(contentB);
            if (hasApprovalA && !hasApprovalB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Device approval number',
                statute: 'Road Safety Act 1986 s.55E',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Device approval number (s.55E proper performance) missing from Doc B'
              });
            }

            // Check: Calibration/maintenance records (s.55E proper performance)
            const hasCalibrationA = /calibrat(?:ed|ion)|maintenance|service/i.test(contentA);
            const hasCalibrationB = /calibrat(?:ed|ion)|maintenance|service/i.test(contentB);
            if (hasCalibrationA && !hasCalibrationB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Calibration/maintenance records',
                statute: 'Road Safety Act 1986 s.55E',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Proper performance indicators (s.55E) - calibration/maintenance omitted from Doc B'
              });
            }

            // Check: Time of test vs time of driving
            const hasTestTimeA = /time\s+of\s+test|test\s+(?:conducted|administered)\s+at/i.test(contentA);
            const hasTestTimeB = /time\s+of\s+test|test\s+(?:conducted|administered)\s+at/i.test(contentB);
            const hasDrivingTimeA = /time\s+of\s+(?:driving|incident|offence)/i.test(contentA);
            const hasDrivingTimeB = /time\s+of\s+(?:driving|incident|offence)/i.test(contentB);

            if (hasTestTimeA && !hasTestTimeB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Time of test administration',
                statute: 'Road Safety Act 1986 - Temporal Requirements',
                severity: 'medium',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Test timing documented in Doc A but omitted from Doc B'
              });
            }

            if (hasDrivingTimeA && !hasDrivingTimeB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Time of driving/incident',
                statute: 'Road Safety Act 1986 - Temporal Requirements',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Critical temporal element - driving time in Doc A but omitted from Doc B'
              });
            }

            // Check: Hearsay exceptions
            const hasHearsayExceptionA = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay/i.test(contentA);
            const hasHearsayExceptionB = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay/i.test(contentB);
            if (hasHearsayExceptionA && !hasHearsayExceptionB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Hearsay exception claim',
                statute: 'Evidence Act 2008 (Vic) s.60-69',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Hearsay exception basis in Doc A but not asserted in Doc B'
              });
            }

            return report;
          };

          // Build Enhanced Cross-Reference Matrix with Doc A vs Doc B Compliance
          const buildComplianceMatrix = (phaseAResults, complianceA, complianceB) => {
            const matrix = [];

            // Build a comprehensive list of all statutory provisions mentioned
            const provisionsMap = new Map();

            // Add provisions from Victorian compliance checks
            [...complianceA, ...complianceB].forEach(issue => {
              const key = `${issue.statute}|${issue.section}`;
              if (!provisionsMap.has(key)) {
                provisionsMap.set(key, {
                  provision: `${issue.statute} - ${issue.section}`,
                  statute: issue.statute,
                  section: issue.section,
                  docACompliance: null,
                  docBCompliance: null,
                  docAIssues: [],
                  docBIssues: [],
                  discrepancies: []
                });
              }
            });

            // Populate Doc A compliance
            complianceA.forEach(issue => {
              const key = `${issue.statute}|${issue.section}`;
              const provision = provisionsMap.get(key);
              if (provision) {
                provision.docAIssues.push(issue);
                // Determine compliance status
                if (issue.compliance === 'compliant') {
                  provision.docACompliance = 'compliant';
                } else if (issue.compliance === 'non-compliant') {
                  provision.docACompliance = 'non-compliant';
                } else {
                  provision.docACompliance = 'unclear';
                }
              }
            });

            // Populate Doc B compliance
            complianceB.forEach(issue => {
              const key = `${issue.statute}|${issue.section}`;
              const provision = provisionsMap.get(key);
              if (provision) {
                provision.docBIssues.push(issue);
                // Determine compliance status
                if (issue.compliance === 'compliant') {
                  provision.docBCompliance = 'compliant';
                } else if (issue.compliance === 'non-compliant') {
                  provision.docBCompliance = 'non-compliant';
                } else {
                  provision.docBCompliance = 'unclear';
                }
              }
            });

            // Identify discrepancies and determine actions
            provisionsMap.forEach((provision, key) => {
              // Default to compliant if no issues found
              if (provision.docACompliance === null && provision.docAIssues.length === 0) {
                provision.docACompliance = 'compliant';
              }
              if (provision.docBCompliance === null && provision.docBIssues.length === 0) {
                provision.docBCompliance = 'compliant';
              }

              // Identify discrepancies
              if (provision.docACompliance !== provision.docBCompliance) {
                provision.discrepancies.push(`Doc A is ${provision.docACompliance || 'unknown'} but Doc B is ${provision.docBCompliance || 'unknown'}`);
              }

              // Determine action required based on compliance
              const highSeverityA = provision.docAIssues.filter(i => i.severity === 'critical' || i.severity === 'high');
              const highSeverityB = provision.docBIssues.filter(i => i.severity === 'critical' || i.severity === 'high');

              if (highSeverityA.length > 0 || highSeverityB.length > 0) {
                provision.actionRequired = 'URGENT: Address critical/high severity issues immediately';
              } else if (provision.docAIssues.length > 0 || provision.docBIssues.length > 0) {
                provision.actionRequired = 'Review and remediate medium/low severity issues';
              } else {
                provision.actionRequired = 'No action required - monitoring';
              }

              matrix.push(provision);
            });

            // Sort by severity (critical issues first)
            matrix.sort((a, b) => {
              const aHasCritical = [...a.docAIssues, ...a.docBIssues].some(i => i.severity === 'critical');
              const bHasCritical = [...b.docAIssues, ...b.docBIssues].some(i => i.severity === 'critical');
              if (aHasCritical && !bHasCritical) return -1;
              if (!aHasCritical && bHasCritical) return 1;

              const aHasHigh = [...a.docAIssues, ...a.docBIssues].some(i => i.severity === 'high');
              const bHasHigh = [...b.docAIssues, ...b.docBIssues].some(i => i.severity === 'high');
              if (aHasHigh && !bHasHigh) return -1;
              if (!aHasHigh && bHasHigh) return 1;

              return 0;
            });

            return matrix;
          };

          const performCrossReference = (phaseAResults) => {
            const discrepancies = [];
            const consistencies = [];
            const omissions = [];

            const refsA = new Set(phaseAResults.fileA[0].findings.legalReferences.map(r => r.text.toLowerCase()));
            const refsB = new Set(phaseAResults.fileB[0].findings.legalReferences.map(r => r.text.toLowerCase()));

            refsA.forEach(ref => {
              if (refsB.has(ref)) {
                consistencies.push({ type: 'Statutory Reference', element: ref, status: 'Present in both documents' });
              } else {
                omissions.push({ type: 'Statutory Reference', element: ref, status: 'Present only in File A' });
              }
            });

            refsB.forEach(ref => {
              if (!refsA.has(ref)) {
                omissions.push({ type: 'Statutory Reference', element: ref, status: 'Present only in File B' });
              }
            });

            const termsA = phaseAResults.fileA[0].findings.keyTermsIdentified.map(t => t.term);
            const termsB = phaseAResults.fileB[0].findings.keyTermsIdentified.map(t => t.term);

            const significantDiscrepancy = Math.abs(termsA.length - termsB.length) > 5;
            if (significantDiscrepancy) {
              discrepancies.push({
                type: 'Document Comprehensiveness',
                description: `Significant difference in legal terminology density (File A: ${termsA.length} terms, File B: ${termsB.length} terms)`,
                severity: 'medium'
              });
            }

            // Add Victorian statutory compliance checks
            const complianceA = checkVictorianStatutoryCompliance(
              fileContents.fileA,
              files.fileA?.documentType || 'General Legal Document',
              phaseAResults.fileA[0].findings.legalReferences
            );

            const complianceB = checkVictorianStatutoryCompliance(
              fileContents.fileB,
              files.fileB?.documentType || 'General Legal Document',
              phaseAResults.fileB[0].findings.legalReferences
            );

            // Add narrative and timeline evaluation
            const narrativeEvaluation = evaluateCrossFileNarrativeTimeline(
              fileContents.fileA,
              fileContents.fileB,
              files.fileA,
              files.fileB
            );

            // Generate comprehensive omissions report
            const omissionsReport = generateOmissionsReport(
              fileContents.fileA,
              fileContents.fileB,
              phaseAResults
            );

            // Build enhanced compliance matrix
            const complianceMatrix = buildComplianceMatrix(
              phaseAResults,
              complianceA,
              complianceB
            );

            return {
              discrepancies,
              consistencies: consistencies.slice(0, 10),
              omissions: omissions.slice(0, 10),
              omissionsReport: omissionsReport,
              complianceMatrix: complianceMatrix,
              governingFramework: identifyGoverningFramework(phaseAResults),
              complianceAssessment: assessCompliance(phaseAResults),
              victorianCompliance: {
                fileA: complianceA,
                fileB: complianceB
              },
              narrativeAndTimeline: narrativeEvaluation
            };
          };

          const identifyGoverningFramework = (phaseAResults) => {
            const frameworks = [];
            
            phaseAResults.fileA.forEach(analysis => {
              analysis.findings.legalReferences.forEach(ref => {
                if (ref.type === 'Act Citation') {
                  frameworks.push({
                    statute: ref.text,
                    source: 'File A',
                    applicability: 'Primary governing legislation'
                  });
                }
              });
            });
            
            phaseAResults.fileB.forEach(analysis => {
              analysis.findings.legalReferences.forEach(ref => {
                if (ref.type === 'Act Citation') {
                  frameworks.push({
                    statute: ref.text,
                    source: 'File B',
                    applicability: 'Primary governing legislation'
                  });
                }
              });
            });
            
            return frameworks;
          };

          const assessCompliance = (phaseAResults) => {
            const assessment = {
              fileA: {
                compliant: 0,
                nonCompliant: 0,
                unclear: 0,
                criticalIssues: 0,
                highIssues: 0,
                mediumIssues: 0,
                lowIssues: 0,
                totalWeight: 0,
                riskLevel: 'LOW'
              },
              fileB: {
                compliant: 0,
                nonCompliant: 0,
                unclear: 0,
                criticalIssues: 0,
                highIssues: 0,
                mediumIssues: 0,
                lowIssues: 0,
                totalWeight: 0,
                riskLevel: 'LOW'
              }
            };

            ['fileA', 'fileB'].forEach(fileKey => {
              let fileRiskScore = 0;

              phaseAResults[fileKey].forEach(analysis => {
                const potentialIssues = analysis.findings.potentialIssues;

                // Handle both old format (array) and new format (object with issues/summary)
                const issues = potentialIssues.issues || potentialIssues;
                const summary = potentialIssues.summary;

                if (summary) {
                  // New enhanced format
                  assessment[fileKey].criticalIssues += summary.critical || 0;
                  assessment[fileKey].highIssues += summary.high || 0;
                  assessment[fileKey].mediumIssues += summary.medium || 0;
                  assessment[fileKey].lowIssues += summary.low || 0;
                  fileRiskScore += summary.overallRiskScore || 0;

                  if (summary.critical > 0 || summary.high > 0) {
                    assessment[fileKey].nonCompliant++;
                  } else if (summary.medium > 0) {
                    assessment[fileKey].unclear++;
                  } else {
                    assessment[fileKey].compliant++;
                  }
                } else {
                  // Old simple format (backward compatibility)
                  if (issues.length === 0) {
                    assessment[fileKey].compliant++;
                  } else {
                    issues.forEach(issue => {
                      if (issue.severity === 'critical') {
                        assessment[fileKey].criticalIssues++;
                        assessment[fileKey].nonCompliant++;
                      } else if (issue.severity === 'high') {
                        assessment[fileKey].highIssues++;
                        assessment[fileKey].nonCompliant++;
                      } else if (issue.severity === 'medium') {
                        assessment[fileKey].mediumIssues++;
                        assessment[fileKey].unclear++;
                      } else {
                        assessment[fileKey].lowIssues++;
                        assessment[fileKey].unclear++;
                      }
                    });
                  }
                }
              });

              assessment[fileKey].totalWeight = fileRiskScore;
              assessment[fileKey].riskLevel = fileRiskScore > 40 ? 'CRITICAL' :
                                               fileRiskScore > 25 ? 'HIGH' :
                                               fileRiskScore > 15 ? 'MEDIUM' : 'LOW';
            });

            return assessment;
          };

          const performStatutoryInterpretation = (phaseAResults, phaseBResults) => {
            return {
              literalInterpretation: {
                approach: 'Textualist/Literal Analysis',
                findings: 'Analysis focuses on the plain, ordinary meaning of words as they appear in both documents. Words must be interpreted in their natural sense unless context demands otherwise.'
              },
              contextualInterpretation: {
                approach: 'Contextual Analysis',
                findings: 'Words interpreted within their statutory context - considering surrounding provisions, the scheme of the legislation, and the relationship between documents.'
              },
              purposiveInterpretation: {
                approach: 'Purposive/Mischief Rule',
                findings: 'Interpretation seeks to advance the legislative purpose and remedy the mischief the statute was designed to address. Requires consideration of extrinsic materials where ambiguity exists.'
              },
              harmonization: {
                approach: 'Harmonious Construction',
                findings: 'Provisions must be read together to give effect to all parts. Inconsistencies between File A and File B require reconciliation using established interpretative principles.'
              },
              extrinsicAids: {
                availableAids: [
                  'Second reading speeches (for Commonwealth legislation)',
                  'Explanatory memoranda',
                  'Parliamentary debates (Hansard)',
                  'Prior judicial interpretation',
                  'Legislative history and amendments'
                ],
                application: 'Extrinsic materials may be consulted to confirm meaning or resolve ambiguity, but cannot override clear statutory language.'
              },
              interpretativePrinciples: [
                {
                  principle: 'Acts Interpretation Act 1901 (Cth) s 15AA',
                  application: 'Interpretation that promotes the purpose of the legislation is preferred'
                },
                {
                  principle: 'Generalia specialibus non derogant',
                  application: 'Specific provisions prevail over general provisions'
                },
                {
                  principle: 'Expressio unius est exclusio alterius',
                  application: 'Express mention of one thing excludes others'
                },
                {
                  principle: 'Noscitur a sociis',
                  application: 'Words are known by their associates - interpret terms by their context'
                }
              ],
              resolutionOfAmbiguity: generateAmbiguityResolution(phaseBResults)
            };
          };

          const generateAmbiguityResolution = (phaseBResults) => {
            const resolutions = [];
            
            phaseBResults.discrepancies.forEach(discrepancy => {
              resolutions.push({
                ambiguity: discrepancy.description,
                resolutionMethod: 'Apply modern purposive approach: examine text, context, and legislative purpose',
                recommendation: 'Seek extrinsic materials if ambiguity persists after textual and contextual analysis'
              });
            });
            
            if (resolutions.length === 0) {
              resolutions.push({
                ambiguity: 'No significant ambiguities identified',
                resolutionMethod: 'Plain meaning approach sufficient',
                recommendation: 'Proceed with literal interpretation absent contrary indicators'
              });
            }
            
            return resolutions;
          };

          const generateExecutiveSummary = (phaseA, phaseB, phaseC) => {
            const totalIssuesA = phaseA.fileA.reduce((sum, analysis) => sum + analysis.findings.potentialIssues.length, 0);
            const totalIssuesB = phaseA.fileB.reduce((sum, analysis) => sum + analysis.findings.potentialIssues.length, 0);
            
            return {
              overallAssessment: totalIssuesA + totalIssuesB === 0 ? 'No Critical Issues Identified' : 'Issues Requiring Attention Identified',
              criticalFindings: [
                `File A: ${totalIssuesA} potential issues identified across ${interpretivePresets.length} analytical presets`,
                `File B: ${totalIssuesB} potential issues identified across ${interpretivePresets.length} analytical presets`,
                `Cross-reference analysis: ${phaseB.discrepancies.length} discrepancies, ${phaseB.omissions.length} omissions`,
                `Governing framework: ${phaseB.governingFramework.length} statutory instruments identified`
              ],
              recommendations: [
                'Review all identified discrepancies for potential procedural defects',
                'Verify compliance with mandatory statutory requirements',
                'Consider extrinsic materials for ambiguity resolution where necessary',
                'Cross-check all statutory references against current legislation',
                'Ensure harmonious interpretation between documents where possible'
              ],
              nextSteps: [
                'Detailed review of high-severity issues',
                'Consultation of relevant case law for interpretative guidance',
                'Preparation of submissions addressing identified defects',
                'Verification of all factual assertions against evidence'
              ]
            };
          };

          const toggleSection = (sectionId) => {
            setExpandedSections(prev => ({
              ...prev,
              [sectionId]: !prev[sectionId]
            }));
          };

          const exportReport = async () => {
            if (!analysisResults) return;

            // Generate enhanced report with historical context
            const learningInsights = await AnalysisMemory.generateLearningInsights();
            const currentDefects = AnalysisMemory.extractDefects(analysisResults);
            const crossIntelligence = await AnalysisMemory.getIntelligenceForAnalysis(currentDefects);
            const allPatterns = await AnalysisMemory.getAllDefectPatterns();
            const allStatutes = await AnalysisMemory.getAllStatutoryReferences();

            const enhancedReport = {
              metadata: {
                exportDate: new Date().toISOString(),
                reportVersion: '2.0-Enhanced',
                includesLearningData: true
              },
              currentAnalysis: {
                timestamp: new Date().toISOString(),
                files: {
                  fileA: files.fileA?.name,
                  fileB: files.fileB?.name
                },
                findings: analysisResults,
                defectsFound: currentDefects.length,
                severitySummary: AnalysisMemory.calculateSeveritySummary(currentDefects)
              },
              systemIntelligence: {
                totalHistoricalAnalyses: learningInsights.totalAnalyses,
                totalDefectsTracked: learningInsights.totalDefects,
                mostCommonIssue: learningInsights.mostCommonIssue,
                complianceTrends: learningInsights.temporalTrends,
                recommendations: learningInsights.recommendations
              },
              crossAnalysisIntelligence: {
                novelIssues: crossIntelligence.filter(i => i.isNovel).length,
                recurringIssues: crossIntelligence.filter(i => i.isRecurring).length,
                details: crossIntelligence.map(intel => ({
                  defectType: intel.defect.type,
                  severity: intel.defect.severity,
                  description: intel.defect.description,
                  isNovel: intel.isNovel,
                  isRecurring: intel.isRecurring,
                  previousOccurrences: intel.previousOccurrences || 0,
                  recommendation: intel.recommendation
                }))
              },
              defectPatterns: {
                total: allPatterns.length,
                recurring: allPatterns.filter(p => p.occurrence_count >= 3).length,
                patterns: allPatterns.map(p => ({
                  type: p.defect_type,
                  description: p.description,
                  occurrences: p.occurrence_count,
                  firstSeen: p.first_seen,
                  lastSeen: p.last_seen,
                  recommendation: p.recommendation
                }))
              },
              statutoryCompliance: {
                total: allStatutes.length,
                compliance: allStatutes.map(s => ({
                  reference: s.reference,
                  statute: s.statute_name,
                  timesEncountered: s.times_encountered,
                  complianceRate: s.compliance_rate,
                  associatedDefects: s.associated_defects
                }))
              },
              exportedBy: 'Forensic Legal Analyzer v2.0 - Enhanced Learning System'
            };

            // Create downloadable file
            const blob = new Blob([JSON.stringify(enhancedReport, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `forensic-analysis-enhanced-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            console.log('üì• Enhanced report exported with full learning context');
          };

          // Progress Bar Component
          const ProgressBar = ({ progress, label, showPercentage = true }) => (
            <div style={{ width: '100%', marginBottom: '12px' }}>
              {label && (
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  marginBottom: '6px',
                  fontSize: '13px',
                  color: '#374151'
                }}>
                  <span>{label}</span>
                  {showPercentage && <span>{progress}%</span>}
                </div>
              )}
              <div style={{
                width: '100%',
                height: '8px',
                backgroundColor: '#e5e7eb',
                borderRadius: '4px',
                overflow: 'hidden',
                position: 'relative'
              }}>
                <div
                  className="fade-in"
                  style={{
                    width: `${progress}%`,
                    height: '100%',
                    background: 'linear-gradient(to right, #2563eb, #1d4ed8)',
                    borderRadius: '4px',
                    transition: 'width 0.3s ease-in-out',
                    position: 'relative',
                    overflow: 'hidden'
                  }}
                >
                  <div style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)',
                    animation: 'shimmer 1.5s infinite'
                  }} />
                </div>
              </div>
            </div>
          );

          // Skeleton Loader Component
          const SkeletonLoader = ({ width = '100%', height = '20px', style = {} }) => (
            <div
              className="skeleton"
              style={{
                width,
                height,
                ...style
              }}
            />
          );

          // Enhanced Badge Component
          const Badge = ({ children, variant = 'default', size = 'md' }) => {
            const variants = {
              default: { bg: '#f3f4f6', color: '#374151' },
              success: { bg: '#dcfce7', color: '#166534' },
              warning: { bg: '#fef3c7', color: '#92400e' },
              error: { bg: '#fee2e2', color: '#991b1b' },
              info: { bg: '#dbeafe', color: '#1e40af' },
              primary: { bg: '#eff6ff', color: '#1e40af' }
            };

            const sizes = {
              sm: { padding: '2px 6px', fontSize: '11px' },
              md: { padding: '4px 10px', fontSize: '12px' },
              lg: { padding: '6px 14px', fontSize: '14px' }
            };

            const variantStyle = variants[variant] || variants.default;
            const sizeStyle = sizes[size] || sizes.md;

            return (
              <span style={{
                display: 'inline-block',
                ...sizeStyle,
                backgroundColor: variantStyle.bg,
                color: variantStyle.color,
                borderRadius: '9999px',
                fontWeight: '600',
                whiteSpace: 'nowrap'
              }}>
                {children}
              </span>
            );
          };

          const FileUploadZone = ({ fileKey, label }) => (
            <div style={{
              backgroundColor: 'white',
              borderRadius: '8px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
              padding: '24px',
              border: '2px dashed #d1d5db',
              transition: 'border-color 0.2s'
            }}>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '48px', marginBottom: '16px' }}>üìÑ</div>
                <h3 style={{ fontSize: '18px', fontWeight: '600', marginBottom: '8px' }}>{label}</h3>
                
                {isUploading[fileKey] ? (
                  <div className="fade-in" style={{ padding: '16px' }}>
                    <div style={{
                      fontSize: '32px',
                      marginBottom: '16px',
                      textAlign: 'center',
                      className: 'pulse'
                    }}>üì§</div>
                    <ProgressBar
                      progress={uploadProgress[fileKey]}
                      label="Uploading file..."
                      showPercentage={true}
                    />
                  </div>
                ) : !files[fileKey] ? (
                  <>
                    <div
                      onDragOver={handleDragOver}
                      onDrop={(e) => handleDrop(e, fileKey)}
                      style={{
                        marginBottom: '16px',
                        padding: '32px',
                        backgroundColor: '#f9fafb',
                        borderRadius: '8px'
                      }}
                    >
                      <p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '8px' }}>Drag and drop file here</p>
                      <p style={{ fontSize: '12px', color: '#9ca3af' }}>or</p>
                    </div>

                    <button
                      onClick={() => fileKey === 'fileA' ? fileInputA.current.click() : fileInputB.current.click()}
                      style={{
                        backgroundColor: '#2563eb',
                        color: 'white',
                        padding: '8px 16px',
                        borderRadius: '8px',
                        border: 'none',
                        cursor: 'pointer',
                        width: '100%',
                        marginBottom: '8px',
                        fontSize: '14px',
                        fontWeight: '500'
                      }}
                    >
                      ‚¨ÜÔ∏è Choose File
                    </button>

                    <p style={{
                      fontSize: '11px',
                      color: '#6b7280',
                      textAlign: 'center',
                      marginBottom: '8px',
                      lineHeight: '1.4'
                    }}>
                      Supports: PDF, Images (OCR), Text files
                    </p>

                    <div style={{ marginTop: '16px' }}>
                      <input
                        type="text"
                        placeholder="Or paste URL to document"
                        style={{
                          width: '100%',
                          padding: '8px 12px',
                          border: '1px solid #d1d5db',
                          borderRadius: '8px',
                          fontSize: '14px'
                        }}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && e.target.value) {
                            handleUrlUpload(e.target.value, fileKey);
                          }
                        }}
                      />
                    </div>
                    
                    <input
                      type="file"
                      ref={fileKey === 'fileA' ? fileInputA : fileInputB}
                      onChange={(e) => handleFileUpload(e.target.files[0], fileKey)}
                      style={{ display: 'none' }}
                      accept=".txt,.doc,.docx,.pdf,.png,.jpg,.jpeg,.gif,.bmp,.tiff,image/*"
                    />
                  </>
                ) : (
                  <div className="fade-in" style={{
                    backgroundColor: '#f0fdf4',
                    padding: '16px',
                    borderRadius: '8px',
                    border: '1px solid #bbf7d0'
                  }}>
                    <div style={{
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      marginBottom: '8px'
                    }}>
                      <div style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                        <span style={{ fontSize: '20px', marginRight: '8px' }}>‚úÖ</span>
                        <div style={{ flex: 1 }}>
                          <div style={{
                            fontSize: '14px',
                            fontWeight: '600',
                            color: '#166534',
                            marginBottom: '4px'
                          }}>
                            {files[fileKey].name}
                          </div>
                          {files[fileKey].documentType && (
                            <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                              <Badge variant="success" size="sm">
                                {files[fileKey].documentType}
                              </Badge>
                              {files[fileKey].size && (
                                <span style={{ fontSize: '11px', color: '#6b7280' }}>
                                  {(files[fileKey].size / 1024).toFixed(1)} KB
                                </span>
                              )}
                            </div>
                          )}
                        </div>
                      </div>
                      <button
                        onClick={() => {
                          setFiles(prev => ({ ...prev, [fileKey]: null }));
                          setFileContents(prev => ({ ...prev, [fileKey]: '' }));
                        }}
                        style={{
                          color: '#dc2626',
                          fontSize: '13px',
                          background: 'none',
                          border: 'none',
                          cursor: 'pointer',
                          padding: '4px 8px',
                          fontWeight: '500'
                        }}
                        aria-label={`Remove ${files[fileKey].name}`}
                      >
                        ‚úï Remove
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );

          const AnalysisSection = ({ title, children, sectionId }) => {
            const isExpanded = expandedSections[sectionId];

            return (
              <div
                className="fade-in"
                style={{
                  backgroundColor: 'white',
                  borderRadius: '8px',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
                  marginBottom: '16px',
                  overflow: 'hidden'
                }}
              >
                <button
                  onClick={() => toggleSection(sectionId)}
                  style={{
                    width: '100%',
                    padding: '24px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    background: isExpanded ? '#f9fafb' : 'none',
                    border: 'none',
                    cursor: 'pointer',
                    fontSize: '18px',
                    fontWeight: '600',
                    textAlign: 'left'
                  }}
                  aria-expanded={isExpanded}
                  aria-controls={`section-${sectionId}`}
                  role="button"
                  tabIndex={0}
                  onKeyPress={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      toggleSection(sectionId);
                    }
                  }}
                >
                  <span>{title}</span>
                  <span
                    style={{
                      fontSize: '14px',
                      transition: 'transform 0.2s ease-in-out',
                      transform: isExpanded ? 'rotate(0deg)' : 'rotate(-90deg)'
                    }}
                  >
                    ‚ñº
                  </span>
                </button>

                {isExpanded && (
                  <div
                    id={`section-${sectionId}`}
                    className="fade-in"
                    style={{
                      padding: '0 24px 24px',
                      borderTop: '1px solid #e5e7eb'
                    }}
                    role="region"
                    aria-labelledby={`section-${sectionId}-title`}
                  >
                    {children}
                  </div>
                )}
              </div>
            );
          };

          return (
            <div style={{
              minHeight: '100vh',
              background: 'linear-gradient(to bottom right, #eff6ff, #f3f4f6)',
              padding: '24px'
            }}>
              <div style={{ maxWidth: '1280px', margin: '0 auto' }}>
                <div style={{
                  backgroundColor: 'white',
                  borderRadius: '12px',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                  padding: '32px',
                  marginBottom: '24px'
                }}>
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    marginBottom: '24px'
                  }}>
                    <div>
                      <h1 style={{
                        fontSize: '30px',
                        fontWeight: 'bold',
                        color: '#111827',
                        marginBottom: '8px'
                      }}>
                        Forensic Legal Document Analyzer
                      </h1>
                      <p style={{ color: '#6b7280' }}>
                        Multi-Layered Interpretive Analysis System for Evidentiary Documents
                      </p>
                    </div>
                    <div style={{ fontSize: '48px' }}>üëÅÔ∏è</div>
                  </div>

                  <div style={{
                    backgroundColor: '#eff6ff',
                    borderLeft: '4px solid #2563eb',
                    padding: '16px',
                    marginBottom: '24px'
                  }}>
                    <h3 style={{
                      fontWeight: '600',
                      color: '#1e3a8a',
                      marginBottom: '8px'
                    }}>System Capabilities:</h3>
                    <ul style={{
                      fontSize: '14px',
                      color: '#1e40af',
                      listStyle: 'none',
                      padding: 0
                    }}>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Phase A: Multi-preset forensic examination using {interpretivePresets.length} interpretive frameworks</li>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Phase B: Statutory framework identification and cross-reference analysis</li>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Phase C: Comprehensive statutory interpretation applying modern purposive approach</li>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Identifies legal flaws, factual inconsistencies, and procedural defects</li>
                      <li style={{ marginBottom: '4px', fontWeight: '600' }}>‚Ä¢ üìä Learning System: Tracks defect patterns, compliance trends, and generates process improvements</li>
                      <li style={{ fontWeight: '600' }}>‚Ä¢ üîç Cross-Analysis Intelligence: Identifies recurring issues and novel defects across all analyses</li>
                    </ul>
                  </div>

                  <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
                    gap: '24px',
                    marginBottom: '24px'
                  }}>
                    <FileUploadZone fileKey="fileA" label="Document A (Primary Exhibit)" />
                    <FileUploadZone fileKey="fileB" label="Document B (Comparative Exhibit)" />
                  </div>

                  <div>
                    <button
                      onClick={simulateAnalysis}
                      disabled={!files.fileA || !files.fileB || analysisState === 'analyzing'}
                      style={{
                        width: '100%',
                        background: (!files.fileA || !files.fileB || analysisState === 'analyzing')
                          ? '#9ca3af'
                          : 'linear-gradient(to right, #2563eb, #1d4ed8)',
                        color: 'white',
                        padding: '16px',
                        borderRadius: '8px',
                        fontSize: '18px',
                        fontWeight: '600',
                        border: 'none',
                        cursor: (!files.fileA || !files.fileB || analysisState === 'analyzing') ? 'not-allowed' : 'pointer',
                        boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                        marginBottom: analysisState === 'analyzing' ? '12px' : '0'
                      }}
                      aria-label={analysisState === 'analyzing' ? 'Analysis in progress' : 'Start forensic analysis'}
                    >
                      {analysisState === 'analyzing' ? (
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                          <span className="spin">‚åõ</span>
                          <span>{currentPhase}</span>
                        </div>
                      ) : (
                        <>‚ö†Ô∏è Commence Forensic Analysis</>
                      )}
                    </button>
                    {analysisState === 'analyzing' && (
                      <div className="fade-in">
                        <ProgressBar
                          progress={analysisProgress}
                          showPercentage={true}
                        />
                      </div>
                    )}
                  </div>
                </div>

                {analysisResults && (
                  <div>
                    <div style={{
                      backgroundColor: 'white',
                      borderRadius: '12px',
                      boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                      padding: '24px',
                      marginBottom: '16px'
                    }}>
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        marginBottom: '16px'
                      }}>
                        <h2 style={{
                          fontSize: '24px',
                          fontWeight: 'bold',
                          color: '#111827'
                        }}>Analysis Report</h2>
                        <button
                          onClick={exportReport}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            padding: '8px 16px',
                            backgroundColor: '#16a34a',
                            color: 'white',
                            borderRadius: '8px',
                            border: 'none',
                            cursor: 'pointer',
                            fontSize: '14px'
                          }}
                        >
                          ‚¨áÔ∏è Export Report
                        </button>
                      </div>

                      <div style={{
                        backgroundColor: '#fef3c7',
                        borderLeft: '4px solid #f59e0b',
                        padding: '16px',
                        marginBottom: '24px'
                      }}>
                        <h3 style={{
                          fontWeight: '600',
                          color: '#78350f',
                          marginBottom: '8px'
                        }}>Executive Summary</h3>
                        <p style={{
                          fontSize: '14px',
                          color: '#92400e',
                          marginBottom: '12px'
                        }}>
                          <strong>Overall Assessment:</strong> {analysisResults.summary.overallAssessment}
                        </p>
                        <div style={{ fontSize: '14px', color: '#92400e' }}>
                          <strong>Critical Findings:</strong>
                          <ul style={{ marginTop: '8px', paddingLeft: '20px' }}>
                            {analysisResults.summary.criticalFindings.map((finding, idx) => (
                              <li key={idx} style={{ marginBottom: '4px' }}>{finding}</li>
                            ))}
                          </ul>
                        </div>
                      </div>

                      {/* Visual Statistics Dashboard */}
                      <div className="fade-in" style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                        gap: '16px',
                        marginBottom: '24px'
                      }}>
                        {(() => {
                          const countIssuesBySeverity = (severity) => {
                            let count = 0;
                            ['fileA', 'fileB'].forEach(fileKey => {
                              if (analysisResults.phaseA[fileKey]) {
                                analysisResults.phaseA[fileKey].forEach(preset => {
                                  const issues = preset.findings.potentialIssues;
                                  if (Array.isArray(issues)) {
                                    count += issues.filter(i => i.severity === severity).length;
                                  }
                                });
                              }
                            });
                            return count;
                          };

                          const totalIssues = ['critical', 'high', 'medium', 'low']
                            .reduce((sum, severity) => sum + countIssuesBySeverity(severity), 0);

                          const stats = [
                            {
                              label: 'Critical Issues',
                              value: countIssuesBySeverity('critical'),
                              icon: 'üî¥',
                              color: '#fee2e2',
                              textColor: '#991b1b'
                            },
                            {
                              label: 'High Priority',
                              value: countIssuesBySeverity('high'),
                              icon: 'üü°',
                              color: '#fef3c7',
                              textColor: '#92400e'
                            },
                            {
                              label: 'Medium Priority',
                              value: countIssuesBySeverity('medium'),
                              icon: 'üîµ',
                              color: '#dbeafe',
                              textColor: '#1e40af'
                            },
                            {
                              label: 'Total Issues',
                              value: totalIssues,
                              icon: 'üìä',
                              color: '#f3f4f6',
                              textColor: '#374151'
                            }
                          ];

                          return stats.map((stat, idx) => (
                            <div
                              key={idx}
                              style={{
                                backgroundColor: stat.color,
                                padding: '20px',
                                borderRadius: '12px',
                                border: '1px solid rgba(0,0,0,0.1)',
                                textAlign: 'center'
                              }}
                            >
                              <div style={{ fontSize: '32px', marginBottom: '8px' }}>
                                {stat.icon}
                              </div>
                              <div style={{
                                fontSize: '28px',
                                fontWeight: 'bold',
                                color: stat.textColor,
                                marginBottom: '4px'
                              }}>
                                {stat.value}
                              </div>
                              <div style={{
                                fontSize: '13px',
                                fontWeight: '500',
                                color: stat.textColor,
                                opacity: 0.8
                              }}>
                                {stat.label}
                              </div>
                            </div>
                          ));
                        })()}
                      </div>
                    </div>

                    <AnalysisSection title="Phase A: Multi-Preset Forensic Examination" sectionId="phaseA">
                      <div style={{ marginTop: '16px' }}>
                        <div>
                          <h4 style={{
                            fontWeight: '600',
                            fontSize: '18px',
                            marginBottom: '12px'
                          }}>Document A Analysis</h4>
                          {analysisResults.phaseA.fileA.map((analysis, idx) => (
                            <div key={idx} style={{
                              backgroundColor: '#f9fafb',
                              padding: '16px',
                              borderRadius: '8px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#1e40af',
                                marginBottom: '8px'
                              }}>{analysis.preset}</h5>
                              <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                                gap: '16px',
                                fontSize: '14px'
                              }}>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Word Count:</strong> {analysis.findings.wordCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Line Count:</strong> {analysis.findings.lineCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Key Terms:</strong> {analysis.findings.keyTermsIdentified.length}</p>
                                </div>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Legal References:</strong> {analysis.findings.legalReferences.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Procedural Elements:</strong> {analysis.findings.proceduralElements.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Potential Issues:</strong> {analysis.findings.potentialIssues.length}</p>
                                </div>
                              </div>
                              {analysis.findings.potentialIssues.length > 0 && (
                                <div style={{
                                  marginTop: '12px',
                                  padding: '12px',
                                  backgroundColor: '#fef2f2',
                                  borderRadius: '4px',
                                  borderLeft: '4px solid #dc2626'
                                }}>
                                  <strong style={{ color: '#7f1d1d' }}>Issues Identified:</strong>
                                  <ul style={{
                                    marginTop: '8px',
                                    fontSize: '14px',
                                    color: '#991b1b',
                                    paddingLeft: '20px'
                                  }}>
                                    {analysis.findings.potentialIssues.map((issue, i) => (
                                      <li key={i} style={{ marginBottom: '4px' }}>
                                        [{issue.severity.toUpperCase()}] {issue.type}: {issue.description}
                                      </li>
                                    ))}
                                  </ul>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>

                        <div style={{ marginTop: '24px' }}>
                          <h4 style={{
                            fontWeight: '600',
                            fontSize: '18px',
                            marginBottom: '12px'
                          }}>Document B Analysis</h4>
                          {analysisResults.phaseA.fileB.map((analysis, idx) => (
                            <div key={idx} style={{
                              backgroundColor: '#f9fafb',
                              padding: '16px',
                              borderRadius: '8px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#1e40af',
                                marginBottom: '8px'
                              }}>{analysis.preset}</h5>
                              <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                                gap: '16px',
                                fontSize: '14px'
                              }}>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Word Count:</strong> {analysis.findings.wordCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Line Count:</strong> {analysis.findings.lineCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Key Terms:</strong> {analysis.findings.keyTermsIdentified.length}</p>
                                </div>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Legal References:</strong> {analysis.findings.legalReferences.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Procedural Elements:</strong> {analysis.findings.proceduralElements.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Potential Issues:</strong> {analysis.findings.potentialIssues.length}</p>
                                </div>
                              </div>
                              {analysis.findings.potentialIssues.length > 0 && (
                                <div style={{
                                  marginTop: '12px',
                                  padding: '12px',
                                  backgroundColor: '#fef2f2',
                                  borderRadius: '4px',
                                  borderLeft: '4px solid #dc2626'
                                }}>
                                  <strong style={{ color: '#7f1d1d' }}>Issues Identified:</strong>
                                  <ul style={{
                                    marginTop: '8px',
                                    fontSize: '14px',
                                    color: '#991b1b',
                                    paddingLeft: '20px'
                                  }}>
                                    {analysis.findings.potentialIssues.map((issue, i) => (
                                      <li key={i} style={{ marginBottom: '4px' }}>
                                        [{issue.severity.toUpperCase()}] {issue.type}: {issue.description}
                                      </li>
                                    ))}
                                  </ul>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    </AnalysisSection>

                    <AnalysisSection title="Phase B: Victorian Criminal Compliance & Statutory Cross-Reference Analysis" sectionId="phaseB">
                      <div style={{ marginTop: '16px' }}>
                        <div style={{
                          backgroundColor: '#eff6ff',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#1e40af',
                            marginBottom: '12px'
                          }}>Governing Statutory Framework</h4>
                          {analysisResults.phaseB.governingFramework.length > 0 ? (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                              {analysisResults.phaseB.governingFramework.map((framework, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: 'white',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  fontSize: '14px'
                                }}>
                                  <p style={{
                                    fontWeight: '500',
                                    color: '#111827'
                                  }}>{framework.statute}</p>
                                  <p style={{ color: '#6b7280' }}>
                                    Source: {framework.source} | {framework.applicability}
                                  </p>
                                </div>
                              ))}
                            </div>
                          ) : (
                            <p style={{ fontSize: '14px', color: '#6b7280' }}>
                              No explicit statutory framework identified in documents
                            </p>
                          )}
                        </div>

                        {analysisResults.phaseB.discrepancies.length > 0 && (
                          <div style={{
                            backgroundColor: '#fef2f2',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #dc2626',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#7f1d1d',
                              marginBottom: '12px'
                            }}>Discrepancies Identified</h4>
                            <ul style={{ paddingLeft: '20px' }}>
                              {analysisResults.phaseB.discrepancies.map((disc, idx) => (
                                <li key={idx} style={{
                                  fontSize: '14px',
                                  color: '#991b1b',
                                  marginBottom: '8px'
                                }}>
                                  <strong>[{disc.severity?.toUpperCase()}]</strong> {disc.type}: {disc.description}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        {analysisResults.phaseB.omissions.length > 0 && (
                          <div style={{
                            backgroundColor: '#fef3c7',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #f59e0b',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#78350f',
                              marginBottom: '12px'
                            }}>Omissions Detected</h4>
                            <ul style={{ paddingLeft: '20px' }}>
                              {analysisResults.phaseB.omissions.slice(0, 10).map((omission, idx) => (
                                <li key={idx} style={{
                                  fontSize: '14px',
                                  color: '#92400e',
                                  marginBottom: '8px'
                                }}>
                                  {omission.type}: <strong>{omission.element}</strong> - {omission.status}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        {analysisResults.phaseB.consistencies.length > 0 && (
                          <div style={{
                            backgroundColor: '#f0fdf4',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #16a34a',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#14532d',
                              marginBottom: '12px'
                            }}>Consistencies Confirmed</h4>
                            <ul style={{ paddingLeft: '20px' }}>
                              {analysisResults.phaseB.consistencies.map((cons, idx) => (
                                <li key={idx} style={{
                                  fontSize: '14px',
                                  color: '#166534',
                                  marginBottom: '8px'
                                }}>
                                  {cons.type}: <strong>{cons.element}</strong> - {cons.status}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        {/* Victorian Criminal Summary Matters Compliance */}
                        {analysisResults.phaseB.victorianCompliance && (
                          <div style={{
                            backgroundColor: '#f5f3ff',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #7c3aed',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#5b21b6',
                              marginBottom: '12px'
                            }}>Victorian Criminal Summary Matters Compliance</h4>
                            <p style={{
                              fontSize: '13px',
                              color: '#6b21a8',
                              marginBottom: '16px',
                              fontStyle: 'italic'
                            }}>
                              Comprehensive checks for CPA 2009 Part 3.3, RSA 1986, and Evidence Act 2008 (Vic)
                            </p>

                            {/* Document A Compliance */}
                            <div style={{ marginBottom: '16px' }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#1e40af',
                                fontSize: '14px',
                                marginBottom: '8px'
                              }}>Document A Compliance Issues</h5>
                              {analysisResults.phaseB.victorianCompliance.fileA.length > 0 ? (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                  {analysisResults.phaseB.victorianCompliance.fileA.map((issue, idx) => (
                                    <div key={idx} style={{
                                      backgroundColor: 'white',
                                      padding: '12px',
                                      borderRadius: '4px',
                                      borderLeft: `4px solid ${
                                        issue.severity === 'critical' ? '#dc2626' :
                                        issue.severity === 'high' ? '#ea580c' :
                                        issue.severity === 'medium' ? '#f59e0b' : '#84cc16'
                                      }`
                                    }}>
                                      <p style={{
                                        fontSize: '13px',
                                        fontWeight: '600',
                                        color: issue.severity === 'critical' ? '#7f1d1d' :
                                               issue.severity === 'high' ? '#9a3412' :
                                               issue.severity === 'medium' ? '#78350f' : '#365314',
                                        marginBottom: '4px'
                                      }}>
                                        [{issue.severity.toUpperCase()}] {issue.statute}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                                        <strong>Section:</strong> {issue.section}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}>
                                        <strong>Defect:</strong> {issue.defect}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#4b5563' }}>
                                        <strong>Remediation:</strong> {issue.remediation}
                                      </p>
                                    </div>
                                  ))}
                                </div>
                              ) : (
                                <p style={{ fontSize: '13px', color: '#10b981' }}>
                                  ‚úÖ No compliance issues detected in Document A
                                </p>
                              )}
                            </div>

                            {/* Document B Compliance */}
                            <div>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#1e40af',
                                fontSize: '14px',
                                marginBottom: '8px'
                              }}>Document B Compliance Issues</h5>
                              {analysisResults.phaseB.victorianCompliance.fileB.length > 0 ? (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                  {analysisResults.phaseB.victorianCompliance.fileB.map((issue, idx) => (
                                    <div key={idx} style={{
                                      backgroundColor: 'white',
                                      padding: '12px',
                                      borderRadius: '4px',
                                      borderLeft: `4px solid ${
                                        issue.severity === 'critical' ? '#dc2626' :
                                        issue.severity === 'high' ? '#ea580c' :
                                        issue.severity === 'medium' ? '#f59e0b' : '#84cc16'
                                      }`
                                    }}>
                                      <p style={{
                                        fontSize: '13px',
                                        fontWeight: '600',
                                        color: issue.severity === 'critical' ? '#7f1d1d' :
                                               issue.severity === 'high' ? '#9a3412' :
                                               issue.severity === 'medium' ? '#78350f' : '#365314',
                                        marginBottom: '4px'
                                      }}>
                                        [{issue.severity.toUpperCase()}] {issue.statute}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                                        <strong>Section:</strong> {issue.section}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}>
                                        <strong>Defect:</strong> {issue.defect}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#4b5563' }}>
                                        <strong>Remediation:</strong> {issue.remediation}
                                      </p>
                                    </div>
                                  ))}
                                </div>
                              ) : (
                                <p style={{ fontSize: '13px', color: '#10b981' }}>
                                  ‚úÖ No compliance issues detected in Document B
                                </p>
                              )}
                            </div>
                          </div>
                        )}

                        {/* Enhanced Omissions Report */}
                        {analysisResults.phaseB.omissionsReport && (
                          <div style={{
                            backgroundColor: '#fff7ed',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #ea580c',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#9a3412',
                              marginBottom: '12px'
                            }}>Comprehensive Omissions Report: Doc A vs Doc B</h4>

                            {/* Critical Victorian Criminal Requirements Omissions */}
                            {analysisResults.phaseB.omissionsReport.criticalOmissions.victorianCriminalRequirements.length > 0 && (
                              <div style={{ marginBottom: '16px' }}>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#dc2626',
                                  fontSize: '14px',
                                  marginBottom: '8px'
                                }}>üî¥ CRITICAL: Victorian Criminal Requirements</h5>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                  {analysisResults.phaseB.omissionsReport.criticalOmissions.victorianCriminalRequirements.map((omission, idx) => (
                                    <div key={idx} style={{
                                      backgroundColor: 'white',
                                      padding: '12px',
                                      borderRadius: '4px',
                                      borderLeft: '4px solid #dc2626'
                                    }}>
                                      <p style={{ fontSize: '13px', fontWeight: '600', color: '#7f1d1d', marginBottom: '4px' }}>
                                        {omission.element}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                                        <strong>Statute:</strong> {omission.statute}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}>
                                        <strong>Present in:</strong> {omission.inDocument} | <strong>Omitted from:</strong> {omission.omittedFrom}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#991b1b' }}>
                                        <strong>Impact:</strong> {omission.impact}
                                      </p>
                                    </div>
                                  ))}
                                </div>
                              </div>
                            )}

                            {/* Statutory References Omissions */}
                            {(analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.length > 0 ||
                              analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.length > 0) && (
                              <div style={{ marginBottom: '16px' }}>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#ea580c',
                                  fontSize: '14px',
                                  marginBottom: '8px'
                                }}>üìã Statutory References</h5>

                                {analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.length > 0 && (
                                  <div style={{ marginBottom: '8px' }}>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc A but not Doc B:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.map((ref, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {ref.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}

                                {analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.length > 0 && (
                                  <div>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc B but not Doc A:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.map((ref, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {ref.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                              </div>
                            )}

                            {/* Procedural Elements Omissions */}
                            {(analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.length > 0 ||
                              analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.length > 0) && (
                              <div>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#ea580c',
                                  fontSize: '14px',
                                  marginBottom: '8px'
                                }}>‚öñÔ∏è Procedural Elements</h5>

                                {analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.length > 0 && (
                                  <div style={{ marginBottom: '8px' }}>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc A but not Doc B:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.map((elem, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {elem.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}

                                {analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.length > 0 && (
                                  <div>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc B but not Doc A:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.map((elem, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {elem.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                        )}

                        {/* Compliance Matrix Table */}
                        {analysisResults.phaseB.complianceMatrix && analysisResults.phaseB.complianceMatrix.length > 0 && (
                          <div style={{
                            backgroundColor: 'white',
                            padding: '16px',
                            borderRadius: '8px',
                            boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#111827',
                              marginBottom: '12px'
                            }}>üìä Statutory Compliance Matrix: Doc A vs Doc B</h4>
                            <p style={{
                              fontSize: '13px',
                              color: '#6b7280',
                              marginBottom: '12px'
                            }}>
                              <span style={{
                                display: 'inline-block',
                                padding: '2px 8px',
                                borderRadius: '4px',
                                backgroundColor: '#d1fae5',
                                color: '#065f46',
                                marginRight: '8px',
                                fontSize: '11px'
                              }}>GREEN = Compliant</span>
                              <span style={{
                                display: 'inline-block',
                                padding: '2px 8px',
                                borderRadius: '4px',
                                backgroundColor: '#fef3c7',
                                color: '#78350f',
                                marginRight: '8px',
                                fontSize: '11px'
                              }}>YELLOW = Unclear</span>
                              <span style={{
                                display: 'inline-block',
                                padding: '2px 8px',
                                borderRadius: '4px',
                                backgroundColor: '#fee2e2',
                                color: '#991b1b',
                                fontSize: '11px'
                              }}>RED = Non-Compliant</span>
                            </p>

                            <div style={{ overflowX: 'auto' }}>
                              <table style={{
                                width: '100%',
                                borderCollapse: 'collapse',
                                fontSize: '13px'
                              }}>
                                <thead>
                                  <tr style={{ backgroundColor: '#f3f4f6', borderBottom: '2px solid #e5e7eb' }}>
                                    <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}>
                                      Statutory Provision
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600' }}>
                                      Doc A Compliance
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600' }}>
                                      Doc B Compliance
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}>
                                      Discrepancies
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}>
                                      Action Required
                                    </th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {analysisResults.phaseB.complianceMatrix.map((row, idx) => (
                                    <tr key={idx} style={{ borderBottom: '1px solid #e5e7eb' }}>
                                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                                        <strong>{row.statute}</strong>
                                        <br />
                                        <span style={{ fontSize: '11px', color: '#6b7280' }}>
                                          {row.section}
                                        </span>
                                      </td>
                                      <td style={{ padding: '12px', textAlign: 'center', verticalAlign: 'top' }}>
                                        <span style={{
                                          display: 'inline-block',
                                          padding: '4px 12px',
                                          borderRadius: '12px',
                                          fontSize: '11px',
                                          fontWeight: '600',
                                          backgroundColor: row.docACompliance === 'compliant' ? '#d1fae5' :
                                                          row.docACompliance === 'unclear' ? '#fef3c7' : '#fee2e2',
                                          color: row.docACompliance === 'compliant' ? '#065f46' :
                                                 row.docACompliance === 'unclear' ? '#78350f' : '#991b1b'
                                        }}>
                                          {row.docACompliance === 'compliant' ? '‚úÖ Compliant' :
                                           row.docACompliance === 'unclear' ? '‚ö†Ô∏è Unclear' : '‚ùå Non-Compliant'}
                                        </span>
                                      </td>
                                      <td style={{ padding: '12px', textAlign: 'center', verticalAlign: 'top' }}>
                                        <span style={{
                                          display: 'inline-block',
                                          padding: '4px 12px',
                                          borderRadius: '12px',
                                          fontSize: '11px',
                                          fontWeight: '600',
                                          backgroundColor: row.docBCompliance === 'compliant' ? '#d1fae5' :
                                                          row.docBCompliance === 'unclear' ? '#fef3c7' : '#fee2e2',
                                          color: row.docBCompliance === 'compliant' ? '#065f46' :
                                                 row.docBCompliance === 'unclear' ? '#78350f' : '#991b1b'
                                        }}>
                                          {row.docBCompliance === 'compliant' ? '‚úÖ Compliant' :
                                           row.docBCompliance === 'unclear' ? '‚ö†Ô∏è Unclear' : '‚ùå Non-Compliant'}
                                        </span>
                                      </td>
                                      <td style={{ padding: '12px', verticalAlign: 'top', fontSize: '12px', color: '#374151' }}>
                                        {row.discrepancies.length > 0 ? (
                                          row.discrepancies.map((disc, dIdx) => (
                                            <div key={dIdx} style={{ marginBottom: '4px' }}>
                                              ‚ö†Ô∏è {disc}
                                            </div>
                                          ))
                                        ) : (
                                          <span style={{ color: '#6b7280' }}>No discrepancies</span>
                                        )}
                                      </td>
                                      <td style={{ padding: '12px', verticalAlign: 'top', fontSize: '12px' }}>
                                        <span style={{
                                          color: row.actionRequired.includes('URGENT') ? '#991b1b' :
                                                 row.actionRequired.includes('Review') ? '#92400e' : '#166534'
                                        }}>
                                          {row.actionRequired}
                                        </span>
                                      </td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        )}
                      </div>
                    </AnalysisSection>

                    <AnalysisSection title="üîó Cross-Reference Matrix" sectionId="crossReference">
                      <CrossReferenceMatrix analysis={analysisResults} />
                    </AnalysisSection>

                    <AnalysisSection title="Phase C: Statutory Interpretation & Legislative Purpose" sectionId="phaseC">
                      <div style={{ marginTop: '16px' }}>
                        <div style={{
                          backgroundColor: '#f9fafb',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#111827',
                            marginBottom: '12px'
                          }}>Interpretive Approaches Applied</h4>
                          
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                            <div style={{
                              backgroundColor: 'white',
                              padding: '16px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #2563eb'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#1e40af',
                                marginBottom: '8px'
                              }}>{analysisResults.phaseC.literalInterpretation.approach}</h5>
                              <p style={{
                                fontSize: '14px',
                                color: '#374151'
                              }}>{analysisResults.phaseC.literalInterpretation.findings}</p>
                            </div>

                            <div style={{
                              backgroundColor: 'white',
                              padding: '16px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #7c3aed'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#5b21b6',
                                marginBottom: '8px'
                              }}>{analysisResults.phaseC.contextualInterpretation.approach}</h5>
                              <p style={{
                                fontSize: '14px',
                                color: '#374151'
                              }}>{analysisResults.phaseC.contextualInterpretation.findings}</p>
                            </div>

                            <div style={{
                              backgroundColor: 'white',
                              padding: '16px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #16a34a'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#14532d',
                                marginBottom: '8px'
                              }}>{analysisResults.phaseC.purposiveInterpretation.approach}</h5>
                              <p style={{
                                fontSize: '14px',
                                color: '#374151'
                              }}>{analysisResults.phaseC.purposiveInterpretation.findings}</p>
                            </div>

                            <div style={{
                              backgroundColor: 'white',
                              padding: '16px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #f59e0b'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#78350f',
                                marginBottom: '8px'
                              }}>{analysisResults.phaseC.harmonization.approach}</h5>
                              <p style={{
                                fontSize: '14px',
                                color: '#374151'
                              }}>{analysisResults.phaseC.harmonization.findings}</p>
                            </div>
                          </div>
                        </div>

                        <div style={{
                          backgroundColor: '#eff6ff',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#1e40af',
                            marginBottom: '12px'
                          }}>Interpretive Principles Applied</h4>
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                            {analysisResults.phaseC.interpretativePrinciples.map((principle, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '12px',
                                borderRadius: '4px',
                                fontSize: '14px'
                              }}>
                                <p style={{
                                  fontWeight: '500',
                                  color: '#111827'
                                }}>{principle.principle}</p>
                                <p style={{
                                  color: '#6b7280',
                                  marginTop: '4px'
                                }}>{principle.application}</p>
                              </div>
                            ))}
                          </div>
                        </div>

                        <div style={{
                          backgroundColor: '#f5f3ff',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#5b21b6',
                            marginBottom: '12px'
                          }}>Extrinsic Aids Available</h4>
                          <p style={{
                            fontSize: '14px',
                            color: '#6b21a8',
                            marginBottom: '8px'
                          }}>{analysisResults.phaseC.extrinsicAids.application}</p>
                          <ul style={{
                            fontSize: '14px',
                            color: '#6b21a8',
                            paddingLeft: '20px'
                          }}>
                            {analysisResults.phaseC.extrinsicAids.availableAids.map((aid, idx) => (
                              <li key={idx} style={{ marginBottom: '4px' }}>{aid}</li>
                            ))}
                          </ul>
                        </div>

                        <div style={{
                          backgroundColor: '#f9fafb',
                          padding: '16px',
                          borderRadius: '8px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#111827',
                            marginBottom: '12px'
                          }}>Ambiguity Resolution</h4>
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                            {analysisResults.phaseC.resolutionOfAmbiguity.map((resolution, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '12px',
                                borderRadius: '4px',
                                fontSize: '14px',
                                borderLeft: '4px solid #9ca3af'
                              }}>
                                <p style={{
                                  fontWeight: '500',
                                  color: '#111827',
                                  marginBottom: '4px'
                                }}>Ambiguity: {resolution.ambiguity}</p>
                                <p style={{
                                  color: '#374151',
                                  marginBottom: '4px'
                                }}><strong>Method:</strong> {resolution.resolutionMethod}</p>
                                <p style={{ color: '#374151' }}>
                                  <strong>Recommendation:</strong> {resolution.recommendation}
                                </p>
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </AnalysisSection>

                    <AnalysisSection title="Recommendations & Next Steps" sectionId="recommendations">
                      <div style={{ marginTop: '16px' }}>
                        <div style={{
                          backgroundColor: '#eff6ff',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#1e40af',
                            marginBottom: '12px'
                          }}>Strategic Recommendations</h4>
                          <ul style={{
                            fontSize: '14px',
                            color: '#1e40af',
                            paddingLeft: '20px'
                          }}>
                            {analysisResults.summary.recommendations.map((rec, idx) => (
                              <li key={idx} style={{ marginBottom: '8px' }}>{rec}</li>
                            ))}
                          </ul>
                        </div>

                        <div style={{
                          backgroundColor: '#f0fdf4',
                          padding: '16px',
                          borderRadius: '8px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#14532d',
                            marginBottom: '12px'
                          }}>Proposed Next Steps</h4>
                          <ol style={{
                            fontSize: '14px',
                            color: '#166534',
                            paddingLeft: '20px'
                          }}>
                            {analysisResults.summary.nextSteps.map((step, idx) => (
                              <li key={idx} style={{ marginBottom: '8px' }}>{step}</li>
                            ))}
                          </ol>
                        </div>
                      </div>
                    </AnalysisSection>

                    {/* Learning Insights Panel */}
                    {contextualInsights?.learningInsights && (
                      <div className="fade-in" style={{ marginBottom: '24px' }}>
                        <LearningInsightsPanel
                          insights={contextualInsights.learningInsights}
                          currentDefects={contextualInsights.crossIntelligence}
                        />
                      </div>
                    )}

                    {/* Cross-Analysis Intelligence */}
                    {contextualInsights?.crossIntelligence && contextualInsights.crossIntelligence.length > 0 && (
                      <div className="fade-in" style={{ marginBottom: '24px' }}>
                        <CrossAnalysisIntelligence intelligence={contextualInsights.crossIntelligence} />
                      </div>
                    )}

                    {historicalAnalyses.length > 0 && (
                      <AnalysisSection title="üìä Defect Evolution Timeline" sectionId="timeline">
                        <DefectTimeline analyses={historicalAnalyses} />
                      </AnalysisSection>
                    )}

                    {detectedPatterns && detectedPatterns.recurring.length > 0 && (
                      <AnalysisSection title="üîç Pattern Recognition Analysis" sectionId="patterns">
                        <div style={{ marginTop: '16px' }}>
                          <div style={{
                            backgroundColor: '#fef2f2',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #dc2626',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#7f1d1d',
                              marginBottom: '12px'
                            }}>Recurring Issues Detected</h4>
                            <p style={{
                              fontSize: '14px',
                              color: '#991b1b',
                              marginBottom: '12px'
                            }}>
                              The following issues have occurred multiple times across your analyses, indicating systematic problems that require attention:
                            </p>

                            {detectedPatterns.recurring.map((pattern, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '16px',
                                borderRadius: '8px',
                                marginBottom: '12px',
                                border: '1px solid #fecaca'
                              }}>
                                <div style={{
                                  display: 'flex',
                                  justifyContent: 'space-between',
                                  alignItems: 'start',
                                  marginBottom: '8px'
                                }}>
                                  <h5 style={{
                                    fontWeight: '600',
                                    color: '#991b1b',
                                    fontSize: '16px'
                                  }}>{pattern.type}</h5>
                                  <span style={{
                                    backgroundColor: '#dc2626',
                                    color: 'white',
                                    padding: '4px 12px',
                                    borderRadius: '12px',
                                    fontSize: '12px',
                                    fontWeight: '600'
                                  }}>
                                    {pattern.frequency}x
                                  </span>
                                </div>

                                <p style={{
                                  fontSize: '14px',
                                  color: '#6b7280',
                                  marginBottom: '8px'
                                }}>
                                  {pattern.description}
                                </p>

                                <div style={{
                                  display: 'flex',
                                  gap: '16px',
                                  fontSize: '12px',
                                  color: '#6b7280',
                                  marginBottom: '12px'
                                }}>
                                  <div>
                                    <strong>First Seen:</strong> {new Date(pattern.firstSeen).toLocaleDateString()}
                                  </div>
                                  <div>
                                    <strong>Last Seen:</strong> {new Date(pattern.lastSeen).toLocaleDateString()}
                                  </div>
                                </div>

                                <div style={{
                                  backgroundColor: '#fffbeb',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  borderLeft: '4px solid #f59e0b'
                                }}>
                                  <strong style={{ color: '#78350f', fontSize: '13px' }}>üí° Recommendation:</strong>
                                  <p style={{
                                    fontSize: '13px',
                                    color: '#92400e',
                                    marginTop: '4px'
                                  }}>
                                    {pattern.recommendation}
                                  </p>
                                </div>
                              </div>
                            ))}
                          </div>

                          {detectedPatterns.recurring.length === 0 && (
                            <div style={{
                              backgroundColor: '#f0fdf4',
                              padding: '16px',
                              borderRadius: '8px',
                              borderLeft: '4px solid #16a34a'
                            }}>
                              <p style={{
                                fontSize: '14px',
                                color: '#166534'
                              }}>
                                ‚úÖ No recurring patterns detected. Continue monitoring future analyses for emerging trends.
                              </p>
                            </div>
                          )}
                        </div>
                      </AnalysisSection>
                    )}

                    {contextualInsights && (
                      <AnalysisSection title="üß† Contextual Intelligence & Trend Analysis" sectionId="contextual">
                        <div style={{ marginTop: '16px' }}>
                          {/* Severity Comparison */}
                          <div style={{
                            backgroundColor: contextualInsights.severity.status === 'worse' ? '#fef2f2' :
                                           contextualInsights.severity.status === 'better' ? '#f0fdf4' : '#eff6ff',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: `4px solid ${
                              contextualInsights.severity.status === 'worse' ? '#dc2626' :
                              contextualInsights.severity.status === 'better' ? '#16a34a' : '#2563eb'
                            }`,
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: contextualInsights.severity.status === 'worse' ? '#7f1d1d' :
                                     contextualInsights.severity.status === 'better' ? '#14532d' : '#1e40af',
                              marginBottom: '12px'
                            }}>üìä Severity Comparison</h4>
                            <p style={{
                              fontSize: '14px',
                              color: contextualInsights.severity.status === 'worse' ? '#991b1b' :
                                     contextualInsights.severity.status === 'better' ? '#166534' : '#1e40af',
                              marginBottom: '8px'
                            }}>
                              {contextualInsights.severity.message}
                            </p>
                            {contextualInsights.severity.data && (
                              <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '8px' }}>
                                Current: {contextualInsights.severity.data.current} | Historical Average: {contextualInsights.severity.data.average}
                              </div>
                            )}
                          </div>

                          {/* Trend Analysis */}
                          <div style={{
                            backgroundColor: contextualInsights.trend.direction === 'worsening' ? '#fef2f2' :
                                           contextualInsights.trend.direction === 'improving' ? '#f0fdf4' : '#eff6ff',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: `4px solid ${
                              contextualInsights.trend.direction === 'worsening' ? '#dc2626' :
                              contextualInsights.trend.direction === 'improving' ? '#16a34a' : '#2563eb'
                            }`,
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: contextualInsights.trend.direction === 'worsening' ? '#7f1d1d' :
                                     contextualInsights.trend.direction === 'improving' ? '#14532d' : '#1e40af',
                              marginBottom: '12px'
                            }}>üìà Trend Analysis</h4>
                            <p style={{
                              fontSize: '14px',
                              color: contextualInsights.trend.direction === 'worsening' ? '#991b1b' :
                                     contextualInsights.trend.direction === 'improving' ? '#166534' : '#1e40af'
                            }}>
                              {contextualInsights.trend.message}
                            </p>
                            {contextualInsights.trend.data && (
                              <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '8px' }}>
                                Based on {contextualInsights.trend.data.samples} recent analyses
                              </div>
                            )}
                          </div>

                          {/* Smart Recommendations */}
                          {contextualInsights.recommendations && contextualInsights.recommendations.length > 0 && (
                            <div style={{
                              backgroundColor: '#fffbeb',
                              padding: '16px',
                              borderRadius: '8px',
                              borderLeft: '4px solid #f59e0b',
                              marginBottom: '16px'
                            }}>
                              <h4 style={{
                                fontWeight: '600',
                                color: '#78350f',
                                marginBottom: '12px'
                              }}>üí° Smart Recommendations</h4>
                              <p style={{
                                fontSize: '13px',
                                color: '#92400e',
                                marginBottom: '12px'
                              }}>
                                Based on analysis of current and historical data, here are intelligent recommendations:
                              </p>
                              {contextualInsights.recommendations.map((rec, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: 'white',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  marginBottom: '8px',
                                  border: '1px solid #fde68a'
                                }}>
                                  <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'start',
                                    marginBottom: '8px'
                                  }}>
                                    <strong style={{
                                      fontSize: '14px',
                                      color: '#78350f'
                                    }}>{rec.category}</strong>
                                    <span style={{
                                      padding: '2px 8px',
                                      borderRadius: '8px',
                                      fontSize: '11px',
                                      fontWeight: '600',
                                      backgroundColor: rec.priority === 'high' ? '#fee2e2' :
                                                      rec.priority === 'medium' ? '#fef3c7' : '#dbeafe',
                                      color: rec.priority === 'high' ? '#991b1b' :
                                             rec.priority === 'medium' ? '#92400e' : '#1e40af'
                                    }}>
                                      {rec.priority.toUpperCase()}
                                    </span>
                                  </div>
                                  <p style={{
                                    fontSize: '13px',
                                    color: '#374151',
                                    marginBottom: '6px'
                                  }}>
                                    {rec.recommendation}
                                  </p>
                                  <p style={{
                                    fontSize: '12px',
                                    color: '#6b7280',
                                    fontStyle: 'italic'
                                  }}>
                                    Expected Impact: {rec.impact}
                                  </p>
                                </div>
                              ))}
                            </div>
                          )}

                          {/* Novel Issues */}
                          {contextualInsights.novelIssues && contextualInsights.novelIssues.length > 0 && (
                            <div style={{
                              backgroundColor: '#fef3c7',
                              padding: '16px',
                              borderRadius: '8px',
                              borderLeft: '4px solid #f59e0b'
                            }}>
                              <h4 style={{
                                fontWeight: '600',
                                color: '#78350f',
                                marginBottom: '12px'
                              }}>üÜï Novel Issues Detected</h4>
                              <p style={{
                                fontSize: '13px',
                                color: '#92400e',
                                marginBottom: '12px'
                              }}>
                                The following issue types have not been seen in previous analyses:
                              </p>
                              {contextualInsights.novelIssues.map((issue, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: 'white',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  marginBottom: '8px',
                                  border: '1px solid #fde68a'
                                }}>
                                  <div style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    marginBottom: '4px'
                                  }}>
                                    <span style={{
                                      padding: '2px 8px',
                                      borderRadius: '8px',
                                      fontSize: '11px',
                                      fontWeight: '600',
                                      backgroundColor: getColorForSeverity(issue.severity),
                                      border: '1px solid #e5e7eb'
                                    }}>
                                      {issue.severity.toUpperCase()}
                                    </span>
                                    <strong style={{ fontSize: '13px', color: '#111827' }}>
                                      {issue.type}
                                    </strong>
                                  </div>
                                  <p style={{ fontSize: '12px', color: '#6b7280' }}>
                                    {issue.description}
                                  </p>
                                  <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '4px' }}>
                                    Detected in: {issue.preset}
                                  </p>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      </AnalysisSection>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ForensicLegalAnalyzer />);
    </script>
</body>
</html>
