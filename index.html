<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forensic Legal Analyzer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- OCR and PDF Processing Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // Configure PDF.js worker
      if (typeof pdfjsLib !== 'undefined') {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
      }
    </script>
    <style>
        /* CSS Custom Properties for Theme System */
        :root {
            /* Color Palette */
            --color-primary: #2563eb;
            --color-primary-dark: #1d4ed8;
            --color-primary-light: #eff6ff;
            --color-secondary: #f59e0b;
            --color-secondary-light: #fef3c7;
            --color-success: #16a34a;
            --color-success-light: #dcfce7;
            --color-warning: #f59e0b;
            --color-warning-light: #fef3c7;
            --color-error: #dc2626;
            --color-error-light: #fee2e2;
            --color-info: #0284c7;
            --color-info-light: #e0f2fe;

            /* Neutral Colors */
            --color-gray-50: #f9fafb;
            --color-gray-100: #f3f4f6;
            --color-gray-200: #e5e7eb;
            --color-gray-300: #d1d5db;
            --color-gray-400: #9ca3af;
            --color-gray-500: #6b7280;
            --color-gray-600: #4b5563;
            --color-gray-700: #374151;
            --color-gray-800: #1f2937;
            --color-gray-900: #111827;

            /* Severity Colors */
            --color-critical: #fecaca;
            --color-critical-text: #991b1b;
            --color-high: #fcd34d;
            --color-high-text: #92400e;
            --color-medium: #a5f3fc;
            --color-medium-text: #0e7490;
            --color-low: #bbf7d0;
            --color-low-text: #166534;

            /* Spacing System */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-2xl: 48px;

            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            --radius-full: 9999px;

            /* Shadows */
            --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.15);

            /* Typography */
            --font-size-xs: 11px;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 24px;
            --font-size-3xl: 30px;
            --font-size-4xl: 36px;

            /* Transitions */
            --transition-fast: 150ms ease-in-out;
            --transition-base: 250ms ease-in-out;
            --transition-slow: 350ms ease-in-out;

            /* Z-index Scale */
            --z-dropdown: 1000;
            --z-modal: 2000;
            --z-tooltip: 3000;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-size: var(--font-size-base);
            color: var(--color-gray-900);
        }

        #root {
            width: 100%;
            min-height: 100vh;
        }

        /* Icon styles - using Unicode symbols instead of Lucide */
        .icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            vertical-align: middle;
        }

        /* Smooth Transitions */
        button, a, .card, .section {
            transition: all var(--transition-base);
        }

        /* Focus Styles for Accessibility */
        button:focus-visible,
        a:focus-visible,
        input:focus-visible {
            outline: 3px solid var(--color-primary);
            outline-offset: 2px;
        }

        /* Hover Effects */
        button:not(:disabled):hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
        }

        button:not(:disabled):active {
            transform: translateY(0);
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -1000px 0;
            }
            100% {
                background-position: 1000px 0;
            }
        }

        .fade-in {
            animation: fadeIn var(--transition-base);
        }

        .slide-in {
            animation: slideIn var(--transition-base);
        }

        .pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .spin {
            animation: spin 1s linear infinite;
        }

        /* Skeleton Loading States */
        .skeleton {
            background: linear-gradient(
                90deg,
                var(--color-gray-200) 0%,
                var(--color-gray-100) 50%,
                var(--color-gray-200) 100%
            );
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
            border-radius: var(--radius-md);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root {
                --font-size-3xl: 24px;
                --spacing-xl: 24px;
                --spacing-2xl: 32px;
            }

            body {
                font-size: var(--font-size-sm);
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white !important;
            }

            button, .no-print {
                display: none !important;
            }

            .card, .section {
                box-shadow: none !important;
                border: 1px solid var(--color-gray-300) !important;
                page-break-inside: avoid;
            }

            h1, h2, h3, h4, h5, h6 {
                page-break-after: avoid;
            }
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--color-gray-100);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--color-gray-400);
            border-radius: var(--radius-full);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--color-gray-500);
        }

        /* Utility Classes */
        .text-center {
            text-align: center;
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useRef } = React;

        // Simple icon components using Unicode symbols
        const Icon = ({ name, className = "", ...props }) => {
            const icons = {
                Upload: "‚¨ÜÔ∏è",
                FileText: "üìÑ",
                AlertCircle: "‚ö†Ô∏è",
                CheckCircle: "‚úÖ",
                Loader: "‚åõ",
                Download: "‚¨áÔ∏è",
                Eye: "üëÅÔ∏è",
                ChevronDown: "‚ñº",
                ChevronRight: "‚ñ∂"
            };
            
            return <span className={`icon ${className}`} {...props}>{icons[name] || "‚Ä¢"}</span>;
        };

        // Persistent Intelligence Layer - Storage Manager
        const AnalysisMemory = {
          storage: null,
          dbPromise: null,

          init() {
            if (this.dbPromise) return this.dbPromise;

            this.dbPromise = new Promise((resolve, reject) => {
              const request = window.indexedDB.open('ForensicAnalysisDB', 1);

              request.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('analyses')) {
                  db.createObjectStore('analyses', { keyPath: 'id', autoIncrement: true });
                }
                if (!db.objectStoreNames.contains('patterns')) {
                  db.createObjectStore('patterns', { keyPath: 'pattern' });
                }
              };

              request.onsuccess = (e) => {
                this.storage = e.target.result;
                resolve(this.storage);
              };

              request.onerror = (e) => {
                console.error('Failed to initialize IndexedDB:', e.target.error);
                reject(e.target.error);
              };
            });

            return this.dbPromise;
          },

          async getDB() {
            if (!this.storage) {
              await this.init();
            }
            return this.storage;
          },

          async saveAnalysis(results, files) {
            try {
              const db = await this.getDB();
              const analysis = {
                timestamp: new Date().toISOString(),
                fileAName: files.fileA?.name,
                fileBName: files.fileB?.name,
                findings: results,
                defects: this.extractDefects(results),
                crossReferences: this.buildCrossReferences(results)
              };

              const tx = db.transaction('analyses', 'readwrite');
              await tx.objectStore('analyses').add(analysis);

              // Learn patterns from this analysis
              await this.updatePatterns(analysis);

              console.log('Analysis saved to persistent storage');
            } catch (error) {
              console.error('Failed to save analysis:', error);
            }
          },

          extractDefects(results) {
            const defects = [];

            // Phase A defects
            ['fileA', 'fileB'].forEach(fileKey => {
              results.phaseA[fileKey].forEach(preset => {
                const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                if (Array.isArray(issues)) {
                  issues.forEach(issue => {
                    defects.push({
                      phase: 'A',
                      preset: preset.preset,
                      severity: issue.severity,
                      type: issue.type,
                      description: issue.description,
                      file: fileKey,
                      timestamp: new Date().toISOString()
                    });
                  });
                }
              });
            });

            // Phase B defects
            if (results.phaseB.discrepancies) {
              results.phaseB.discrepancies.forEach(disc => {
                defects.push({
                  phase: 'B',
                  type: 'discrepancy',
                  severity: disc.severity,
                  description: disc.description,
                  timestamp: new Date().toISOString()
                });
              });
            }

            if (results.phaseB.omissions) {
              results.phaseB.omissions.forEach(om => {
                defects.push({
                  phase: 'B',
                  type: 'omission',
                  element: om.element,
                  status: om.status,
                  timestamp: new Date().toISOString()
                });
              });
            }

            return defects;
          },

          buildCrossReferences(results) {
            const refs = {
              statutory: [],
              procedural: [],
              temporal: [],
              evidential: []
            };

            // Extract all statutory references
            ['fileA', 'fileB'].forEach(fileKey => {
              if (results.phaseA[fileKey][0]?.findings?.legalReferences) {
                results.phaseA[fileKey][0].findings.legalReferences.forEach(ref => {
                  refs.statutory.push({
                    text: ref.text,
                    type: ref.type,
                    source: fileKey,
                    relatedDefects: this.findRelatedDefects(ref.text, results)
                  });
                });
              }
            });

            return refs;
          },

          findRelatedDefects(reference, results) {
            const related = [];
            const refLower = reference.toLowerCase();

            ['fileA', 'fileB'].forEach(fileKey => {
              results.phaseA[fileKey].forEach(preset => {
                const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                if (Array.isArray(issues)) {
                  issues.forEach(issue => {
                    if (issue.description.toLowerCase().includes(refLower)) {
                      related.push({
                        preset: preset.preset,
                        type: issue.type,
                        severity: issue.severity
                      });
                    }
                  });
                }
              });
            });

            return related;
          },

          async updatePatterns(analysis) {
            try {
              const db = await this.getDB();
              // This could be expanded to learn common patterns in defects
              // For now, just log that pattern learning is available
              console.log('Pattern learning capability ready');
            } catch (error) {
              console.error('Failed to update patterns:', error);
            }
          },

          async getAllAnalyses() {
            try {
              const db = await this.getDB();
              const tx = db.transaction('analyses', 'readonly');
              const store = tx.objectStore('analyses');
              const request = store.getAll();

              return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
              });
            } catch (error) {
              console.error('Failed to retrieve analyses:', error);
              return [];
            }
          }
        };

        // Timeline Visualization Component
        const DefectTimeline = ({ analyses }) => {
          const [selectedDefect, setSelectedDefect] = useState(null);

          // Group defects by type across all analyses
          const defectEvolution = React.useMemo(() => {
            if (!analyses || analyses.length === 0) return {};

            return analyses.reduce((acc, analysis) => {
              if (analysis.defects) {
                analysis.defects.forEach(defect => {
                  const key = `${defect.type}-${defect.severity}`;
                  if (!acc[key]) acc[key] = [];
                  acc[key].push({
                    date: analysis.timestamp,
                    description: defect.description,
                    file: analysis.fileAName
                  });
                });
              }
              return acc;
            }, {});
          }, [analyses]);

          if (!analyses || analyses.length === 0) {
            return (
              <div style={{ padding: '20px', backgroundColor: '#f9fafb', textAlign: 'center' }}>
                <p style={{ color: '#6b7280' }}>No historical analysis data available yet. Complete analyses will appear here over time.</p>
              </div>
            );
          }

          return (
            <div style={{ padding: '20px', backgroundColor: '#f9fafb' }}>
              <h3>üìä Defect Evolution Timeline</h3>
              <p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '16px' }}>
                Showing patterns across {analyses.length} historical analysis sessions
              </p>

              {Object.entries(defectEvolution).map(([type, occurrences]) => (
                <div key={type} style={{
                  marginBottom: '20px',
                  padding: '15px',
                  backgroundColor: 'white',
                  borderRadius: '8px',
                  borderLeft: '4px solid #dc2626'
                }}>
                  <h4>{type.replace('-', ' - ').toUpperCase()}</h4>
                  <p style={{ fontSize: '12px', color: '#666' }}>
                    Occurred {occurrences.length} times
                  </p>

                  <div style={{ marginTop: '10px' }}>
                    {occurrences.map((occ, idx) => (
                      <div key={idx} style={{
                        padding: '8px',
                        marginBottom: '8px',
                        backgroundColor: '#fef2f2',
                        borderRadius: '4px',
                        fontSize: '13px'
                      }}>
                        <strong>{new Date(occ.date).toLocaleString()}</strong>
                        <br />
                        File: {occ.file}
                        <br />
                        {occ.description}
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          );
        };

        // Pattern Recognition Engine
        const PatternDetector = {
          async analyze(currentAnalysis, historicalAnalyses) {
            const patterns = {
              recurring: [],
              emerging: [],
              resolved: []
            };

            // Find recurring defects
            const defectCounts = {};
            historicalAnalyses.forEach(analysis => {
              if (analysis.defects) {
                analysis.defects.forEach(defect => {
                  const key = `${defect.type}|${defect.description}`;
                  defectCounts[key] = (defectCounts[key] || 0) + 1;
                });
              }
            });

            // Identify patterns
            Object.entries(defectCounts).forEach(([key, count]) => {
              if (count >= 3) {
                const [type, description] = key.split('|');
                patterns.recurring.push({
                  type,
                  description,
                  frequency: count,
                  firstSeen: this.findFirstOccurrence(type, description, historicalAnalyses),
                  lastSeen: this.findLastOccurrence(type, description, historicalAnalyses),
                  recommendation: this.generateRecommendation(type, description, count)
                });
              }
            });

            return patterns;
          },

          findFirstOccurrence(type, description, analyses) {
            for (let analysis of analyses) {
              if (analysis.defects) {
                const found = analysis.defects.find(d => d.type === type && d.description === description);
                if (found) return analysis.timestamp;
              }
            }
            return null;
          },

          findLastOccurrence(type, description, analyses) {
            for (let i = analyses.length - 1; i >= 0; i--) {
              if (analyses[i].defects) {
                const found = analyses[i].defects.find(d => d.type === type && d.description === description);
                if (found) return analyses[i].timestamp;
              }
            }
            return null;
          },

          generateRecommendation(type, description, frequency) {
            const recommendations = {
              'Missing Statutory Reference': `After ${frequency} occurrences, consider creating a checklist template that includes all required statutory references for this document type.`,
              'Mixed Mandatory/Discretionary Language': `This language ambiguity has appeared ${frequency} times. Recommend standardizing document language to use either "must/shall" OR "may" consistently, with clear section separation.`,
              'Insufficient Detail': `Documents consistently lack detail. Create minimum content guidelines specifying required sections and minimum line/word counts.`,
              'Acknowledged Defect': `Errors acknowledged ${frequency} times suggests a review process gap. Implement mandatory peer review before document finalization.`,
              'Missing Primary Legislation': `After ${frequency} occurrences, consider creating a checklist template that includes all required statutory references for this document type.`,
              'Insufficient Substantive Content': `Documents consistently lack detail. Create minimum content guidelines specifying required sections and minimum line/word counts.`
            };

            return recommendations[type] || `Recurring issue (${frequency}x). Systematic review and process improvement recommended.`;
          }
        };

        // Helper function: Get color for severity
        const getColorForSeverity = (severity) => {
          const colors = {
            'critical': '#fecaca',
            'high': '#fed7aa',
            'medium': '#fef3c7',
            'low': '#dbeafe'
          };
          return colors[severity] || '#f3f4f6';
        };

        // Helper function: Find defects related to a reference
        const findDefectsForReference = (reference, analysis) => {
          const related = [];
          const refLower = reference.toLowerCase();

          ['fileA', 'fileB'].forEach(fileKey => {
            if (analysis.phaseA && analysis.phaseA[fileKey]) {
              analysis.phaseA[fileKey].forEach(preset => {
                const potentialIssues = preset.findings.potentialIssues;
                const issues = potentialIssues.issues || potentialIssues;

                if (Array.isArray(issues)) {
                  issues.forEach(issue => {
                    if (issue.description && issue.description.toLowerCase().includes(refLower)) {
                      related.push({
                        type: issue.type,
                        severity: issue.severity,
                        description: issue.description
                      });
                    }
                  });
                }
              });
            }
          });

          return related;
        };

        // Helper function: Build matrix
        const buildMatrix = (analysis) => {
          const matrix = [];

          // Get all statutory references
          const refs = [];
          if (analysis.phaseA) {
            ['fileA', 'fileB'].forEach(fileKey => {
              if (analysis.phaseA[fileKey] && analysis.phaseA[fileKey][0] &&
                  analysis.phaseA[fileKey][0].findings &&
                  analysis.phaseA[fileKey][0].findings.legalReferences) {
                refs.push(...analysis.phaseA[fileKey][0].findings.legalReferences);
              }
            });
          }

          // Remove duplicates
          const uniqueRefs = [];
          const seen = new Set();
          refs.forEach(ref => {
            const key = `${ref.type}:${ref.text}`.toLowerCase();
            if (!seen.has(key)) {
              seen.add(key);
              uniqueRefs.push(ref);
            }
          });

          uniqueRefs.forEach(ref => {
            const relatedDefects = findDefectsForReference(ref.text, analysis);
            const highSeverity = relatedDefects.filter(d =>
              d.severity === 'high' || d.severity === 'critical'
            );
            const compliant = highSeverity.length === 0;

            matrix.push({
              statute: ref.text,
              section: ref.type,
              defects: relatedDefects.slice(0, 5), // Limit to 5 for display
              compliant: compliant,
              action: determineAction(relatedDefects, compliant)
            });
          });

          return matrix;
        };

        // Helper function: Determine action
        const determineAction = (defects, compliant) => {
          if (compliant) return 'No action required - monitoring';

          const highSeverity = defects.filter(d =>
            d.severity === 'high' || d.severity === 'critical'
          );
          if (highSeverity.length > 0) {
            return '‚ö†Ô∏è URGENT: Review and address high-severity issues immediately';
          }

          return 'üìã Review medium/low issues and plan remediation';
        };

        // Helper function: Detect patterns from historical data
        const detectPatterns = (historicalAnalyses) => {
          if (!historicalAnalyses || historicalAnalyses.length === 0) return [];

          const patternCounts = {};

          historicalAnalyses.forEach(analysis => {
            if (analysis.defects) {
              analysis.defects.forEach(defect => {
                const key = `${defect.type}|${defect.severity}`;
                if (!patternCounts[key]) {
                  patternCounts[key] = {
                    type: defect.type,
                    severity: defect.severity,
                    count: 0,
                    descriptions: []
                  };
                }
                patternCounts[key].count++;
                if (patternCounts[key].descriptions.length < 3) {
                  patternCounts[key].descriptions.push(defect.description);
                }
              });
            }
          });

          return Object.values(patternCounts).filter(p => p.count >= 2);
        };

        // Cross-Reference Matrix Component
        const CrossReferenceMatrix = ({ analysis }) => {
          const matrix = React.useMemo(() => buildMatrix(analysis), [analysis]);

          if (!matrix || matrix.length === 0) {
            return (
              <div style={{ padding: '20px', backgroundColor: '#f9fafb', textAlign: 'center' }}>
                <p style={{ color: '#6b7280' }}>No statutory references found to create cross-reference matrix.</p>
              </div>
            );
          }

          return (
            <div style={{ padding: '20px' }}>
              <h3>üîó Cross-Reference Matrix</h3>
              <p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '16px' }}>
                Relationships between statutory references and identified defects
              </p>

              <table style={{
                width: '100%',
                borderCollapse: 'collapse',
                backgroundColor: 'white',
                boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
                borderRadius: '8px',
                overflow: 'hidden'
              }}>
                <thead>
                  <tr style={{ backgroundColor: '#f3f4f6' }}>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Statutory Reference</th>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Related Defects</th>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Compliance Status</th>
                    <th style={{
                      padding: '12px',
                      textAlign: 'left',
                      borderBottom: '2px solid #e5e7eb',
                      fontWeight: '600',
                      fontSize: '14px'
                    }}>Action Required</th>
                  </tr>
                </thead>
                <tbody>
                  {matrix.map((row, idx) => (
                    <tr key={idx} style={{ borderBottom: '1px solid #e5e7eb' }}>
                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                        <strong style={{ fontSize: '14px' }}>{row.statute}</strong>
                        <br />
                        <span style={{ fontSize: '12px', color: '#666' }}>
                          {row.section}
                        </span>
                      </td>
                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                        {row.defects.length > 0 ? (
                          row.defects.map((d, i) => (
                            <div key={i} style={{
                              padding: '4px 8px',
                              marginBottom: '4px',
                              backgroundColor: getColorForSeverity(d.severity),
                              borderRadius: '4px',
                              fontSize: '12px',
                              border: '1px solid #e5e7eb'
                            }}>
                              <strong>[{d.severity.toUpperCase()}]</strong> {d.type}
                            </div>
                          ))
                        ) : (
                          <span style={{ fontSize: '12px', color: '#6b7280' }}>No related defects</span>
                        )}
                      </td>
                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                        <span style={{
                          padding: '4px 12px',
                          borderRadius: '12px',
                          fontSize: '12px',
                          fontWeight: '600',
                          backgroundColor: row.compliant ? '#d1fae5' : '#fee2e2',
                          color: row.compliant ? '#065f46' : '#991b1b'
                        }}>
                          {row.compliant ? '‚úÖ Compliant' : '‚ö†Ô∏è Non-Compliant'}
                        </span>
                      </td>
                      <td style={{ padding: '12px', fontSize: '13px', verticalAlign: 'top' }}>
                        {row.action}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          );
        };

        // Contextual Intelligence Enhancement
        const ContextualIntelligence = {
          async enhanceFindings(currentAnalysis, historicalAnalyses) {
            return {
              ...currentAnalysis,
              contextualInsights: {
                // Compare current to historical average
                severity: this.compareSeverity(currentAnalysis, historicalAnalyses),

                // Identify if issues are worsening or improving
                trend: this.analyzeTrend(currentAnalysis, historicalAnalyses),

                // Suggest specific actions based on patterns
                recommendations: this.generateSmartRecommendations(currentAnalysis, historicalAnalyses),

                // Highlight new issue types never seen before
                novelIssues: this.identifyNovelIssues(currentAnalysis, historicalAnalyses)
              }
            };
          },

          countSeverity(analysis, severity) {
            let count = 0;
            if (analysis.findings && analysis.findings.phaseA) {
              ['fileA', 'fileB'].forEach(fileKey => {
                if (analysis.findings.phaseA[fileKey]) {
                  analysis.findings.phaseA[fileKey].forEach(preset => {
                    const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                    if (Array.isArray(issues)) {
                      count += issues.filter(i => i.severity === severity).length;
                    }
                  });
                }
              });
            } else if (analysis.defects) {
              count = analysis.defects.filter(d => d.severity === severity).length;
            }
            return count;
          },

          compareSeverity(current, historical) {
            if (!historical || historical.length === 0) {
              return {
                status: 'baseline',
                message: 'This is your first analysis - establishing baseline metrics'
              };
            }

            const currentHigh = this.countSeverity({ findings: current }, 'high');
            const currentCritical = this.countSeverity({ findings: current }, 'critical');
            const currentTotal = currentHigh + currentCritical;

            const avgHigh = historical.reduce((sum, a) =>
              sum + this.countSeverity(a, 'high'), 0) / historical.length;
            const avgCritical = historical.reduce((sum, a) =>
              sum + this.countSeverity(a, 'critical'), 0) / historical.length;
            const avgTotal = avgHigh + avgCritical;

            if (avgTotal === 0) {
              return {
                status: 'baseline',
                message: 'Insufficient historical data for comparison'
              };
            }

            if (currentTotal > avgTotal * 1.5) {
              return {
                status: 'worse',
                message: `‚ö†Ô∏è Current analysis shows ${Math.round((currentTotal / avgTotal - 1) * 100)}% more high-severity issues than historical average`,
                data: { current: currentTotal, average: avgTotal.toFixed(1) }
              };
            } else if (currentTotal < avgTotal * 0.5 && avgTotal > 0) {
              return {
                status: 'better',
                message: `‚úÖ Significant improvement: ${Math.round((1 - currentTotal / avgTotal) * 100)}% fewer high-severity issues`,
                data: { current: currentTotal, average: avgTotal.toFixed(1) }
              };
            }

            return {
              status: 'stable',
              message: 'Issue severity within normal range',
              data: { current: currentTotal, average: avgTotal.toFixed(1) }
            };
          },

          analyzeTrend(current, historical) {
            if (!historical || historical.length < 2) {
              return {
                direction: 'insufficient_data',
                message: 'Need at least 2 historical analyses to detect trends'
              };
            }

            // Look at last 5 analyses
            const recent = historical.slice(-5);
            const counts = recent.map(a => this.countSeverity(a, 'high') + this.countSeverity(a, 'critical'));

            // Simple linear trend
            const trend = counts[counts.length - 1] - counts[0];

            if (trend > 2) {
              return {
                direction: 'worsening',
                message: 'üìà Issues increasing over recent analyses - systematic review recommended',
                data: { change: trend, samples: counts.length }
              };
            } else if (trend < -2) {
              return {
                direction: 'improving',
                message: 'üìâ Issues decreasing - current processes appear effective',
                data: { change: trend, samples: counts.length }
              };
            }

            return {
              direction: 'stable',
              message: 'No significant trend detected',
              data: { change: trend, samples: counts.length }
            };
          },

          generateSmartRecommendations(current, historical) {
            const recommendations = [];

            // Get current issues
            const currentIssues = [];
            if (current.phaseA) {
              ['fileA', 'fileB'].forEach(fileKey => {
                if (current.phaseA[fileKey]) {
                  current.phaseA[fileKey].forEach(preset => {
                    const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                    if (Array.isArray(issues)) {
                      currentIssues.push(...issues);
                    }
                  });
                }
              });
            }

            // Check for recurring high-severity issues
            const highSeverity = currentIssues.filter(i => i.severity === 'high' || i.severity === 'critical');
            if (highSeverity.length > 3) {
              recommendations.push({
                priority: 'high',
                category: 'Quality Control',
                recommendation: 'Multiple high-severity issues detected. Consider implementing a document review checklist before submission.',
                impact: 'Reduce critical defects by 40-60%'
              });
            }

            // Check for missing statutory references
            const missingRefs = currentIssues.filter(i =>
              i.type && (i.type.includes('Missing') || i.type.includes('Statute'))
            );
            if (missingRefs.length > 0) {
              recommendations.push({
                priority: 'medium',
                category: 'Statutory Compliance',
                recommendation: 'Create a statutory reference template for this document type to ensure all required references are included.',
                impact: 'Improve compliance by 30-50%'
              });
            }

            // Check for procedural issues
            const proceduralIssues = currentIssues.filter(i =>
              i.type && (i.type.includes('Procedural') || i.type.includes('Fairness'))
            );
            if (proceduralIssues.length > 0) {
              recommendations.push({
                priority: 'high',
                category: 'Procedural Compliance',
                recommendation: 'Review procedural requirements and implement mandatory peer review for procedural fairness.',
                impact: 'Reduce jurisdictional errors'
              });
            }

            if (recommendations.length === 0) {
              recommendations.push({
                priority: 'low',
                category: 'Monitoring',
                recommendation: 'Continue current document preparation processes - quality metrics are within acceptable range.',
                impact: 'Maintain current standards'
              });
            }

            return recommendations;
          },

          identifyNovelIssues(current, historical) {
            if (!historical || historical.length === 0) {
              return [];
            }

            // Get all historical issue types
            const historicalTypes = new Set();
            historical.forEach(analysis => {
              if (analysis.defects) {
                analysis.defects.forEach(defect => {
                  historicalTypes.add(defect.type);
                });
              }
            });

            // Find current issues that are new
            const novelIssues = [];
            if (current.phaseA) {
              ['fileA', 'fileB'].forEach(fileKey => {
                if (current.phaseA[fileKey]) {
                  current.phaseA[fileKey].forEach(preset => {
                    const issues = preset.findings.potentialIssues.issues || preset.findings.potentialIssues;
                    if (Array.isArray(issues)) {
                      issues.forEach(issue => {
                        if (!historicalTypes.has(issue.type)) {
                          novelIssues.push({
                            type: issue.type,
                            severity: issue.severity,
                            description: issue.description,
                            preset: preset.preset
                          });
                        }
                      });
                    }
                  });
                }
              });
            }

            return novelIssues;
          }
        };

        const ForensicLegalAnalyzer = () => {
          const [files, setFiles] = useState({ fileA: null, fileB: null });
          const [fileContents, setFileContents] = useState({ fileA: '', fileB: '' });
          const [analysisState, setAnalysisState] = useState('idle');
          const [currentPhase, setCurrentPhase] = useState('');
          const [analysisResults, setAnalysisResults] = useState(null);
          const [expandedSections, setExpandedSections] = useState({});
          const [historicalAnalyses, setHistoricalAnalyses] = useState([]);
          const [detectedPatterns, setDetectedPatterns] = useState(null);
          const [contextualInsights, setContextualInsights] = useState(null);
          const [uploadProgress, setUploadProgress] = useState({ fileA: 0, fileB: 0 });
          const [isUploading, setIsUploading] = useState({ fileA: false, fileB: false });
          const [analysisProgress, setAnalysisProgress] = useState(0);
          const fileInputA = useRef(null);
          const fileInputB = useRef(null);

          // Initialize persistent storage on component mount
          React.useEffect(() => {
            AnalysisMemory.init().then(() => {
              console.log('Persistent Intelligence Layer initialized');
              // Load historical analyses
              return AnalysisMemory.getAllAnalyses();
            }).then(analyses => {
              setHistoricalAnalyses(analyses || []);
              console.log(`Loaded ${analyses?.length || 0} historical analyses`);
            }).catch(err => {
              console.error('Failed to initialize storage:', err);
            });
          }, []);

          const interpretivePresets = [
            {
              name: 'Statutory Procedural Analysis',
              description: 'Examines compliance with statutory requirements, procedural mandates, and legislative frameworks',
              focus: ['compliance', 'procedure', 'statutory_requirements', 'jurisdictional_prerequisites']
            },
            {
              name: 'Contextual Analysis',
              description: 'Evaluates meaning within broader legislative, factual, and temporal context',
              focus: ['surrounding_circumstances', 'legislative_scheme', 'temporal_context', 'factual_matrix']
            },
            {
              name: 'Jurisprudential Analysis',
              description: 'Applies established legal principles, precedents, and interpretative doctrines',
              focus: ['precedent', 'common_law_principles', 'interpretative_doctrines', 'judicial_reasoning']
            },
            {
              name: 'Objective Textual Analysis',
              description: 'Focuses on plain meaning, literal interpretation, and grammatical construction',
              focus: ['plain_meaning', 'grammatical_analysis', 'ordinary_meaning', 'textual_structure']
            },
            {
              name: 'Subjective Intent Analysis',
              description: 'Considers apparent intentions, representations, and assertions within documents',
              focus: ['stated_intentions', 'apparent_purposes', 'declarations', 'subjective_assertions']
            },
            {
              name: 'Purposive Analysis',
              description: 'Examines legislative purpose, policy objectives, and intended outcomes',
              focus: ['legislative_purpose', 'policy_objectives', 'mischief_rule', 'intended_effect']
            },
            {
              name: 'Comparative Cross-Reference Analysis',
              description: 'Identifies inconsistencies, contradictions, and discrepancies between documents',
              focus: ['consistency', 'contradictions', 'omissions', 'discrepancies']
            },
            {
              name: 'Evidentiary Standards Analysis',
              description: 'Evaluates evidentiary sufficiency, admissibility, and probative value',
              focus: ['admissibility', 'relevance', 'probative_value', 'evidentiary_weight']
            }
          ];

          // Victorian Law Document Type Classifier
          const classifyDocumentType = (filename, content) => {
            const types = {
              'Statutory Legislation': /\bact\s+\d{4}\b|primary legislation|statute/i,
              'Delegated Legislation': /\bregulation|rules|order|instrument\b/i,
              'Victoria Police Manual': /\bvictoria police|vpm|police manual|operational procedure/i,
              'Disclosure Document': /\bdisclosure|discovery|prosecution brief/i,
              'Evidence Exhibit': /\bexhibit|evidentiary material|physical evidence/i,
              'Statement': /\bstatement of|witness statement|affidavit|statutory declaration/i,
              'Court Order': /\border of the court|court order|judicial order/i,
              'Evidentiary Certificate': /\bevidentiary certificate|certificate of|s\.\s*\d+\s+certificate/i,
              'Summons': /\bsummons|witness summons|subpoena/i,
              'Charge Sheet': /\bcharge sheet|charges|indictment|complaint/i,
              'Submission': /\bsubmission|written submission|legal submission/i,
              'Deposition': /\bdeposition|committal|preliminary hearing/i,
              'Case Law': /\b[A-Z][a-z]+\s+v\s+[A-Z][a-z]+|\[\d{4}\]|CLR|VR|VSC/,
              'Legal Narrative': /\bnarrativ|chronolog|fact pattern|sequence of events/i,
              'Court Documentation': /\bfiling|pleading|court document|notice of/i
            };

            for (const [type, pattern] of Object.entries(types)) {
              if (pattern.test(content) || pattern.test(filename)) {
                return type;
              }
            }
            return 'General Legal Document';
          };

          // Victorian Governing Framework Identifier
          const identifyVictorianFramework = (content, documentType) => {
            const framework = {
              primaryLegislation: [],
              subordinateInstrumentation: [],
              jurisdiction: 'Victoria, Australia',
              governingCourts: [],
              relevantPoliceProcedures: [],
              applicableEvidentRules: []
            };

            // Victorian Primary Legislation
            const vicActPatterns = [
              /Criminal\s+Procedure\s+Act\s+2009/gi,
              /Evidence\s+Act\s+2008/gi,
              /Crimes\s+Act\s+1958/gi,
              /Charter\s+of\s+Human\s+Rights\s+and\s+Responsibilities\s+Act\s+2006/gi,
              /Victoria\s+Police\s+Act\s+2013/gi,
              /Sentencing\s+Act\s+1991/gi,
              /Children,\s+Youth\s+and\s+Families\s+Act\s+2005/gi,
              /Supreme\s+Court\s+Act\s+1986/gi,
              /Magistrates[\'']?\s+Court\s+Act\s+1989/gi,
              /County\s+Court\s+Act\s+1958/gi,
              /Bail\s+Act\s+1977/gi,
              /Confiscation\s+Act\s+1997/gi
            ];

            vicActPatterns.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.primaryLegislation.push(...new Set(matches));
              }
            });

            // Victorian Subordinate Instruments
            const vicRegPatterns = [
              /Criminal\s+Procedure\s+Regulations/gi,
              /Evidence\s+\(Miscellaneous\s+Provisions\s*\)\s+Regulations/gi,
              /Victoria\s+Police\s+Regulations/gi,
              /Supreme\s+Court\s+\(General\s+Civil\s+Procedure\s*\)\s+Rules/gi,
              /Magistrates[\'']?\s+Court\s+General\s+Civil\s+Procedure\s+Rules/gi
            ];

            vicRegPatterns.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.subordinateInstrumentation.push(...new Set(matches));
              }
            });

            // Victorian Courts
            const courtPatterns = [
              /Supreme\s+Court\s+of\s+Victoria/gi,
              /County\s+Court\s+of\s+Victoria/gi,
              /Magistrates[\'']?\s+Court\s+of\s+Victoria/gi,
              /Children[\'']?s\s+Court\s+of\s+Victoria/gi,
              /Coroners\s+Court\s+of\s+Victoria/gi
            ];

            courtPatterns.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.governingCourts.push(...new Set(matches));
              }
            });

            // Victorian Police Procedures
            if (documentType === 'Victoria Police Manual' || content.match(/victoria\s+police/i)) {
              const vpmPatterns = [
                /VPM\s+[A-Z0-9-]+/g,
                /Operational\s+Procedure\s+\d+/gi,
                /Victoria\s+Police\s+Manual\s+Section\s+\d+/gi
              ];

              vpmPatterns.forEach(pattern => {
                const matches = content.match(pattern);
                if (matches) {
                  framework.relevantPoliceProcedures.push(...new Set(matches));
                }
              });
            }

            // Victorian Evidence Rules
            const evidenceRules = [
              /s\.\s*\d+\s+Evidence\s+Act/gi,
              /section\s+\d+\s+of\s+the\s+Evidence\s+Act/gi,
              /Division\s+\d+\s+of\s+Part\s+\d+\s+of\s+the\s+Evidence\s+Act/gi
            ];

            evidenceRules.forEach(pattern => {
              const matches = content.match(pattern);
              if (matches) {
                framework.applicableEvidentRules.push(...new Set(matches));
              }
            });

            return framework;
          };

          // OCR Text Extraction Function
          const extractTextWithOCR = async (file, fileKey, onProgress) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();

              reader.onload = async (e) => {
                try {
                  console.log(`Starting OCR processing for ${file.name}...`);

                  const { data: { text } } = await Tesseract.recognize(
                    e.target.result,
                    'eng',
                    {
                      logger: (m) => {
                        if (m.status === 'recognizing text') {
                          const progress = Math.round(m.progress * 100);
                          if (onProgress) {
                            onProgress(progress);
                          }
                          console.log(`OCR Progress: ${progress}%`);
                        }
                      }
                    }
                  );

                  console.log(`OCR completed for ${file.name}. Extracted ${text.length} characters.`);
                  resolve(text);
                } catch (error) {
                  console.error('OCR extraction failed:', error);
                  reject(error);
                }
              };

              reader.onerror = () => reject(new Error('Failed to read file'));
              reader.readAsDataURL(file);
            });
          };

          // PDF Text Extraction Function
          const extractTextFromPDF = async (file, fileKey, onProgress) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();

              reader.onload = async (e) => {
                try {
                  console.log(`Starting PDF text extraction for ${file.name}...`);
                  const typedArray = new Uint8Array(e.target.result);

                  const loadingTask = pdfjsLib.getDocument(typedArray);
                  const pdf = await loadingTask.promise;

                  const numPages = pdf.numPages;
                  console.log(`PDF has ${numPages} pages`);

                  let fullText = '';

                  for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';

                    const progress = Math.round((pageNum / numPages) * 100);
                    if (onProgress) {
                      onProgress(progress);
                    }
                    console.log(`Processed page ${pageNum}/${numPages} (${progress}%)`);
                  }

                  console.log(`PDF extraction completed. Extracted ${fullText.length} characters from ${numPages} pages.`);
                  resolve(fullText);
                } catch (error) {
                  console.error('PDF extraction failed:', error);
                  reject(error);
                }
              };

              reader.onerror = () => reject(new Error('Failed to read PDF file'));
              reader.readAsArrayBuffer(file);
            });
          };

          const handleFileUpload = async (file, fileKey) => {
            if (!file) return;

            setIsUploading(prev => ({ ...prev, [fileKey]: true }));
            setUploadProgress(prev => ({ ...prev, [fileKey]: 0 }));

            try {
              let content = '';
              const fileType = file.type;
              const fileName = file.name.toLowerCase();

              // PHASE 1: OCR and Text Extraction (happens FIRST before any analysis)
              console.log(`Starting text extraction for ${file.name}...`);
              console.log(`File type: ${fileType}`);

              // Determine extraction method based on file type
              if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) {
                // PDF files: Extract text using PDF.js
                console.log('Detected PDF file - using PDF text extraction');
                setUploadProgress(prev => ({ ...prev, [fileKey]: 5 }));

                content = await extractTextFromPDF(file, fileKey, (progress) => {
                  // Map PDF extraction progress to 5-70% of overall progress
                  const mappedProgress = 5 + Math.round(progress * 0.65);
                  setUploadProgress(prev => ({ ...prev, [fileKey]: mappedProgress }));
                });

              } else if (fileType.startsWith('image/') ||
                         fileName.endsWith('.png') ||
                         fileName.endsWith('.jpg') ||
                         fileName.endsWith('.jpeg') ||
                         fileName.endsWith('.gif') ||
                         fileName.endsWith('.bmp') ||
                         fileName.endsWith('.tiff')) {
                // Image files: Extract text using OCR (Tesseract.js)
                console.log('Detected image file - using OCR text extraction');
                setUploadProgress(prev => ({ ...prev, [fileKey]: 5 }));

                content = await extractTextWithOCR(file, fileKey, (progress) => {
                  // Map OCR progress to 5-70% of overall progress
                  const mappedProgress = 5 + Math.round(progress * 0.65);
                  setUploadProgress(prev => ({ ...prev, [fileKey]: mappedProgress }));
                });

              } else {
                // Plain text files: Read directly
                console.log('Detected text file - reading as plain text');
                content = await new Promise((resolve, reject) => {
                  const reader = new FileReader();

                  reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                      const progress = 5 + Math.round((e.loaded / e.total) * 65);
                      setUploadProgress(prev => ({ ...prev, [fileKey]: progress }));
                    }
                  };

                  reader.onload = (e) => resolve(e.target.result);
                  reader.onerror = () => reject(new Error('Failed to read text file'));
                  reader.readAsText(file);
                });
              }

              // Verify we got content
              if (!content || content.trim().length === 0) {
                throw new Error('No text could be extracted from the file. The file may be empty or the format is not supported.');
              }

              console.log(`Text extraction completed. Extracted ${content.length} characters.`);
              setUploadProgress(prev => ({ ...prev, [fileKey]: 75 }));

              // PHASE 2: Document Classification and Framework Identification
              console.log('Classifying document and identifying legal framework...');
              const documentType = classifyDocumentType(file.name, content);
              const framework = identifyVictorianFramework(content, documentType);

              setUploadProgress(prev => ({ ...prev, [fileKey]: 90 }));

              // PHASE 3: Store Results
              const enhancedFile = {
                ...file,
                documentType: documentType,
                framework: framework,
                uploadTimestamp: new Date().toISOString(),
                extractionMethod: fileType === 'application/pdf' ? 'PDF Extraction' :
                                 fileType.startsWith('image/') ? 'OCR (Tesseract)' : 'Plain Text'
              };

              setFiles(prev => ({ ...prev, [fileKey]: enhancedFile }));
              setFileContents(prev => ({ ...prev, [fileKey]: content }));
              setUploadProgress(prev => ({ ...prev, [fileKey]: 100 }));

              console.log(`File ${fileKey} processed successfully:`);
              console.log(`- Classification: ${documentType}`);
              console.log(`- Extraction Method: ${enhancedFile.extractionMethod}`);
              console.log(`- Text Length: ${content.length} characters`);
              console.log(`- Governing Framework:`, framework);

              setTimeout(() => {
                setIsUploading(prev => ({ ...prev, [fileKey]: false }));
              }, 300);

            } catch (error) {
              console.error(`Error processing file ${file.name}:`, error);
              alert(`Failed to process file: ${error.message}\n\nSupported formats:\n- PDF documents (.pdf)\n- Images (.png, .jpg, .jpeg, .gif, .bmp, .tiff) - OCR will be performed\n- Text files (.txt, .doc, .docx)`);

              setIsUploading(prev => ({ ...prev, [fileKey]: false }));
              setUploadProgress(prev => ({ ...prev, [fileKey]: 0 }));
            }
          };

          const handleUrlUpload = async (url, fileKey) => {
            try {
              const response = await fetch(url);
              const content = await response.text();
              setFiles(prev => ({ ...prev, [fileKey]: { name: url.split('/').pop(), type: 'url' } }));
              setFileContents(prev => ({ ...prev, [fileKey]: content }));
            } catch (error) {
              alert('Failed to fetch document from URL. Please ensure the URL is accessible and points to a text document.');
            }
          };

          const handleDragOver = (e) => {
            e.preventDefault();
            e.stopPropagation();
          };

          const handleDrop = (e, fileKey) => {
            e.preventDefault();
            e.stopPropagation();
            const file = e.dataTransfer.files[0];
            if (file) handleFileUpload(file, fileKey);
          };

          const simulateAnalysis = async () => {
            setAnalysisState('analyzing');
            setAnalysisResults(null);
            setAnalysisProgress(0);

            setCurrentPhase('Phase A: Multi-Preset Forensic Examination');
            setAnalysisProgress(10);
            await new Promise(resolve => setTimeout(resolve, 2000));

            const phaseAResults = {
              fileA: interpretivePresets.map(preset => ({
                preset: preset.name,
                findings: generateFindings(fileContents.fileA, preset)
              })),
              fileB: interpretivePresets.map(preset => ({
                preset: preset.name,
                findings: generateFindings(fileContents.fileB, preset)
              }))
            };

            setAnalysisProgress(40);
            setCurrentPhase('Phase B: Victorian Criminal Compliance & Statutory Cross-Reference Analysis');
            await new Promise(resolve => setTimeout(resolve, 2000));

            const phaseBResults = performCrossReference(phaseAResults);
            setAnalysisProgress(65);

            setCurrentPhase('Phase C: Statutory Interpretation & Legislative Purpose Analysis');
            await new Promise(resolve => setTimeout(resolve, 2000));

            const phaseCResults = performStatutoryInterpretation(phaseAResults, phaseBResults);
            setAnalysisProgress(80);

            const finalResults = {
              phaseA: phaseAResults,
              phaseB: phaseBResults,
              phaseC: phaseCResults,
              summary: generateExecutiveSummary(phaseAResults, phaseBResults, phaseCResults)
            };

            setAnalysisResults(finalResults);
            setAnalysisProgress(90);

            // Save analysis to persistent storage
            await AnalysisMemory.saveAnalysis(finalResults, files);

            // Reload historical analyses and detect patterns
            const updatedAnalyses = await AnalysisMemory.getAllAnalyses();
            setHistoricalAnalyses(updatedAnalyses || []);

            setAnalysisProgress(95);

            // Run pattern detection
            if (updatedAnalyses && updatedAnalyses.length > 0) {
              const patterns = await PatternDetector.analyze(finalResults, updatedAnalyses);
              setDetectedPatterns(patterns);
              console.log('Pattern detection completed:', patterns);

              // Run contextual intelligence analysis
              const insights = await ContextualIntelligence.enhanceFindings(finalResults, updatedAnalyses);
              setContextualInsights(insights.contextualInsights);
              console.log('Contextual intelligence analysis completed:', insights.contextualInsights);
            }

            setAnalysisProgress(100);
            setAnalysisState('complete');
            setCurrentPhase('Analysis Complete');
          };

          // Word-by-Word Linguistic Inspection Engine
          const performLinguisticInspection = (content, documentType, framework) => {
            const lines = content.split('\n');
            const linguisticReport = {
              totalWords: 0,
              totalLines: lines.length,
              lineByLineAnalysis: [],
              wordAccuracyIssues: [],
              grammaticalDefects: [],
              legalTerminologyIssues: [],
              victorianComplianceDefects: []
            };

            lines.forEach((line, lineIndex) => {
              const lineNumber = lineIndex + 1;
              const words = line.trim().split(/\s+/).filter(w => w.length > 0);
              linguisticReport.totalWords += words.length;

              const lineAnalysis = {
                lineNumber: lineNumber,
                content: line,
                wordCount: words.length,
                issues: [],
                wordByWordInspection: []
              };

              // Word-by-word inspection
              words.forEach((word, wordIndex) => {
                const wordPosition = wordIndex + 1;
                const cleanWord = word.replace(/[^\w\s'-]/g, '').toLowerCase();

                const wordInspection = {
                  position: wordPosition,
                  word: word,
                  issues: []
                };

                // Victorian legal terminology accuracy
                const victorianTermIssues = checkVictorianLegalTerminology(word, cleanWord, documentType);
                if (victorianTermIssues.length > 0) {
                  wordInspection.issues.push(...victorianTermIssues);
                  linguisticReport.legalTerminologyIssues.push({
                    line: lineNumber,
                    word: word,
                    position: wordPosition,
                    issues: victorianTermIssues
                  });
                }

                // Check for spelling and accuracy
                const spellingIssues = checkLegalSpelling(word, cleanWord);
                if (spellingIssues) {
                  wordInspection.issues.push(spellingIssues);
                  linguisticReport.wordAccuracyIssues.push({
                    line: lineNumber,
                    word: word,
                    position: wordPosition,
                    issue: spellingIssues
                  });
                }

                if (wordInspection.issues.length > 0) {
                  lineAnalysis.wordByWordInspection.push(wordInspection);
                }
              });

              // Line-level checks
              const lineIssues = performLineInspection(line, lineNumber, documentType, framework);
              lineAnalysis.issues.push(...lineIssues);

              if (lineIssues.length > 0) {
                linguisticReport.grammaticalDefects.push(...lineIssues.map(issue => ({
                  line: lineNumber,
                  content: line,
                  issue: issue
                })));
              }

              linguisticReport.lineByLineAnalysis.push(lineAnalysis);
            });

            return linguisticReport;
          };

          // Victorian Legal Terminology Checker
          const checkVictorianLegalTerminology = (originalWord, cleanWord, documentType) => {
            const issues = [];

            // Victorian-specific terminology that must be accurate
            const victorianTerms = {
              'informant': { correct: 'informant', common_errors: ['informent', 'informent'], context: 'Victorian police terminology' },
              'indictable': { correct: 'indictable', common_errors: ['indicatable', 'indictible'], context: 'Victorian criminal law' },
              'committals': { correct: 'committals', common_errors: ['commitals', 'commital'], context: 'Victorian court procedure' },
              'magistrate': { correct: 'magistrate', common_errors: ['magistrait', 'magistrat'], context: 'Victorian judicial officer' },
              'summons': { correct: 'summons', common_errors: ['summon', 'summonses'], context: 'Victorian court process' },
              'pursuant': { correct: 'pursuant', common_errors: ['persuan', 'persuant'], context: 'Legal terminology' },
              'defence': { correct: 'defence', american: 'defense', context: 'Australian spelling (not defense)' },
              'practitioner': { correct: 'practitioner', common_errors: ['practisioner', 'practioner'], context: 'Legal practitioner' },
              'recognised': { correct: 'recognised', american: 'recognized', context: 'Australian spelling (not recognized)' },
              'summarised': { correct: 'summarised', american: 'summarized', context: 'Australian spelling (not summarized)' }
            };

            for (const [term, info] of Object.entries(victorianTerms)) {
              if (info.common_errors && info.common_errors.includes(cleanWord)) {
                issues.push({
                  type: 'Victorian Legal Terminology Error',
                  severity: 'high',
                  description: `"${originalWord}" should be "${info.correct}" in ${info.context}`,
                  correct: info.correct,
                  context: info.context
                });
              }

              // Check for American spelling in Victorian context
              if (info.american && cleanWord === info.american) {
                issues.push({
                  type: 'Australian Spelling Required',
                  severity: 'medium',
                  description: `"${originalWord}" uses American spelling. Victorian documents require "${info.correct}"`,
                  correct: info.correct,
                  context: info.context
                });
              }
            }

            return issues;
          };

          // Legal Spelling Checker
          const checkLegalSpelling = (word, cleanWord) => {
            const commonLegalMisspellings = {
              'achive': 'achieve',
              'admissable': 'admissible',
              'alledge': 'allege',
              'arguement': 'argument',
              'benificial': 'beneficial',
              'calender': 'calendar',
              'comitted': 'committed',
              'complience': 'compliance',
              'defendent': 'defendant',
              'discreation': 'discretion',
              'existance': 'existence',
              'fourty': 'forty',
              'gaurd': 'guard',
              'guidence': 'guidance',
              'independant': 'independent',
              'judgement': 'judgment',  // Note: In Australian legal context, both are acceptable
              'liason': 'liaison',
              'maintainance': 'maintenance',
              'occassion': 'occasion',
              'occurance': 'occurrence',
              'persue': 'pursue',
              'preceed': 'precede',
              'priviledge': 'privilege',
              'proceedure': 'procedure',
              'recieve': 'receive',
              'seperate': 'separate',
              'statutory': 'statuary'  // Common typo
            };

            if (commonLegalMisspellings[cleanWord]) {
              return {
                type: 'Spelling Error',
                severity: 'medium',
                description: `"${word}" appears to be misspelled. Correct spelling: "${commonLegalMisspellings[cleanWord]}"`,
                suggestion: commonLegalMisspellings[cleanWord]
              };
            }

            return null;
          };

          // Line-Level Inspection
          const performLineInspection = (line, lineNumber, documentType, framework) => {
            const issues = [];

            // Check for incomplete statutory references
            if (/section\s+\d+\s*$/i.test(line) && !line.includes('Act')) {
              issues.push({
                type: 'Incomplete Statutory Reference',
                severity: 'high',
                description: 'Section reference without specifying the Act',
                defect: 'Section reference incomplete - must specify governing Act'
              });
            }

            // Check for incorrect conjunction usage in legal lists
            if (/,\s+and\s+,/.test(line)) {
              issues.push({
                type: 'Grammatical Error',
                severity: 'low',
                description: 'Incorrect comma placement with conjunction',
                defect: 'Oxford comma usage inconsistent or incorrect'
              });
            }

            // Check for passive voice in Victoria Police procedural documents
            if (documentType === 'Victoria Police Manual' && /was\s+\w+ed\b|were\s+\w+ed\b/i.test(line)) {
              issues.push({
                type: 'Passive Voice in Procedural Document',
                severity: 'low',
                description: 'Victoria Police procedures should use active voice',
                defect: 'Consider rephrasing in active voice for clarity'
              });
            }

            // Check for ambiguous temporal references
            if (/as soon as possible|ASAP|promptly|immediately/i.test(line)) {
              issues.push({
                type: 'Vague Temporal Reference',
                severity: 'medium',
                description: 'Imprecise time requirement - Victorian statutory compliance requires specific timeframes',
                defect: 'Replace with specific timeframe (e.g., "within 7 days", "within 24 hours")'
              });
            }

            // Check for missing mandatory elements in statements
            if (documentType === 'Statement' && lineNumber === 1) {
              if (!/statement\s+of/i.test(line)) {
                issues.push({
                  type: 'Missing Statement Header',
                  severity: 'high',
                  description: 'Statement documents should begin with "Statement of [name]"',
                  defect: 'Required header missing - Victoria Police disclosure requirements'
                });
              }
            }

            // Check for incorrect court references
            const incorrectCourtRefs = [
              { pattern: /Magistrates Court(?!\s+of\s+Victoria)/gi, correct: 'Magistrates\' Court of Victoria' },
              { pattern: /Supreme Court(?!\s+of\s+Victoria)/gi, correct: 'Supreme Court of Victoria' },
              { pattern: /County Court(?!\s+of\s+Victoria)/gi, correct: 'County Court of Victoria' }
            ];

            incorrectCourtRefs.forEach(ref => {
              if (ref.pattern.test(line)) {
                issues.push({
                  type: 'Incomplete Court Reference',
                  severity: 'high',
                  description: `Court reference should be "${ref.correct}" in Victorian documents`,
                  defect: 'Full court name required for Victorian jurisdiction'
                });
              }
            });

            return issues;
          };

          const generateFindings = (content, preset) => {
            const words = content.split(/\s+/).filter(w => w.length > 0);
            const lines = content.split('\n').filter(l => l.trim().length > 0);

            // Extract legal references first so we can pass them to issue identification
            const legalReferences = extractLegalReferences(content);

            // Perform comprehensive linguistic inspection
            const linguisticInspection = performLinguisticInspection(content, 'General Legal Document', {});

            return {
              wordCount: words.length,
              lineCount: lines.length,
              linguisticInspection: linguisticInspection,
              keyTermsIdentified: extractKeyTerms(content, preset),
              proceduralElements: identifyProceduralElements(content, preset),
              legalReferences: legalReferences,
              potentialIssues: identifyPotentialIssues(content, preset, legalReferences),
              contextualMarkers: extractContextualMarkers(content, preset)
            };
          };

          const extractKeyTerms = (content, preset) => {
            const legalTerms = ['section', 'act', 'regulation', 'pursuant', 'provision', 'subsection', 
                                'statute', 'legislative', 'compliance', 'requirement', 'jurisdiction',
                                'evidence', 'exhibit', 'disclosure', 'preliminary', 'test', 'analysis',
                                'procedure', 'statutory', 'mandatory', 'discretionary', 'power'];
            
            const found = [];
            
            legalTerms.forEach(term => {
              const regex = new RegExp(`\\b${term}\\b`, 'gi');
              const matches = content.match(regex);
              if (matches) {
                found.push({
                  term: term,
                  occurrences: matches.length,
                  contexts: extractContexts(content, term, 50)
                });
              }
            });
            
            return found.slice(0, 10);
          };

          const extractContexts = (content, term, contextLength) => {
            const regex = new RegExp(`.{0,${contextLength}}\\b${term}\\b.{0,${contextLength}}`, 'gi');
            const matches = content.match(regex);
            return matches ? matches.slice(0, 3) : [];
          };

          const identifyProceduralElements = (content, preset) => {
            const proceduralIndicators = [
              { pattern: /section\s+\d+[A-Z]?/gi, type: 'Statutory Reference' },
              { pattern: /\b(must|shall|may|ought)\b/gi, type: 'Mandatory/Discretionary Language' },
              { pattern: /\b(pursuant to|in accordance with|under)\b/gi, type: 'Procedural Compliance Indicator' },
              { pattern: /\b(evidence|exhibit|disclosure|statement)\b/gi, type: 'Evidentiary Element' },
              { pattern: /\b(date|time|within|before|after)\b/gi, type: 'Temporal Element' }
            ];

            return proceduralIndicators.map(indicator => ({
              type: indicator.type,
              matches: (content.match(indicator.pattern) || []).length,
              examples: extractContexts(content, indicator.pattern.source.replace(/\\b|\(|\)|gi/g, ''), 40).slice(0, 2)
            })).filter(item => item.matches > 0);
          };

          const extractLegalReferences = (content) => {
            const references = [];
            
            const sectionMatches = content.match(/section\s+\d+[A-Z]?(?:\(\d+\))?(?:\([a-z]\))?/gi);
            if (sectionMatches) {
              references.push(...sectionMatches.map(m => ({ type: 'Section Reference', text: m })));
            }
            
            const actMatches = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Act\s+\d{4}/g);
            if (actMatches) {
              references.push(...actMatches.map(m => ({ type: 'Act Citation', text: m })));
            }
            
            return references.slice(0, 15);
          };

          // Enhanced issue identification with statutory compliance matrix
          const identifyPotentialIssues = (content, preset, legalReferences = []) => {
            const issues = [];

            // Extract statutory framework for this document
            const primaryActs = legalReferences.filter(r => r.type === 'Act Citation');
            const sectionRefs = legalReferences.filter(r => r.type === 'Section Reference');

            // Category 1: CRITICAL STATUTORY DEFECTS (High Severity)

            // 1.1 Acknowledged Errors or Corrections
            const errorPatterns = /\b(error|incorrect|mistake|erroneously|wrongly|inadvertent|oversight)\b/gi;
            const errorMatches = content.match(errorPatterns);
            if (errorMatches && errorMatches.length > 0) {
              issues.push({
                severity: 'critical',
                type: 'Acknowledged Defect',
                category: 'Statutory Compliance',
                description: `Document contains ${errorMatches.length} reference(s) to errors or incorrect information`,
                evidence: errorMatches.slice(0, 3).join(', '),
                statutoryImpact: 'May invalidate reliance on document under s15AA Acts Interpretation Act',
                weight: 10
              });
            }

            // 1.2 Jurisdiction Issues
            const jurisdictionPatterns = /\b(jurisdiction|ultra vires|beyond power|lack.*authority|void|invalid)\b/gi;
            const jurisdictionMatches = content.match(jurisdictionPatterns);
            if (jurisdictionMatches && jurisdictionMatches.length > 2) {
              issues.push({
                severity: 'critical',
                type: 'Jurisdictional Defect',
                category: 'Statutory Compliance',
                description: 'Document raises potential jurisdictional or validity concerns',
                evidence: jurisdictionMatches.slice(0, 3).join(', '),
                statutoryImpact: 'Jurisdictional defects may render decision void ab initio',
                weight: 10
              });
            }

            // 1.3 Procedural Fairness Violations
            const fairnessPatterns = /\b(natural justice|procedural fairness|bias|denied.*opportunity|no.*hearing|unfair)\b/gi;
            const fairnessMatches = content.match(fairnessPatterns);
            if (fairnessMatches && fairnessMatches.length > 0) {
              issues.push({
                severity: 'high',
                type: 'Procedural Fairness Issue',
                category: 'Statutory Compliance',
                description: 'Document indicates potential breach of procedural fairness',
                evidence: fairnessMatches.slice(0, 3).join(', '),
                statutoryImpact: 'Breach of natural justice may constitute jurisdictional error',
                weight: 9
              });
            }

            // Category 2: STATUTORY REFERENCE DEFECTS (High-Medium Severity)

            // 2.1 Missing Primary Legislation Reference
            if (primaryActs.length === 0) {
              issues.push({
                severity: 'high',
                type: 'Missing Primary Legislation',
                category: 'Statutory Framework',
                description: 'No primary Act citations identified - cannot determine governing legislative framework',
                statutoryImpact: 'Unable to assess compliance with enabling legislation',
                weight: 8
              });
            }

            // 2.2 Missing Section References
            if (sectionRefs.length === 0 && content.length > 500) {
              issues.push({
                severity: 'medium',
                type: 'Missing Specific Statutory Provisions',
                category: 'Statutory Framework',
                description: 'No specific section references identified despite substantive content',
                statutoryImpact: 'Lack of specificity may indicate insufficient statutory basis',
                weight: 6
              });
            }

            // 2.3 Inconsistent Citation Format
            const inconsistentCitations = checkCitationConsistency(content);
            if (inconsistentCitations.length > 0) {
              issues.push({
                severity: 'medium',
                type: 'Inconsistent Citation Format',
                category: 'Statutory Framework',
                description: 'Mixed or inconsistent citation formats detected',
                evidence: inconsistentCitations.join('; '),
                weight: 5
              });
            }

            // Category 3: SUBORDINATE INSTRUMENT ISSUES (Medium Severity)

            // 3.1 Identify subordinate instruments
            const subordinateInstruments = identifySubordinateInstruments(content);
            if (subordinateInstruments.regulations.length > 0 && primaryActs.length === 0) {
              issues.push({
                severity: 'medium',
                type: 'Orphaned Subordinate Instrument',
                category: 'Legislative Hierarchy',
                description: `${subordinateInstruments.regulations.length} subordinate instrument(s) cited without parent Act`,
                evidence: subordinateInstruments.regulations.slice(0, 3).join(', '),
                statutoryImpact: 'Subordinate instruments must be read subject to enabling Act',
                weight: 7
              });
            }

            // 3.2 Regulation vs Act conflict indicators
            const conflictPatterns = /\b(contrary to|inconsistent with|conflict|override|supersede)\b/gi;
            const conflictMatches = content.match(conflictPatterns);
            if (conflictMatches && subordinateInstruments.regulations.length > 0) {
              issues.push({
                severity: 'high',
                type: 'Potential Instrument Conflict',
                category: 'Legislative Hierarchy',
                description: 'Potential conflict between subordinate and primary legislation',
                evidence: conflictMatches.slice(0, 2).join(', '),
                statutoryImpact: 'Subordinate instruments cannot override primary legislation',
                weight: 8
              });
            }

            // Category 4: MANDATORY VS DISCRETIONARY LANGUAGE (Medium-Low Severity)

            const mustShallCount = (content.match(/\b(must|shall|required)\b/gi) || []).length;
            const mayCount = (content.match(/\b(may|discretion|permitted)\b/gi) || []).length;
            const couldCount = (content.match(/\b(could|might|possibly)\b/gi) || []).length;

            // 4.1 Ambiguous mandatory obligations
            if (mustShallCount > 0 && mayCount > 0) {
              const ratio = mayCount / mustShallCount;
              const severity = ratio > 0.5 ? 'medium' : 'low';
              issues.push({
                severity: severity,
                type: 'Mixed Mandatory/Discretionary Language',
                category: 'Interpretive Clarity',
                description: `Document contains both mandatory (${mustShallCount}) and discretionary (${mayCount}) obligations`,
                statutoryImpact: 'Mandatory obligations interpreted according to "must" vs "may" distinction',
                weight: ratio > 0.5 ? 5 : 3
              });
            }

            // 4.2 Weak or vague language in statutory context
            if (couldCount > mustShallCount && mustShallCount > 0) {
              issues.push({
                severity: 'medium',
                type: 'Vague Language in Statutory Context',
                category: 'Interpretive Clarity',
                description: `Predominance of uncertain language (${couldCount} instances) over mandatory obligations`,
                weight: 4
              });
            }

            // Category 5: EVIDENTIARY & PROCEDURAL SUFFICIENCY (Medium-Low Severity)

            // 5.1 Insufficient factual detail
            const lines = content.split('\n').filter(l => l.trim().length > 0);
            const words = content.split(/\s+/).length;
            if (lines.length < 5 && words < 100) {
              issues.push({
                severity: 'medium',
                type: 'Insufficient Substantive Content',
                category: 'Procedural Sufficiency',
                description: `Document appears to lack substantive detail (${lines.length} lines, ${words} words)`,
                statutoryImpact: 'Inadequate reasoning may constitute failure to discharge statutory duty',
                weight: 6
              });
            }

            // 5.2 Missing temporal references
            const temporalMarkers = content.match(/\b(\d{1,2}\/\d{1,2}\/\d{2,4}|\d{4}-\d{2}-\d{2}|date|time|deadline|by|before|after|within \d+)\b/gi);
            if (!temporalMarkers && content.length > 500) {
              issues.push({
                severity: 'low',
                type: 'Missing Temporal References',
                category: 'Procedural Sufficiency',
                description: 'No specific dates or timeframes identified in substantive document',
                weight: 3
              });
            }

            // 5.3 Evidence markers
            const evidenceMarkers = content.match(/\b(evidence|exhibit|annexure|attachment|schedule|appendix)\b/gi);
            if (evidenceMarkers && evidenceMarkers.length > 3) {
              const evidenceVerification = content.match(/\b(refer|attached|enclosed|provided)\b/gi);
              if (!evidenceVerification || evidenceVerification.length < evidenceMarkers.length) {
                issues.push({
                  severity: 'medium',
                  type: 'Potential Missing Evidence',
                  category: 'Procedural Sufficiency',
                  description: `${evidenceMarkers.length} evidence references but insufficient verification of attachment`,
                  weight: 5
                });
              }
            }

            // Category 6: INTERPRETIVE PRINCIPLES (Low-Medium Severity)

            // 6.1 Specific vs General provisions (generalia specialibus non derogant)
            const generalTerms = content.match(/\b(general|overall|broadly|in general|generally)\b/gi);
            const specificTerms = content.match(/\b(specific|specifically|particular|precisely|expressly)\b/gi);
            if (generalTerms && specificTerms && generalTerms.length > specificTerms.length * 2) {
              issues.push({
                severity: 'low',
                type: 'Predominance of General over Specific',
                category: 'Interpretive Principles',
                description: 'Document relies heavily on general rather than specific provisions',
                statutoryImpact: 'Principle: Specific provisions prevail over general (generalia specialibus non derogant)',
                weight: 4
              });
            }

            // 6.2 Express inclusions/exclusions (expressio unius est exclusio alterius)
            const inclusionTerms = content.match(/\b(includes?|including|such as|means)\b/gi);
            const exclusionTerms = content.match(/\b(excludes?|excluding|except|other than|but not)\b/gi);
            if (inclusionTerms && !exclusionTerms && inclusionTerms.length > 3) {
              issues.push({
                severity: 'low',
                type: 'Express Inclusions without Exclusions',
                category: 'Interpretive Principles',
                description: 'Multiple express inclusions may imply exclusion of unstated items',
                statutoryImpact: 'Principle: Express mention excludes unstated items (expressio unius)',
                weight: 3
              });
            }

            // Calculate overall severity score
            const totalWeight = issues.reduce((sum, issue) => sum + (issue.weight || 0), 0);

            // Sort issues by weight (highest first)
            issues.sort((a, b) => (b.weight || 0) - (a.weight || 0));

            // Add metadata
            issues.forEach((issue, index) => {
              issue.id = `ISSUE-${index + 1}`;
              issue.governingFramework = primaryActs.length > 0 ? primaryActs[0].text : 'Unspecified';
            });

            return {
              issues: issues,
              summary: {
                totalIssues: issues.length,
                critical: issues.filter(i => i.severity === 'critical').length,
                high: issues.filter(i => i.severity === 'high').length,
                medium: issues.filter(i => i.severity === 'medium').length,
                low: issues.filter(i => i.severity === 'low').length,
                overallRiskScore: totalWeight,
                riskLevel: totalWeight > 40 ? 'CRITICAL' : totalWeight > 25 ? 'HIGH' : totalWeight > 15 ? 'MEDIUM' : 'LOW'
              }
            };
          };

          // Helper function: Check citation consistency
          const checkCitationConsistency = (content) => {
            const inconsistencies = [];

            // Check for mixed section reference styles
            const sectionStyle1 = content.match(/section \d+/gi);
            const sectionStyle2 = content.match(/s\.\d+/gi);
            const sectionStyle3 = content.match(/sec\. \d+/gi);

            const styles = [sectionStyle1, sectionStyle2, sectionStyle3].filter(s => s && s.length > 0);
            if (styles.length > 1) {
              inconsistencies.push('Mixed section reference formats (e.g., "section 5", "s.5", "sec. 5")');
            }

            // Check for mixed subsection styles
            const subsectionParen = content.match(/\(\d+\)/g);
            const subsectionBracket = content.match(/\[\d+\]/g);
            if (subsectionParen && subsectionBracket) {
              inconsistencies.push('Mixed subsection formats (parentheses vs brackets)');
            }

            return inconsistencies;
          };

          // Helper function: Identify subordinate instruments
          const identifySubordinateInstruments = (content) => {
            const regulations = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Regulations?\s+\d{4}/g) || [];
            const rules = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Rules\s+\d{4}/g) || [];
            const orders = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Orders?\s+\d{4}/g) || [];
            const instruments = content.match(/[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\s+Instrument\s+\d{4}/g) || [];

            return {
              regulations: [...new Set(regulations)],
              rules: [...new Set(rules)],
              orders: [...new Set(orders)],
              instruments: [...new Set(instruments)],
              total: regulations.length + rules.length + orders.length + instruments.length
            };
          };

          const extractContextualMarkers = (content, preset) => {
            return {
              temporalMarkers: (content.match(/\b(before|after|within|during|on|at)\s+[a-zA-Z0-9\s,]+/gi) || []).slice(0, 5),
              conditionalMarkers: (content.match(/\b(if|unless|provided that|subject to)\b[^.]+/gi) || []).slice(0, 5),
              authorityMarkers: (content.match(/\b(officer|court|tribunal|authority|minister)\b[^.]+/gi) || []).slice(0, 5)
            };
          };

          // Enhanced Victorian Law Statutory Compliance Checker for Criminal Summary Matters
          const checkVictorianStatutoryCompliance = (content, documentType, legalReferences) => {
            const complianceIssues = [];

            // ====================================================================================
            // PART 1: DISCLOSURE REQUIREMENTS - Criminal Procedure Act 2009 Part 3.3
            // ====================================================================================

            if (documentType === 'Disclosure Document' || documentType === 'Statement') {
              // Check 1.1: Informant's statement present
              if (!/informant[\'']?s?\s+statement/i.test(content)) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Disclosure Requirements',
                  defect: 'Missing informant\'s statement in disclosure',
                  compliance: 'non-compliant',
                  remediation: 'Include informant\'s statement as required by CPA 2009 s.186(1)(a)'
                });
              }

              // Check 1.2: Witness statements
              const witnessStatementMatch = content.match(/witness\s+statement/gi);
              if (!witnessStatementMatch || witnessStatementMatch.length === 0) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Witness Statements',
                  defect: 'No witness statements identified',
                  compliance: 'unclear',
                  remediation: 'Verify all witness statements are disclosed per s.186(1)(b)'
                });
              }

              // Check 1.3: Prior convictions disclosed
              if (!/prior\s+(conviction|record|history)|criminal\s+(history|record)/i.test(content)) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Prior Convictions',
                  defect: 'No reference to prior convictions or criminal history',
                  compliance: 'unclear',
                  remediation: 'Disclose any prior convictions relevant to the case (s.186(1)(c))'
                });
              }

              // Check 1.4: Physical evidence list
              if (!/evidence\s+(list|schedule|inventory)|exhibit\s+(list|schedule|inventory)|physical\s+evidence/i.test(content)) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - s.186 Physical Evidence',
                  defect: 'No physical evidence list or exhibit schedule identified',
                  compliance: 'non-compliant',
                  remediation: 'Provide list of all physical evidence per s.186(1)(d)'
                });
              }

              // Check 1.5: Statements signed and dated
              const hasSignature = /signed|signature/i.test(content);
              const hasDate = /dated|date\s*:/i.test(content);
              if (!hasSignature) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - Statement Formalities',
                  defect: 'No indication that statements are signed',
                  compliance: 'non-compliant',
                  remediation: 'All statements must be signed by declarant'
                });
              }
              if (!hasDate) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 'Part 3.3 - Statement Formalities',
                  defect: 'No indication that statements are dated',
                  compliance: 'non-compliant',
                  remediation: 'All statements must be dated to establish timeline'
                });
              }

              // Check 1.6: s.186 timeframe compliance
              if (!/within\s+\d+\s+(days?|weeks?|months?)|disclosure\s+deadline/i.test(content)) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Criminal Procedure Act 2009',
                  section: 's.186 - Disclosure Timing',
                  defect: 'No specific disclosure timeframe identified',
                  compliance: 'potentially non-compliant',
                  remediation: 'Ensure disclosure meets s.186 mandatory timeframes'
                });
              }

              // Check 1.7: Exhibits properly identified
              const exhibitReferences = content.match(/exhibit\s+[A-Z0-9]+/gi);
              if (exhibitReferences && exhibitReferences.length > 0) {
                const properIdentification = /exhibit\s+[A-Z0-9]+:\s*[\w\s]+/i.test(content);
                if (!properIdentification) {
                  complianceIssues.push({
                    severity: 'medium',
                    statute: 'Criminal Procedure Act 2009',
                    section: 'Part 3.3 - Exhibit Identification',
                    defect: 'Exhibits referenced but may lack proper descriptions',
                    compliance: 'unclear',
                    remediation: 'Each exhibit must have unique identifier and description'
                  });
                }
              }
            }

            // ====================================================================================
            // PART 2: PRELIMINARY TEST REQUIREMENTS - Road Safety Act 1986
            // ====================================================================================

            const isPreliminaryTest = /preliminary\s+(test|breath|drug)|roadside\s+test|screening\s+test/i.test(content);

            if (isPreliminaryTest) {
              // Check 2.1: Section 49(1) - "reason to believe"
              const hasReasonToBelieve = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)|believed|suspected/i.test(content);
              if (!hasReasonToBelieve) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Road Safety Act 1986',
                  section: 's.49(1) - Reason to Believe',
                  defect: 'No evidence that officer had "reason to believe" as required by s.49(1)',
                  compliance: 'non-compliant',
                  remediation: 'Document must show officer\'s subjective belief that driver had consumed alcohol/drugs'
                });
              }

              // Check 2.2: Section 55D(1) - test "in accordance with directions"
              const hasDirections = /in\s+accordance\s+with\s+directions?|directions?\s+(given|provided|issued)|followed\s+directions?/i.test(content);
              if (!hasDirections) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Road Safety Act 1986',
                  section: 's.55D(1) - Accordance with Directions',
                  defect: 'No evidence test was conducted "in accordance with directions"',
                  compliance: 'non-compliant',
                  remediation: 'Must specify that test was conducted in accordance with s.55D(1) directions'
                });
              }

              // Check 2.3: Section 55D(2) - oral directions if literate
              const hasOralDirections = /oral\s+directions?|verbal\s+(?:directions?|instructions?)|spoken\s+to|told\s+to|instructed\s+(?:to|that)/i.test(content);
              const hasLiteracyRef = /literate|able\s+to\s+read|read\s+and\s+understand/i.test(content);
              if (!hasOralDirections && !hasLiteracyRef) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Road Safety Act 1986',
                  section: 's.55D(2) - Oral Directions',
                  defect: 'No indication that oral directions were given if person literate',
                  compliance: 'unclear',
                  remediation: 'If person literate, oral directions must be given per s.55D(2)'
                });
              }

              // Check 2.4: Section 55E - "proper performance" indicators
              const properPerformanceIndicators = [
                /device\s+approval|approved\s+device|approved\s+(?:by|under)/i,
                /calibrat(?:ed|ion)|maintain(?:ed|ance)|servic(?:ed|ing)/i,
                /proper\s+(?:working\s+)?(?:order|condition|performance)/i,
                /tested\s+and\s+(?:certified|approved)/i
              ];
              const hasProperPerformance = properPerformanceIndicators.some(pattern => pattern.test(content));
              if (!hasProperPerformance) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Road Safety Act 1986',
                  section: 's.55E - Proper Performance',
                  defect: 'No indicators of device "proper performance" as required by s.55E',
                  compliance: 'non-compliant',
                  remediation: 'Must document: device approval number, calibration/maintenance records'
                });
              }

              // Check 2.5: Device approval number
              const hasApprovalNumber = /approval\s+(?:number|no\.?|#)\s*:?\s*[\w\d\-]+|device\s+(?:number|no\.?|#)\s*:?\s*[\w\d\-]+/i.test(content);
              if (!hasApprovalNumber) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Road Safety Act 1986',
                  section: 's.55E - Device Approval',
                  defect: 'No device approval number specified',
                  compliance: 'non-compliant',
                  remediation: 'Must specify approved device number per s.55E proper performance requirements'
                });
              }

              // Check 2.6: Calibration/maintenance records
              const hasMaintenanceRecords = /calibrat(?:ed|ion)\s+(?:on|date|record)|maintenance\s+(?:log|record)|service\s+(?:date|record)/i.test(content);
              if (!hasMaintenanceRecords) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Road Safety Act 1986',
                  section: 's.55E - Device Maintenance',
                  defect: 'No calibration or maintenance records referenced',
                  compliance: 'unclear',
                  remediation: 'Document calibration/maintenance to establish proper performance'
                });
              }

              // Check 2.7: Section 55(1) - evidentiary test compliance
              const hasEvidentinaryTest = /evidentiary\s+test|evidential\s+(?:test|breath)/i.test(content);
              if (hasEvidentinaryTest) {
                const hasCompliance = /complied\s+with|in\s+accordance\s+with|pursuant\s+to.*s(?:ection)?\s*55\(1\)/i.test(content);
                if (!hasCompliance) {
                  complianceIssues.push({
                    severity: 'high',
                    statute: 'Road Safety Act 1986',
                    section: 's.55(1) - Evidentiary Test',
                    defect: 'Evidentiary test mentioned but compliance not documented',
                    compliance: 'unclear',
                    remediation: 'Document compliance with s.55(1) evidentiary test requirements'
                  });
                }
              }

              // Check 2.8: Time of test vs time of driving
              const hasTestTime = /time\s+of\s+test|test\s+conducted\s+at|tested\s+at/i.test(content);
              const hasDrivingTime = /time\s+of\s+(?:driving|incident|offence)|drove\s+at|driving\s+at/i.test(content);
              if (hasTestTime && !hasDrivingTime) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Road Safety Act 1986',
                  section: 'Temporal Requirements',
                  defect: 'Test time documented but time of driving unclear',
                  compliance: 'unclear',
                  remediation: 'Establish temporal link between driving and test administration'
                });
              }
            }

            // ====================================================================================
            // PART 3: EVIDENCE ACT 2008 COMPLIANCE
            // ====================================================================================

            // Check 3.1: Hearsay issues (s.59)
            const hearsayIndicators = /(?:he|she|they)\s+(?:said|told|stated)|told\s+(?:me|us|the\s+officer)|stated\s+that|informed\s+(?:me|us)|reported\s+that/i;
            const hasHearsay = hearsayIndicators.test(content);
            if (hasHearsay) {
              complianceIssues.push({
                severity: 'high',
                statute: 'Evidence Act 2008 (Vic)',
                section: 's.59 - Hearsay Rule',
                defect: 'Potential hearsay evidence identified',
                compliance: 'unclear',
                remediation: 'Verify hearsay is admissible under exception (s.60-69) or consider s.59 exclusion'
              });

              // Check 3.2: If hearsay, is exception claimed? (s.60-69)
              const hearsayExceptions = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay|business\s+records|contemporaneous\s+statement/i;
              if (!hearsayExceptions.test(content)) {
                complianceIssues.push({
                  severity: 'critical',
                  statute: 'Evidence Act 2008 (Vic)',
                  section: 's.60-69 - Hearsay Exceptions',
                  defect: 'Hearsay evidence present but no exception claimed',
                  compliance: 'non-compliant',
                  remediation: 'Identify applicable hearsay exception under s.60-69 or exclude evidence'
                });
              }

              // Check 3.3: Business records exception (s.69)
              const businessRecords = /business\s+records?|s(?:ection)?\s*69|records?\s+(?:kept|made)\s+in\s+(?:the\s+)?course\s+of.*business/i;
              if (businessRecords.test(content)) {
                const hasFoundation = /person\s+with\s+knowledge|made\s+(?:by|at)|kept\s+in\s+(?:the\s+)?ordinary\s+course/i.test(content);
                if (!hasFoundation) {
                  complianceIssues.push({
                    severity: 'high',
                    statute: 'Evidence Act 2008 (Vic)',
                    section: 's.69 - Business Records',
                    defect: 'Business records exception invoked but foundation not established',
                    compliance: 'unclear',
                    remediation: 'Establish s.69 requirements: record made by competent person, in ordinary course'
                  });
                }
              }
            }

            // Check 3.4: Section 137 - probative vs prejudicial
            const highlyPrejudicial = /prior\s+(?:conviction|offence)|bad\s+character|previous\s+(?:criminal|bad)\s+(?:conduct|behaviour)|prejudicial/i;
            if (highlyPrejudicial.test(content)) {
              complianceIssues.push({
                severity: 'medium',
                statute: 'Evidence Act 2008 (Vic)',
                section: 's.137 - Probative vs Prejudicial',
                defect: 'Potentially prejudicial evidence - probative value may be outweighed',
                compliance: 'consider-exclusion',
                remediation: 'Court discretion under s.137: exclude if probative value < unfair prejudice'
              });
            }

            // Check 3.5: Section 138 - improperly obtained evidence
            const improperlyObtained = /obtained\s+(?:illegally|unlawfully|improperly)|breach\s+of|violated|without\s+(?:warrant|authority|consent)|unlawful\s+(?:search|seizure)/i;
            if (improperlyObtained.test(content)) {
              complianceIssues.push({
                severity: 'critical',
                statute: 'Evidence Act 2008 (Vic)',
                section: 's.138 - Improperly Obtained Evidence',
                defect: 'Evidence may have been improperly or illegally obtained',
                compliance: 'non-compliant',
                remediation: 'Court must consider s.138 discretionary exclusion for improperly obtained evidence'
              });
            }

            // ====================================================================================
            // PART 4: GENERAL VICTORIAN COMPLIANCE CHECKS
            // ====================================================================================

            // Check 4.1: Victoria Police Act 2013 compliance
            if (documentType === 'Victoria Police Manual' || /victoria\s+police/i.test(content)) {
              if (!/Victoria\s+Police\s+Act\s+2013/i.test(content)) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Victoria Police Act 2013',
                  section: 'General Compliance',
                  defect: 'Police procedures should reference Victoria Police Act 2013',
                  compliance: 'potentially non-compliant',
                  remediation: 'Add reference to Victoria Police Act 2013'
                });
              }
            }

            // Check 4.2: Charter of Human Rights compliance
            const humanRightsIndicators = /rights?|fairness|natural justice|discrimination|equality/i;
            if (humanRightsIndicators.test(content)) {
              if (!/Charter\s+of\s+Human\s+Rights/i.test(content)) {
                complianceIssues.push({
                  severity: 'medium',
                  statute: 'Charter of Human Rights and Responsibilities Act 2006',
                  section: 'Human rights considerations',
                  defect: 'Document discusses rights but does not reference Charter',
                  compliance: 'consider-charter',
                  remediation: 'Consider whether Charter of Human Rights and Responsibilities Act 2006 is engaged'
                });
              }
            }

            // Check 4.3: Court-specific compliance
            if (documentType === 'Court Order' || documentType === 'Court Documentation') {
              const hasCourtRef = /Supreme\s+Court|County\s+Court|Magistrates/i.test(content);
              const hasFullCourtName = /Supreme\s+Court\s+of\s+Victoria|County\s+Court\s+of\s+Victoria|Magistrates[\'']?\s+Court\s+of\s+Victoria/i.test(content);

              if (hasCourtRef && !hasFullCourtName) {
                complianceIssues.push({
                  severity: 'high',
                  statute: 'Court rules and procedures',
                  section: 'Court identification',
                  defect: 'Court references must use full official name including "of Victoria"',
                  compliance: 'non-compliant',
                  remediation: 'Use full court names: "Supreme Court of Victoria", "County Court of Victoria", "Magistrates\' Court of Victoria"'
                });
              }
            }

            return complianceIssues;
          };

          // Cross-File Narrative and Timeline Evaluator
          const evaluateCrossFileNarrativeTimeline = (contentA, contentB, fileAMetadata, fileBMetadata) => {
            const narrativeAnalysis = {
              timelineDiscrepancies: [],
              narrativeInconsistencies: [],
              eventSequenceMismatch: [],
              factualContradictions: [],
              sequentialMapping: []
            };

            // Extract dates and temporal references from both files
            const datesA = extractDatesAndTimeline(contentA);
            const datesB = extractDatesAndTimeline(contentB);

            // Extract events and narrative elements
            const eventsA = extractNarrativeEvents(contentA);
            const eventsB = extractNarrativeEvents(contentB);

            // Compare timelines
            datesA.forEach(dateA => {
              const matchingDatesB = datesB.filter(dateB =>
                dateB.normalizedDate === dateA.normalizedDate
              );

              if (matchingDatesB.length > 0) {
                matchingDatesB.forEach(dateB => {
                  if (dateA.context !== dateB.context) {
                    narrativeAnalysis.timelineDiscrepancies.push({
                      date: dateA.normalizedDate,
                      fileA: { line: dateA.line, context: dateA.context },
                      fileB: { line: dateB.line, context: dateB.context },
                      severity: 'high',
                      defect: 'Same date referenced with different contexts',
                      mapping: `File A Line ${dateA.line} vs File B Line ${dateB.line}`
                    });
                  }
                });
              }
            });

            // Compare event sequences
            const commonTerms = findCommonNarrativeTerms(eventsA, eventsB);
            commonTerms.forEach(term => {
              const orderA = eventsA.findIndex(e => e.text.toLowerCase().includes(term.toLowerCase()));
              const orderB = eventsB.findIndex(e => e.text.toLowerCase().includes(term.toLowerCase()));

              if (orderA !== -1 && orderB !== -1) {
                const contextA = eventsA[orderA];
                const contextB = eventsB[orderB];

                // Check if surrounding context differs significantly
                if (contextA.surrounding !== contextB.surrounding) {
                  narrativeAnalysis.eventSequenceMismatch.push({
                    term: term,
                    fileA: { line: contextA.line, sequence: orderA, context: contextA.text },
                    fileB: { line: contextB.line, sequence: orderB, context: contextB.text },
                    severity: 'medium',
                    defect: 'Same event referenced but surrounding narrative differs',
                    mapping: `File A Line ${contextA.line} (Event #${orderA + 1}) vs File B Line ${contextB.line} (Event #${orderB + 1})`
                  });
                }
              }
            });

            // Look for direct contradictions
            const contradictions = findFactualContradictions(contentA, contentB);
            narrativeAnalysis.factualContradictions = contradictions;

            // Build sequential mapping of all cross-referenced elements
            narrativeAnalysis.sequentialMapping = buildSequentialMapping(
              datesA,
              datesB,
              eventsA,
              eventsB,
              contentA,
              contentB
            );

            return narrativeAnalysis;
          };

          // Extract dates and temporal references
          const extractDatesAndTimeline = (content) => {
            const dates = [];
            const lines = content.split('\n');

            const datePatterns = [
              /\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\b/g,  // DD/MM/YYYY or DD-MM-YYYY
              /\b(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})\b/g,    // YYYY/MM/DD
              /\b(\d{1,2})\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{4})\b/gi,
              /\b(January|February|March|April|May|June|July|August|September|October|November|December)\s+(\d{1,2}),?\s+(\d{4})\b/gi
            ];

            lines.forEach((line, index) => {
              datePatterns.forEach(pattern => {
                const matches = [...line.matchAll(pattern)];
                matches.forEach(match => {
                  dates.push({
                    line: index + 1,
                    original: match[0],
                    normalizedDate: match[0],  // Simplified - would normally parse to standard format
                    context: line.trim()
                  });
                });
              });

              // Temporal markers
              const temporalMarkers = [
                /\bbefore\s+[^.]+/gi,
                /\bafter\s+[^.]+/gi,
                /\bwithin\s+\d+\s+(days?|weeks?|months?|years?)/gi,
                /\bon\s+or\s+about\s+[^.]+/gi
              ];

              temporalMarkers.forEach(pattern => {
                const matches = [...line.matchAll(pattern)];
                matches.forEach(match => {
                  dates.push({
                    line: index + 1,
                    original: match[0],
                    normalizedDate: 'temporal-marker',
                    context: line.trim()
                  });
                });
              });
            });

            return dates;
          };

          // Extract narrative events
          const extractNarrativeEvents = (content) => {
            const events = [];
            const lines = content.split('\n');

            const eventIndicators = [
              /\b(occurred|happened|took place|transpired|witnessed|observed|attended|conducted|performed|executed)\b/gi,
              /\b(seized|arrested|detained|charged|interviewed|questioned)\b/gi,
              /\b(stated|declared|asserted|claimed|testified|deposed)\b/gi,
              /\b(found|discovered|located|identified|recovered)\b/gi
            ];

            lines.forEach((line, index) => {
              eventIndicators.forEach(pattern => {
                if (pattern.test(line)) {
                  const surrounding = lines.slice(Math.max(0, index - 1), Math.min(lines.length, index + 2)).join(' ');
                  events.push({
                    line: index + 1,
                    text: line.trim(),
                    surrounding: surrounding.trim()
                  });
                }
              });
            });

            return events;
          };

          // Find common narrative terms
          const findCommonNarrativeTerms = (eventsA, eventsB) => {
            const termsA = new Set(
              eventsA.flatMap(e => e.text.toLowerCase().match(/\b\w{4,}\b/g) || [])
            );
            const termsB = new Set(
              eventsB.flatMap(e => e.text.toLowerCase().match(/\b\w{4,}\b/g) || [])
            );

            return [...termsA].filter(term => termsB.has(term) && !['this', 'that', 'with', 'from', 'have', 'been', 'were', 'said'].includes(term));
          };

          // Find factual contradictions
          const findFactualContradictions = (contentA, contentB) => {
            const contradictions = [];

            // Simple contradiction patterns
            const contradictionPatterns = [
              { pattern: /\b(yes|no|true|false|did|did not|was|was not)\b/gi, type: 'affirmation/negation' },
              { pattern: /\b\d+\s+(person|people|officer|individual|item|exhibit)/gi, type: 'quantity' },
              { pattern: /\b(present|absent|available|unavailable)\b/gi, type: 'presence' }
            ];

            // This is a simplified version - full implementation would use NLP
            contradictionPatterns.forEach(({ pattern, type }) => {
              const matchesA = contentA.match(pattern) || [];
              const matchesB = contentB.match(pattern) || [];

              if (matchesA.length > 0 && matchesB.length > 0) {
                const uniqueA = new Set(matchesA.map(m => m.toLowerCase()));
                const uniqueB = new Set(matchesB.map(m => m.toLowerCase()));

                // Check for direct opposites
                uniqueA.forEach(a => {
                  if (a.includes('not') && uniqueB.has(a.replace(/not\s+/, ''))) {
                    contradictions.push({
                      type: type,
                      fileA: a,
                      fileB: a.replace(/not\s+/, ''),
                      severity: 'high',
                      defect: 'Direct contradiction between documents'
                    });
                  }
                });
              }
            });

            return contradictions;
          };

          // Build sequential mapping
          const buildSequentialMapping = (datesA, datesB, eventsA, eventsB, contentA, contentB) => {
            const mapping = [];

            // Map all dates sequentially
            datesA.forEach((dateA, indexA) => {
              mapping.push({
                sequenceNumber: mapping.length + 1,
                type: 'temporal',
                source: 'File A',
                line: dateA.line,
                element: dateA.original,
                context: dateA.context,
                crossReference: datesB.find(db => db.normalizedDate === dateA.normalizedDate) || null
              });
            });

            datesB.forEach((dateB, indexB) => {
              if (!mapping.find(m => m.source === 'File B' && m.line === dateB.line)) {
                mapping.push({
                  sequenceNumber: mapping.length + 1,
                  type: 'temporal',
                  source: 'File B',
                  line: dateB.line,
                  element: dateB.original,
                  context: dateB.context,
                  crossReference: datesA.find(da => da.normalizedDate === dateB.normalizedDate) || null
                });
              }
            });

            // Map all events sequentially
            eventsA.forEach(eventA => {
              mapping.push({
                sequenceNumber: mapping.length + 1,
                type: 'narrative-event',
                source: 'File A',
                line: eventA.line,
                element: eventA.text,
                context: eventA.surrounding,
                crossReference: null
              });
            });

            eventsB.forEach(eventB => {
              mapping.push({
                sequenceNumber: mapping.length + 1,
                type: 'narrative-event',
                source: 'File B',
                line: eventB.line,
                element: eventB.text,
                context: eventB.surrounding,
                crossReference: null
              });
            });

            return mapping.sort((a, b) => a.sequenceNumber - b.sequenceNumber);
          };

          // Generate Comprehensive Omissions Report - Doc A vs Doc B
          const generateOmissionsReport = (contentA, contentB, phaseAResults) => {
            const report = {
              statutoryReferences: {
                inANotInB: [],
                inBNotInA: []
              },
              proceduralElements: {
                inANotInB: [],
                inBNotInA: []
              },
              factsAndAssertions: {
                inANotInB: [],
                inBNotInA: []
              },
              criticalOmissions: {
                victorianCriminalRequirements: []
              }
            };

            // Extract statutory references
            const refsA = new Set(phaseAResults.fileA[0].findings.legalReferences.map(r => r.text));
            const refsB = new Set(phaseAResults.fileB[0].findings.legalReferences.map(r => r.text));

            refsA.forEach(ref => {
              if (!refsB.has(ref)) {
                report.statutoryReferences.inANotInB.push({
                  element: ref,
                  category: 'Statutory Reference',
                  severity: 'high',
                  impact: 'Legal authority present in Doc A but not referenced in Doc B'
                });
              }
            });

            refsB.forEach(ref => {
              if (!refsA.has(ref)) {
                report.statutoryReferences.inBNotInA.push({
                  element: ref,
                  category: 'Statutory Reference',
                  severity: 'high',
                  impact: 'Legal authority present in Doc B but not referenced in Doc A'
                });
              }
            });

            // Extract procedural elements
            const proceduralA = phaseAResults.fileA[0].findings.proceduralElements || [];
            const proceduralB = phaseAResults.fileB[0].findings.proceduralElements || [];

            const procTypesA = new Set(proceduralA.map(p => p.type));
            const procTypesB = new Set(proceduralB.map(p => p.type));

            procTypesA.forEach(type => {
              if (!procTypesB.has(type)) {
                const examples = proceduralA.find(p => p.type === type)?.examples || [];
                report.proceduralElements.inANotInB.push({
                  element: type,
                  category: 'Procedural Element',
                  severity: 'medium',
                  examples: examples.slice(0, 2),
                  impact: 'Procedural step described in Doc A but omitted from Doc B'
                });
              }
            });

            procTypesB.forEach(type => {
              if (!procTypesA.has(type)) {
                const examples = proceduralB.find(p => p.type === type)?.examples || [];
                report.proceduralElements.inBNotInA.push({
                  element: type,
                  category: 'Procedural Element',
                  severity: 'medium',
                  examples: examples.slice(0, 2),
                  impact: 'Procedural step described in Doc B but omitted from Doc A'
                });
              }
            });

            // Critical Victorian Criminal Matter Omissions

            // Check: "in accordance with directions" language (s.55D RSA 1986)
            const hasDirectionsA = /in\s+accordance\s+with\s+directions?/i.test(contentA);
            const hasDirectionsB = /in\s+accordance\s+with\s+directions?/i.test(contentB);
            if (hasDirectionsA && !hasDirectionsB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: '"In accordance with directions" language',
                statute: 'Road Safety Act 1986 s.55D(1)',
                severity: 'critical',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Critical RSA 1986 s.55D(1) compliance requirement missing from Doc B'
              });
            }
            if (hasDirectionsB && !hasDirectionsA) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: '"In accordance with directions" language',
                statute: 'Road Safety Act 1986 s.55D(1)',
                severity: 'critical',
                inDocument: 'Doc B',
                omittedFrom: 'Doc A',
                impact: 'Critical RSA 1986 s.55D(1) compliance requirement missing from Doc A'
              });
            }

            // Check: Officer's subjective belief formation (s.49 RSA 1986)
            const hasReasonToBelieveA = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)/i.test(contentA);
            const hasReasonToBelieveB = /reason\s+to\s+(believe|suspect)|reasonable\s+(belief|suspicion)/i.test(contentB);
            if (hasReasonToBelieveA && !hasReasonToBelieveB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Officer\'s "reason to believe" formation',
                statute: 'Road Safety Act 1986 s.49(1)',
                severity: 'critical',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Critical s.49(1) requirement - officer\'s subjective belief not documented in Doc B'
              });
            }
            if (hasReasonToBelieveB && !hasReasonToBelieveA) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Officer\'s "reason to believe" formation',
                statute: 'Road Safety Act 1986 s.49(1)',
                severity: 'critical',
                inDocument: 'Doc B',
                omittedFrom: 'Doc A',
                impact: 'Critical s.49(1) requirement - officer\'s subjective belief not documented in Doc A'
              });
            }

            // Check: Device approval number (s.55E RSA 1986)
            const hasApprovalA = /approval\s+(?:number|no\.?|#)|device\s+(?:number|no\.?|#)/i.test(contentA);
            const hasApprovalB = /approval\s+(?:number|no\.?|#)|device\s+(?:number|no\.?|#)/i.test(contentB);
            if (hasApprovalA && !hasApprovalB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Device approval number',
                statute: 'Road Safety Act 1986 s.55E',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Device approval number (s.55E proper performance) missing from Doc B'
              });
            }

            // Check: Calibration/maintenance records (s.55E proper performance)
            const hasCalibrationA = /calibrat(?:ed|ion)|maintenance|service/i.test(contentA);
            const hasCalibrationB = /calibrat(?:ed|ion)|maintenance|service/i.test(contentB);
            if (hasCalibrationA && !hasCalibrationB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Calibration/maintenance records',
                statute: 'Road Safety Act 1986 s.55E',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Proper performance indicators (s.55E) - calibration/maintenance omitted from Doc B'
              });
            }

            // Check: Time of test vs time of driving
            const hasTestTimeA = /time\s+of\s+test|test\s+(?:conducted|administered)\s+at/i.test(contentA);
            const hasTestTimeB = /time\s+of\s+test|test\s+(?:conducted|administered)\s+at/i.test(contentB);
            const hasDrivingTimeA = /time\s+of\s+(?:driving|incident|offence)/i.test(contentA);
            const hasDrivingTimeB = /time\s+of\s+(?:driving|incident|offence)/i.test(contentB);

            if (hasTestTimeA && !hasTestTimeB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Time of test administration',
                statute: 'Road Safety Act 1986 - Temporal Requirements',
                severity: 'medium',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Test timing documented in Doc A but omitted from Doc B'
              });
            }

            if (hasDrivingTimeA && !hasDrivingTimeB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Time of driving/incident',
                statute: 'Road Safety Act 1986 - Temporal Requirements',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Critical temporal element - driving time in Doc A but omitted from Doc B'
              });
            }

            // Check: Hearsay exceptions
            const hasHearsayExceptionA = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay/i.test(contentA);
            const hasHearsayExceptionB = /s(?:ection)?\s*(?:60|61|62|63|64|65|66|67|68|69)|exception\s+to\s+hearsay/i.test(contentB);
            if (hasHearsayExceptionA && !hasHearsayExceptionB) {
              report.criticalOmissions.victorianCriminalRequirements.push({
                element: 'Hearsay exception claim',
                statute: 'Evidence Act 2008 (Vic) s.60-69',
                severity: 'high',
                inDocument: 'Doc A',
                omittedFrom: 'Doc B',
                impact: 'Hearsay exception basis in Doc A but not asserted in Doc B'
              });
            }

            return report;
          };

          // Build Enhanced Cross-Reference Matrix with Doc A vs Doc B Compliance
          const buildComplianceMatrix = (phaseAResults, complianceA, complianceB) => {
            const matrix = [];

            // Build a comprehensive list of all statutory provisions mentioned
            const provisionsMap = new Map();

            // Add provisions from Victorian compliance checks
            [...complianceA, ...complianceB].forEach(issue => {
              const key = `${issue.statute}|${issue.section}`;
              if (!provisionsMap.has(key)) {
                provisionsMap.set(key, {
                  provision: `${issue.statute} - ${issue.section}`,
                  statute: issue.statute,
                  section: issue.section,
                  docACompliance: null,
                  docBCompliance: null,
                  docAIssues: [],
                  docBIssues: [],
                  discrepancies: []
                });
              }
            });

            // Populate Doc A compliance
            complianceA.forEach(issue => {
              const key = `${issue.statute}|${issue.section}`;
              const provision = provisionsMap.get(key);
              if (provision) {
                provision.docAIssues.push(issue);
                // Determine compliance status
                if (issue.compliance === 'compliant') {
                  provision.docACompliance = 'compliant';
                } else if (issue.compliance === 'non-compliant') {
                  provision.docACompliance = 'non-compliant';
                } else {
                  provision.docACompliance = 'unclear';
                }
              }
            });

            // Populate Doc B compliance
            complianceB.forEach(issue => {
              const key = `${issue.statute}|${issue.section}`;
              const provision = provisionsMap.get(key);
              if (provision) {
                provision.docBIssues.push(issue);
                // Determine compliance status
                if (issue.compliance === 'compliant') {
                  provision.docBCompliance = 'compliant';
                } else if (issue.compliance === 'non-compliant') {
                  provision.docBCompliance = 'non-compliant';
                } else {
                  provision.docBCompliance = 'unclear';
                }
              }
            });

            // Identify discrepancies and determine actions
            provisionsMap.forEach((provision, key) => {
              // Default to compliant if no issues found
              if (provision.docACompliance === null && provision.docAIssues.length === 0) {
                provision.docACompliance = 'compliant';
              }
              if (provision.docBCompliance === null && provision.docBIssues.length === 0) {
                provision.docBCompliance = 'compliant';
              }

              // Identify discrepancies
              if (provision.docACompliance !== provision.docBCompliance) {
                provision.discrepancies.push(`Doc A is ${provision.docACompliance || 'unknown'} but Doc B is ${provision.docBCompliance || 'unknown'}`);
              }

              // Determine action required based on compliance
              const highSeverityA = provision.docAIssues.filter(i => i.severity === 'critical' || i.severity === 'high');
              const highSeverityB = provision.docBIssues.filter(i => i.severity === 'critical' || i.severity === 'high');

              if (highSeverityA.length > 0 || highSeverityB.length > 0) {
                provision.actionRequired = 'URGENT: Address critical/high severity issues immediately';
              } else if (provision.docAIssues.length > 0 || provision.docBIssues.length > 0) {
                provision.actionRequired = 'Review and remediate medium/low severity issues';
              } else {
                provision.actionRequired = 'No action required - monitoring';
              }

              matrix.push(provision);
            });

            // Sort by severity (critical issues first)
            matrix.sort((a, b) => {
              const aHasCritical = [...a.docAIssues, ...a.docBIssues].some(i => i.severity === 'critical');
              const bHasCritical = [...b.docAIssues, ...b.docBIssues].some(i => i.severity === 'critical');
              if (aHasCritical && !bHasCritical) return -1;
              if (!aHasCritical && bHasCritical) return 1;

              const aHasHigh = [...a.docAIssues, ...a.docBIssues].some(i => i.severity === 'high');
              const bHasHigh = [...b.docAIssues, ...b.docBIssues].some(i => i.severity === 'high');
              if (aHasHigh && !bHasHigh) return -1;
              if (!aHasHigh && bHasHigh) return 1;

              return 0;
            });

            return matrix;
          };

          const performCrossReference = (phaseAResults) => {
            const discrepancies = [];
            const consistencies = [];
            const omissions = [];

            const refsA = new Set(phaseAResults.fileA[0].findings.legalReferences.map(r => r.text.toLowerCase()));
            const refsB = new Set(phaseAResults.fileB[0].findings.legalReferences.map(r => r.text.toLowerCase()));

            refsA.forEach(ref => {
              if (refsB.has(ref)) {
                consistencies.push({ type: 'Statutory Reference', element: ref, status: 'Present in both documents' });
              } else {
                omissions.push({ type: 'Statutory Reference', element: ref, status: 'Present only in File A' });
              }
            });

            refsB.forEach(ref => {
              if (!refsA.has(ref)) {
                omissions.push({ type: 'Statutory Reference', element: ref, status: 'Present only in File B' });
              }
            });

            const termsA = phaseAResults.fileA[0].findings.keyTermsIdentified.map(t => t.term);
            const termsB = phaseAResults.fileB[0].findings.keyTermsIdentified.map(t => t.term);

            const significantDiscrepancy = Math.abs(termsA.length - termsB.length) > 5;
            if (significantDiscrepancy) {
              discrepancies.push({
                type: 'Document Comprehensiveness',
                description: `Significant difference in legal terminology density (File A: ${termsA.length} terms, File B: ${termsB.length} terms)`,
                severity: 'medium'
              });
            }

            // Add Victorian statutory compliance checks
            const complianceA = checkVictorianStatutoryCompliance(
              fileContents.fileA,
              files.fileA?.documentType || 'General Legal Document',
              phaseAResults.fileA[0].findings.legalReferences
            );

            const complianceB = checkVictorianStatutoryCompliance(
              fileContents.fileB,
              files.fileB?.documentType || 'General Legal Document',
              phaseAResults.fileB[0].findings.legalReferences
            );

            // Add narrative and timeline evaluation
            const narrativeEvaluation = evaluateCrossFileNarrativeTimeline(
              fileContents.fileA,
              fileContents.fileB,
              files.fileA,
              files.fileB
            );

            // Generate comprehensive omissions report
            const omissionsReport = generateOmissionsReport(
              fileContents.fileA,
              fileContents.fileB,
              phaseAResults
            );

            // Build enhanced compliance matrix
            const complianceMatrix = buildComplianceMatrix(
              phaseAResults,
              complianceA,
              complianceB
            );

            return {
              discrepancies,
              consistencies: consistencies.slice(0, 10),
              omissions: omissions.slice(0, 10),
              omissionsReport: omissionsReport,
              complianceMatrix: complianceMatrix,
              governingFramework: identifyGoverningFramework(phaseAResults),
              complianceAssessment: assessCompliance(phaseAResults),
              victorianCompliance: {
                fileA: complianceA,
                fileB: complianceB
              },
              narrativeAndTimeline: narrativeEvaluation
            };
          };

          const identifyGoverningFramework = (phaseAResults) => {
            const frameworks = [];
            
            phaseAResults.fileA.forEach(analysis => {
              analysis.findings.legalReferences.forEach(ref => {
                if (ref.type === 'Act Citation') {
                  frameworks.push({
                    statute: ref.text,
                    source: 'File A',
                    applicability: 'Primary governing legislation'
                  });
                }
              });
            });
            
            phaseAResults.fileB.forEach(analysis => {
              analysis.findings.legalReferences.forEach(ref => {
                if (ref.type === 'Act Citation') {
                  frameworks.push({
                    statute: ref.text,
                    source: 'File B',
                    applicability: 'Primary governing legislation'
                  });
                }
              });
            });
            
            return frameworks;
          };

          const assessCompliance = (phaseAResults) => {
            const assessment = {
              fileA: {
                compliant: 0,
                nonCompliant: 0,
                unclear: 0,
                criticalIssues: 0,
                highIssues: 0,
                mediumIssues: 0,
                lowIssues: 0,
                totalWeight: 0,
                riskLevel: 'LOW'
              },
              fileB: {
                compliant: 0,
                nonCompliant: 0,
                unclear: 0,
                criticalIssues: 0,
                highIssues: 0,
                mediumIssues: 0,
                lowIssues: 0,
                totalWeight: 0,
                riskLevel: 'LOW'
              }
            };

            ['fileA', 'fileB'].forEach(fileKey => {
              let fileRiskScore = 0;

              phaseAResults[fileKey].forEach(analysis => {
                const potentialIssues = analysis.findings.potentialIssues;

                // Handle both old format (array) and new format (object with issues/summary)
                const issues = potentialIssues.issues || potentialIssues;
                const summary = potentialIssues.summary;

                if (summary) {
                  // New enhanced format
                  assessment[fileKey].criticalIssues += summary.critical || 0;
                  assessment[fileKey].highIssues += summary.high || 0;
                  assessment[fileKey].mediumIssues += summary.medium || 0;
                  assessment[fileKey].lowIssues += summary.low || 0;
                  fileRiskScore += summary.overallRiskScore || 0;

                  if (summary.critical > 0 || summary.high > 0) {
                    assessment[fileKey].nonCompliant++;
                  } else if (summary.medium > 0) {
                    assessment[fileKey].unclear++;
                  } else {
                    assessment[fileKey].compliant++;
                  }
                } else {
                  // Old simple format (backward compatibility)
                  if (issues.length === 0) {
                    assessment[fileKey].compliant++;
                  } else {
                    issues.forEach(issue => {
                      if (issue.severity === 'critical') {
                        assessment[fileKey].criticalIssues++;
                        assessment[fileKey].nonCompliant++;
                      } else if (issue.severity === 'high') {
                        assessment[fileKey].highIssues++;
                        assessment[fileKey].nonCompliant++;
                      } else if (issue.severity === 'medium') {
                        assessment[fileKey].mediumIssues++;
                        assessment[fileKey].unclear++;
                      } else {
                        assessment[fileKey].lowIssues++;
                        assessment[fileKey].unclear++;
                      }
                    });
                  }
                }
              });

              assessment[fileKey].totalWeight = fileRiskScore;
              assessment[fileKey].riskLevel = fileRiskScore > 40 ? 'CRITICAL' :
                                               fileRiskScore > 25 ? 'HIGH' :
                                               fileRiskScore > 15 ? 'MEDIUM' : 'LOW';
            });

            return assessment;
          };

          // ============================================================================
          // PHASE C: COMPREHENSIVE STATUTORY INTERPRETATION ENGINE
          // Implements Interpretation Act 1984 (Vic) and Common Law Maxims
          // ============================================================================

          /**
           * Apply Interpretation Act 1984 (Vic) Section 35(a) - Purposive Construction
           * Analyzes provisions to determine Parliament's intention and legislative purpose
           */
          const applyPurposiveConstruction = (provision, context) => {
            const analysis = {
              provision: provision,
              parliamentaryIntention: '',
              mischiefAddressed: '',
              purposeAdvanced: '',
              recommendation: ''
            };

            // Analyze based on provision type
            if (provision.includes('s.49') || provision.includes('section 49')) {
              analysis.parliamentaryIntention = 'Parliament intended to provide lawful authority for preliminary breath testing while protecting individual rights through procedural safeguards';
              analysis.mischiefAddressed = 'Addresses the mischief of impaired driving detection while preventing arbitrary testing without reasonable grounds';
              analysis.purposeAdvanced = 'Road safety through evidence-based detection of alcohol impairment, balanced against procedural fairness';
              analysis.recommendation = 'Interpret requirements strictly - each element must be satisfied to advance the protective purpose';
            } else if (provision.includes('s.55') || provision.includes('section 55')) {
              analysis.parliamentaryIntention = 'Parliament intended to establish evidentiary breath testing regime with strict procedural compliance to ensure accuracy and fairness';
              analysis.mischiefAddressed = 'Prevents unreliable breath test evidence while ensuring procedural integrity of testing process';
              analysis.purposeAdvanced = 'Reliable evidence of BAC levels through mandated procedures and device standards';
              analysis.recommendation = 'Strict compliance with directions and procedures required - deviations undermine legislative purpose';
            } else if (provision.includes('RSA') || provision.includes('Road Safety Act')) {
              analysis.parliamentaryIntention = 'Comprehensive road safety framework balancing enforcement with procedural protections';
              analysis.mischiefAddressed = 'Road trauma from impaired driving while maintaining evidentiary standards';
              analysis.purposeAdvanced = 'Public safety through evidence-based prosecutions with procedural safeguards';
              analysis.recommendation = 'Purposive interpretation requires balancing safety objectives with fairness to accused';
            } else {
              analysis.parliamentaryIntention = 'Determine purpose through text, context, and legislative scheme';
              analysis.mischiefAddressed = 'Consider what problem the provision addresses';
              analysis.purposeAdvanced = 'Interpretation should advance the identified legislative purpose';
              analysis.recommendation = 'Apply purposive construction per Interpretation Act 1984 (Vic) s.35(a)';
            }

            return analysis;
          };

          /**
           * Apply Interpretation Act 1984 (Vic) Section 36 - Use of Extrinsic Materials
           * Identifies ambiguous provisions and suggests reference to extrinsic aids
           */
          const identifyExtrinsicMaterialsNeeded = (provision, ambiguity) => {
            const extrinsicAnalysis = {
              provision: provision,
              isAmbiguous: false,
              ambiguityType: '',
              suggestedMaterials: [],
              applicationGuidance: ''
            };

            // Identify common ambiguous phrases in Victorian traffic law
            const ambiguousPhrases = [
              { phrase: 'reason to believe', type: 'Subjective vs Objective Standard' },
              { phrase: 'as soon as practicable', type: 'Temporal Requirement' },
              { phrase: 'in accordance with', type: 'Compliance Standard' },
              { phrase: 'satisfied that', type: 'Evidentiary Threshold' },
              { phrase: 'directions', type: 'Form and Content of Directions' },
              { phrase: 'approved', type: 'Authorization Standard' }
            ];

            for (const item of ambiguousPhrases) {
              if (provision.toLowerCase().includes(item.phrase) || ambiguity.includes(item.phrase)) {
                extrinsicAnalysis.isAmbiguous = true;
                extrinsicAnalysis.ambiguityType = item.type;

                extrinsicAnalysis.suggestedMaterials = [
                  `Second Reading Speech for relevant amending Act (if Victorian legislation)`,
                  `Explanatory Memorandum addressing "${item.phrase}" requirement`,
                  `Parliamentary Committee Reports on road safety legislation`,
                  `Prior judicial interpretation of "${item.phrase}" in Victorian courts`,
                  `Regulatory Impact Statements for relevant regulations`
                ];

                extrinsicAnalysis.applicationGuidance = `Per Interpretation Act 1984 (Vic) s.36, extrinsic materials may be considered to: (a) confirm plain meaning; (b) resolve ambiguity; (c) determine Parliament's intention. Materials cannot override clear statutory language but can illuminate meaning of "${item.phrase}".`;
                break;
              }
            }

            return extrinsicAnalysis;
          };

          /**
           * Apply Common Law Maxim: Noscitur a sociis (words known by company)
           * Interprets words in context of surrounding words
           */
          const applyNosciturASociis = (phrase, context) => {
            const analysis = {
              phrase: phrase,
              surroundingContext: '',
              interpretation: '',
              application: ''
            };

            if (phrase.includes('reason to believe')) {
              analysis.surroundingContext = 'Within s.49, "reason to believe" appears alongside requirements for preliminary testing, indications of alcohol consumption, and observation requirements';
              analysis.interpretation = 'Must be interpreted in context of other s.49 requirements - objective basis required, not mere suspicion';
              analysis.application = 'Officer must articulate specific facts constituting "reason to believe" consistent with other evidentiary requirements in s.49';
            } else if (phrase.includes('in accordance with')) {
              analysis.surroundingContext = 'Appears with "directions", "approved device", and procedural requirements';
              analysis.interpretation = 'Strict compliance interpretation - must follow directions precisely as the surrounding procedural language requires exactitude';
              analysis.application = 'Deviations from directions may vitiate test validity, as phrase appears in procedural compliance context';
            } else if (phrase.includes('directions')) {
              analysis.surroundingContext = 'Used with "oral or written", "given by", and "approved device"';
              analysis.interpretation = 'Directions must be clear, communicated (oral or written), and relate to approved device operation';
              analysis.application = 'Vague or uncommunicated instructions cannot constitute "directions" in this statutory context';
            } else {
              analysis.surroundingContext = context || 'Analyze within immediate statutory context';
              analysis.interpretation = 'Interpret term by reference to associated words and phrases';
              analysis.application = 'Apply noscitur a sociis to derive meaning from statutory company';
            }

            return analysis;
          };

          /**
           * Apply Common Law Maxim: Expressio unius est exclusio alterius
           * Express mention of specific things excludes others not mentioned
           */
          const applyExpressioUnius = (listProvision) => {
            const analysis = {
              expresslyIncluded: [],
              impliedlyExcluded: '',
              legalConsequence: '',
              example: ''
            };

            if (listProvision.includes('s.49(1)') || listProvision.includes('section 49(1)')) {
              analysis.expresslyIncluded = [
                's.49(1)(a) - Driving or in charge of motor vehicle',
                's.49(1)(b) - Consumed intoxicating liquor',
                's.49(1)(c) - Accident involving injury/death',
                's.49(1)(d) - Involved in accident',
                's.49(1)(e) - Committed traffic offence',
                's.49(1)(f) - Driving in manner dangerous',
                's.49(1)(g) - Subject to alcohol interlock condition',
                's.49(1)(h) - Random breath testing'
              ];
              analysis.impliedlyExcluded = 'Any circumstances NOT listed in s.49(1)(a)-(h) do NOT authorize preliminary breath test';
              analysis.legalConsequence = 'If test conducted outside listed circumstances, test is unauthorized and potentially inadmissible';
              analysis.example = 'Example: If officer lacks "reason to believe" under (b) and no other subsection applies, test is unauthorized';
            } else if (listProvision.includes('approved') || listProvision.includes('prescribed')) {
              analysis.expresslyIncluded = ['Specifically approved/prescribed items per regulation'];
              analysis.impliedlyExcluded = 'Non-approved or non-prescribed items/procedures are excluded';
              analysis.legalConsequence = 'Use of non-approved device or non-prescribed procedure renders test invalid';
              analysis.example = 'Example: Only breath testing devices specifically approved may be used - substitutes excluded';
            } else {
              analysis.expresslyIncluded = ['Items explicitly listed in provision'];
              analysis.impliedlyExcluded = 'Items not listed are implicitly excluded';
              analysis.legalConsequence = 'Express list limits scope of provision';
              analysis.example = 'Apply expressio unius to statutory lists';
            }

            return analysis;
          };

          /**
           * Apply Common Law Maxim: Generalia specialibus non derogant
           * Specific provisions override general provisions
           */
          const applyGeneraliaSpecialibus = (generalProvision, specificProvision) => {
            const analysis = {
              generalProvision: generalProvision,
              specificProvision: specificProvision,
              whichPrevails: '',
              reasoning: '',
              practicalEffect: ''
            };

            if (specificProvision.includes('s.55D') || specificProvision.includes('s.55E')) {
              analysis.specificProvision = 'RSA 1986 ss.55D-55E (specific breath test direction requirements)';
              analysis.generalProvision = generalProvision || 'General testing provisions under RSA Part 5';
              analysis.whichPrevails = 'Specific provisions in ss.55D-55E prevail';
              analysis.reasoning = 'Sections 55D-55E contain detailed, specific requirements for breath test directions and procedures. These override general testing provisions.';
              analysis.practicalEffect = 'Must comply with specific s.55D requirements (directions, timing) even if general provisions might allow broader discretion';
            } else if (specificProvision.includes('s.49')) {
              analysis.specificProvision = 's.49 RSA (specific preliminary test requirements)';
              analysis.generalProvision = generalProvision || 'General police powers';
              analysis.whichPrevails = 'Specific s.49 requirements prevail';
              analysis.reasoning = 's.49 lists specific circumstances authorizing preliminary tests - these specific requirements override general police discretion';
              analysis.practicalEffect = 'Cannot rely on general police powers to conduct test outside s.49(1)(a)-(h) circumstances';
            } else {
              analysis.whichPrevails = 'Specific provision prevails over general';
              analysis.reasoning = 'Where specific and general provisions conflict, specific controls per generalia specialibus non derogant';
              analysis.practicalEffect = 'Apply specific statutory requirements strictly';
            }

            return analysis;
          };

          /**
           * Apply Common Law Maxim: Ejusdem generis (of the same kind)
           * General words following specific words are interpreted consistently
           */
          const applyEjusdemGeneris = (specificList, generalTerm) => {
            const analysis = {
              specificItems: specificList,
              generalTerm: generalTerm,
              interpretation: '',
              limitation: ''
            };

            if (generalTerm.includes('other') || generalTerm.includes('similar')) {
              analysis.interpretation = `General term "${generalTerm}" must be interpreted ejusdem generis - of the same kind as the specific items listed`;
              analysis.limitation = `"${generalTerm}" is limited to items sharing characteristics of: ${specificList.join(', ')}`;
            } else {
              analysis.interpretation = 'Interpret general terms following specific lists as being of the same kind';
              analysis.limitation = 'General language constrained by nature of specific examples';
            }

            return analysis;
          };

          /**
           * COMPREHENSIVE AMBIGUITY RESOLVER
           * Provides literal, contextual, and purposive interpretations for ambiguous phrases
           */
          const resolveAmbiguity = (ambiguousPhrase, documentContext, statutoryContext) => {
            const resolution = {
              ambiguousPhrase: ambiguousPhrase,
              literalInterpretation: {
                meaning: '',
                analysis: '',
                strengths: '',
                weaknesses: ''
              },
              contextualInterpretation: {
                meaning: '',
                analysis: '',
                statutoryScheme: '',
                strengths: '',
                weaknesses: ''
              },
              purposiveInterpretation: {
                meaning: '',
                analysis: '',
                legislativePurpose: '',
                mischiefRule: '',
                strengths: '',
                weaknesses: ''
              },
              victorianCourtPreference: '',
              recommendedInterpretation: '',
              caseLawPrinciples: []
            };

            // Analyze "reason to believe"
            if (ambiguousPhrase.toLowerCase().includes('reason to believe')) {
              resolution.literalInterpretation = {
                meaning: 'Plain English: A reason (cause, ground) to believe (accept as true)',
                analysis: 'Ordinary meaning suggests some factual basis for belief, but does not specify objective or subjective standard',
                strengths: 'Simple, accessible interpretation aligned with common usage',
                weaknesses: 'Ambiguous whether purely subjective belief sufficient or objective reasonableness required'
              };

              resolution.contextualInterpretation = {
                meaning: 'Within s.49 statutory context: Objective factual basis for belief that person consumed intoxicating liquor',
                analysis: 's.49 is a police power provision requiring justification for interference with liberty. Context suggests objective standard.',
                statutoryScheme: 's.49 part of graduated testing regime (preliminary ‚Üí evidentiary). Each stage requires objective basis. Context demands "reason" be objectively verifiable.',
                strengths: 'Consistent with other s.49 requirements; protects against arbitrary testing; aligns with rule of law',
                weaknesses: 'More demanding than plain text might suggest'
              };

              resolution.purposiveInterpretation = {
                meaning: 'Objectively reasonable grounds based on observable facts to believe alcohol consumed',
                analysis: 'Legislative purpose balances road safety with individual rights. Requires articulable, objective basis.',
                legislativePurpose: 'Parliament intended to authorize testing while preventing arbitrary exercises of power. Purpose advanced by objective standard.',
                mischiefRule: 'Mischief addressed: impaired driving detection. But also addresses mischief of arbitrary state power. Requires objective reasonableness.',
                strengths: 'Advances legislative purpose of balanced enforcement; consistent with Interpretation Act 1984 (Vic) s.35(a)',
                weaknesses: 'Imposes requirements not explicit in text'
              };

              resolution.victorianCourtPreference = 'Victorian courts would prefer PURPOSIVE/CONTEXTUAL interpretation requiring objective reasonableness';
              resolution.recommendedInterpretation = 'Adopt objective standard: "reason to believe" requires articulable, objectively reasonable grounds based on observable facts. Purely subjective belief insufficient.';
              resolution.caseLawPrinciples = [
                'Modern statutory interpretation favors purposive approach (Interpretation Act 1984 (Vic) s.35(a))',
                'Police power provisions interpreted with attention to rights protection',
                'Ambiguity in penal/quasi-penal statutes resolved in favor of subject',
                'Context and purpose trump literalism where ambiguity exists'
              ];
            }
            // Analyze "in accordance with directions"
            else if (ambiguousPhrase.toLowerCase().includes('in accordance with')) {
              resolution.literalInterpretation = {
                meaning: 'Plain meaning: In conformity with; following; complying with',
                analysis: 'Suggests requirement for compliance, but does not specify degree of exactitude required',
                strengths: 'Clear requirement for some form of compliance',
                weaknesses: 'Does not specify whether substantial compliance sufficient or strict compliance required'
              };

              resolution.contextualInterpretation = {
                meaning: 'Within s.55D context: Strict compliance with directions for breath test procedure',
                analysis: 's.55D creates procedural safeguards for evidentiary testing. Context suggests strict compliance.',
                statutoryScheme: 'Breath test results are scientific evidence affecting liberty. Statutory scheme requires precision in procedure. "In accordance with" in this context means strict compliance.',
                strengths: 'Protects evidentiary integrity; ensures procedural fairness; consistent with scientific testing requirements',
                weaknesses: 'May invalidate tests for minor, non-prejudicial deviations'
              };

              resolution.purposiveInterpretation = {
                meaning: 'Strict compliance with directions required to ensure test validity and procedural fairness',
                analysis: 'Purpose of s.55D: ensure reliable, procedurally sound breath testing. Requires strict compliance.',
                legislativePurpose: 'Parliament intended to ensure breath tests conducted properly with clear procedures. Purpose demands strict interpretation.',
                mischiefRule: 'Addresses mischief of unreliable or procedurally flawed breath testing. Strict compliance advances this purpose.',
                strengths: 'Advances legislative purpose; protects accused from procedural irregularities; ensures evidence reliability',
                weaknesses: 'Strict approach may exclude otherwise reliable evidence'
              };

              resolution.victorianCourtPreference = 'Victorian courts would prefer STRICT COMPLIANCE interpretation given evidentiary and liberty interests';
              resolution.recommendedInterpretation = '"In accordance with directions" requires strict compliance. Material deviations from directions vitiate test validity. Minor, non-prejudicial variations may be excused if no unfairness results.';
              resolution.caseLawPrinciples = [
                'Evidentiary provisions in criminal/traffic matters require strict construction',
                'Procedural safeguards must be observed to protect accused',
                'Scientific evidence requires procedural integrity',
                'Purposive interpretation favors strict compliance where liberty interests engaged'
              ];
            }
            // Analyze "directions"
            else if (ambiguousPhrase.toLowerCase().includes('directions') || ambiguousPhrase.toLowerCase().includes('direction')) {
              resolution.literalInterpretation = {
                meaning: 'Plain meaning: Instructions or orders about how to do something',
                analysis: 'Ordinary meaning suggests communication of instructions, but does not specify form, content, or detail required',
                strengths: 'Flexible interpretation allowing various forms of instruction',
                weaknesses: 'Ambiguous as to whether oral suffices, how specific directions must be, whether understanding required'
              };

              resolution.contextualInterpretation = {
                meaning: 'Within RSA context: Clear, communicated instructions (oral or written) about breath test procedure',
                analysis: 's.55D(2) explicitly allows "oral or written" directions, indicating communication is essential. Context requires clarity.',
                statutoryScheme: 'Directions serve to ensure person understands procedure and can comply. Must be sufficiently clear and communicated. Statutory context suggests directions must be comprehensible and actually given.',
                strengths: 'Ensures procedural fairness; person knows what is required; enables compliance',
                weaknesses: 'May exclude tests where directions unclear or not proven'
              };

              resolution.purposiveInterpretation = {
                meaning: 'Clear, communicated instructions enabling subject to understand and comply with breath test procedure',
                analysis: 'Purpose: ensure person tested understands procedure and can meaningfully comply. Requires actual communication.',
                legislativePurpose: 'Parliament intended directions to safeguard procedural fairness and enable informed compliance. Purpose requires actual, clear communication.',
                mischiefRule: 'Addresses mischief of procedurally unfair testing where person does not understand requirements. Demands clear, communicated directions.',
                strengths: 'Protects procedural rights; ensures fairness; advances purpose of informed compliance',
                weaknesses: 'May require proof of actual communication and understanding'
              };

              resolution.victorianCourtPreference = 'Victorian courts would require CLEAR, COMMUNICATED directions with proof of actual communication';
              resolution.recommendedInterpretation = '"Directions" requires proof that clear instructions were actually communicated (orally or in writing) to the subject. Mere device operation without communicated directions insufficient.';
              resolution.caseLawPrinciples = [
                'Procedural requirements in testing regimes must be strictly observed',
                'Directions imply communication - unspoken intentions insufficient',
                'Purposive interpretation requires directions serve their protective function',
                'Ambiguity resolved to protect procedural rights of accused'
              ];
            }
            // Default analysis for other ambiguous phrases
            else {
              resolution.literalInterpretation = {
                meaning: `Plain, ordinary meaning of "${ambiguousPhrase}"`,
                analysis: 'Interpret words in natural, ordinary sense unless context demands otherwise',
                strengths: 'Accessible, predictable interpretation',
                weaknesses: 'May not capture legislative intent or statutory purpose'
              };

              resolution.contextualInterpretation = {
                meaning: `"${ambiguousPhrase}" interpreted within statutory context and legislative scheme`,
                analysis: 'Consider surrounding provisions, relationship to other sections, overall statutory purpose',
                statutoryScheme: 'Examine how phrase fits within broader legislative framework',
                strengths: 'Harmonizes with legislative scheme; considers broader context',
                weaknesses: 'May depart from plain meaning'
              };

              resolution.purposiveInterpretation = {
                meaning: `"${ambiguousPhrase}" interpreted to advance legislative purpose`,
                analysis: 'Interpretation that promotes purpose of legislation preferred per Interpretation Act 1984 (Vic) s.35(a)',
                legislativePurpose: 'Determine Parliament\'s intention and mischief addressed',
                mischiefRule: 'Consider problem provision designed to remedy',
                strengths: 'Advances legislative purpose; consistent with modern interpretation principles',
                weaknesses: 'Requires identification of purpose, which may be contested'
              };

              resolution.victorianCourtPreference = 'Victorian courts favor PURPOSIVE interpretation per Interpretation Act 1984 (Vic) s.35(a)';
              resolution.recommendedInterpretation = 'Apply modern purposive approach: examine text, context, and legislative purpose. Prefer interpretation advancing statutory purpose.';
              resolution.caseLawPrinciples = [
                'Interpretation Act 1984 (Vic) s.35(a) mandates purposive construction',
                'Text, context, and purpose analyzed together',
                'Extrinsic materials may be consulted per s.36',
                'Ambiguity in penal provisions resolved favorably to accused'
              ];
            }

            return resolution;
          };

          /**
           * HARMONIZATION ANALYZER
           * Reconciles conflicts between documents using interpretation principles
           */
          const harmonizeConflicts = (conflicts, phaseAResults, phaseBResults) => {
            const harmonizations = [];

            conflicts.forEach(conflict => {
              const harmonization = {
                conflict: conflict.description || conflict.element || conflict.type,
                fileAPosition: '',
                fileBPosition: '',
                reconciliationAttempt: '',
                isReconcilable: false,
                whichPrevails: '',
                statutorySupport: '',
                legalConsequence: '',
                argumentApproach: ''
              };

              // Extract positions from documents
              harmonization.fileAPosition = `File A: ${conflict.status?.includes('File A') ? conflict.element : 'Position stated in File A'}`;
              harmonization.fileBPosition = `File B: ${conflict.status?.includes('File B') ? conflict.element : 'Position stated in File B'}`;

              // Attempt reconciliation using interpretation principles
              if (conflict.type === 'Statutory Reference' || conflict.element?.toLowerCase().includes('s.') || conflict.element?.toLowerCase().includes('section')) {
                // Statutory reference conflict
                harmonization.reconciliationAttempt = 'Apply harmonious construction principle: attempt to read both documents together to give effect to all provisions. If both documents purport to describe same event, reconcile by examining whether references are complementary or contradictory.';

                if (conflict.status?.includes('only in File A')) {
                  harmonization.isReconcilable = false;
                  harmonization.whichPrevails = 'File A contains statutory reference absent from File B';
                  harmonization.statutorySupport = 'File A has express statutory support; File B lacks this support';
                  harmonization.legalConsequence = 'File B may be deficient if statutory reference is material to facts. File A position preferred if statutory basis required.';
                  harmonization.argumentApproach = 'ARGUMENT: File B omits material statutory reference present in File A. Where statutory authority required, File A account prevails. Omission in File B raises question of procedural compliance.';
                } else if (conflict.status?.includes('only in File B')) {
                  harmonization.isReconcilable = false;
                  harmonization.whichPrevails = 'File B contains statutory reference absent from File A';
                  harmonization.statutorySupport = 'File B has express statutory support; File A lacks this support';
                  harmonization.legalConsequence = 'File A may be deficient if statutory reference is material. File B position preferred if statutory grounding required.';
                  harmonization.argumentApproach = 'ARGUMENT: File A omits statutory reference present in File B. Question whether File A actions had statutory foundation. File B reference may reveal procedural defect in File A account.';
                } else {
                  harmonization.isReconcilable = true;
                  harmonization.whichPrevails = 'Documents can be read harmoniously';
                  harmonization.statutorySupport = 'Both documents reference relevant statutory provisions';
                  harmonization.legalConsequence = 'No conflict - documents consistent on statutory framework';
                  harmonization.argumentApproach = 'Documents align on statutory basis - no interpretative issue';
                }
              } else if (conflict.type === 'Document Comprehensiveness' || conflict.description?.includes('terminology density')) {
                // Comprehensiveness conflict
                harmonization.reconciliationAttempt = 'Differences in detail or terminology density do not necessarily create irreconcilable conflict. Apply principle that more detailed account may supplement (not contradict) less detailed account.';
                harmonization.isReconcilable = true;
                harmonization.whichPrevails = 'More comprehensive document provides fuller account';
                harmonization.statutorySupport = 'No direct statutory conflict - difference in detail level';
                harmonization.legalConsequence = 'More detailed document may reveal omissions in less detailed document. Not necessarily contradictory.';
                harmonization.argumentApproach = 'ARGUMENT: Difference in comprehensiveness suggests one document more complete. Question which is contemporaneous and which is reconstruction. More detailed document may be preferred if created closer to events.';
              } else {
                // General conflict
                harmonization.reconciliationAttempt = 'Attempt harmonious construction: can documents be read together without contradiction? If irreconcilable, determine which has better statutory foundation and contemporaneous reliability.';
                harmonization.isReconcilable = false;
                harmonization.whichPrevails = 'Depends on statutory support, contemporaneous creation, and procedural context';
                harmonization.statutorySupport = 'Analyze which document has express statutory grounding';
                harmonization.legalConsequence = 'Irreconcilable conflict raises credibility and reliability issues. May constitute evidence defect.';
                harmonization.argumentApproach = 'ARGUMENT: Where documents irreconcilable, prefer document with (1) statutory foundation, (2) contemporaneous creation, (3) procedural safeguards. Conflict itself may be evidence of unreliability.';
              }

              harmonizations.push(harmonization);
            });

            return harmonizations;
          };

          /**
           * STATUTORY PROVISION INTERPRETATION REPORT GENERATOR
           * Generates detailed interpretation reports for key provisions
           */
          const generateProvisionReport = (provision, documentText, findings) => {
            const report = {
              provision: provision,
              plainText: '',
              applicationToFacts: '',
              requirementsSatisfied: null,
              deficiencies: [],
              legalConsequences: [],
              recommendedArgument: ''
            };

            // Generate report for s.49 RSA (Preliminary Breath Test)
            if (provision.includes('s.49') || provision.includes('section 49') || provision.includes('s 49')) {
              report.plainText = 'Road Safety Act 1986 (Vic) s.49 - Preliminary Breath Test. Requires: (1) Person driving/in charge of motor vehicle; (2) Officer has reason to believe person consumed intoxicating liquor [s.49(1)(b)] OR other circumstances in s.49(1)(a)-(h); (3) Officer may require preliminary breath test; (4) Person must comply with requirement.';

              report.applicationToFacts = `Analyzing documents for s.49 compliance:\n`;

              // Check for "reason to believe"
              const hasReasonToBelieve = documentText.toLowerCase().includes('reason to believe') ||
                                        documentText.toLowerCase().includes('believed') ||
                                        documentText.toLowerCase().includes('appeared');

              const hasObservations = documentText.toLowerCase().includes('smell') ||
                                      documentText.toLowerCase().includes('odour') ||
                                      documentText.toLowerCase().includes('alcohol') ||
                                      documentText.toLowerCase().includes('intoxicated');

              if (hasReasonToBelieve && hasObservations) {
                report.applicationToFacts += '- Document contains reference to belief/observations regarding alcohol consumption\n';
                report.applicationToFacts += '- Observable facts may constitute "reason to believe" under s.49(1)(b)\n';
                report.requirementsSatisfied = 'POTENTIALLY - requires verification of objective basis';
              } else if (hasReasonToBelieve && !hasObservations) {
                report.applicationToFacts += '- Document mentions belief but lacks specific observable facts\n';
                report.applicationToFacts += '- Insufficient detail to assess whether objective "reason to believe" established\n';
                report.requirementsSatisfied = 'UNCLEAR - insufficient factual detail';
                report.deficiencies.push('No specific observable facts articulated to establish "reason to believe"');
              } else {
                report.applicationToFacts += '- No express reference to "reason to believe" alcohol consumed\n';
                report.applicationToFacts += '- Document does not establish s.49(1)(b) basis for preliminary test\n';
                report.requirementsSatisfied = 'NOT SATISFIED - no reason to believe established';
                report.deficiencies.push('CRITICAL: No evidence of "reason to believe" person consumed intoxicating liquor per s.49(1)(b)');
              }

              // Analyze deficiencies
              if (report.deficiencies.length > 0) {
                report.legalConsequences.push('Preliminary breath test may be unauthorized if s.49 requirements not satisfied');
                report.legalConsequences.push('Unauthorized preliminary test may affect admissibility of subsequent evidentiary test');
                report.legalConsequences.push('Lack of statutory authority for initial stop/test may vitiate entire procedure');
              }

              // Recommended argument
              if (report.requirementsSatisfied === 'NOT SATISFIED') {
                report.recommendedArgument = 'LITERAL INTERPRETATION ARGUMENT: s.49 expressly requires "reason to believe" person consumed intoxicating liquor. Document lacks any evidence of this prerequisite. Per expressio unius principle, circumstances listed in s.49(1)(a)-(h) are exhaustive - test outside these circumstances is unauthorized. Preliminary test was unlawful, vitiating subsequent evidentiary procedure.';
              } else if (report.requirementsSatisfied === 'UNCLEAR') {
                report.recommendedArgument = 'PURPOSIVE INTERPRETATION ARGUMENT: s.49 "reason to believe" requires objective, articulable basis per Interpretation Act 1984 (Vic) s.35(a). Document fails to articulate specific observable facts. Mere conclusory assertion of belief insufficient. Legislative purpose of protecting against arbitrary testing requires objective basis - not present here.';
              } else {
                report.recommendedArgument = 'VERIFY: While document references observations, confirm they constitute objectively reasonable grounds for belief of alcohol consumption. Apply contextual interpretation of "reason to believe" - requires more than subjective suspicion.';
              }
            }

            // Generate report for s.55D RSA (Breath Test Directions)
            else if (provision.includes('s.55D') || provision.includes('section 55D') || provision.includes('s.55') || provision.includes('s 55')) {
              report.plainText = 'Road Safety Act 1986 (Vic) s.55D - Breath Test Directions. Requires: (1) Test must be "in accordance with the directions" of person conducting test; (2) Directions may be oral or written; (3) Person must be given opportunity to comply; (4) Procedure must follow approved device requirements.';

              report.applicationToFacts = `Analyzing documents for s.55D compliance:\n`;

              // Check for directions evidence
              const hasDirections = documentText.toLowerCase().includes('directions') ||
                                   documentText.toLowerCase().includes('directed') ||
                                   documentText.toLowerCase().includes('instructed') ||
                                   documentText.toLowerCase().includes('told');

              const hasSpecificDirections = documentText.toLowerCase().includes('blow') ||
                                           documentText.toLowerCase().includes('breathe') ||
                                           documentText.toLowerCase().includes('provide');

              if (hasDirections && hasSpecificDirections) {
                report.applicationToFacts += '- Document contains reference to directions/instructions\n';
                report.applicationToFacts += '- Some evidence of directions regarding breath sample provision\n';
                report.requirementsSatisfied = 'PARTIALLY - requires verification of full compliance';
              } else if (hasDirections && !hasSpecificDirections) {
                report.applicationToFacts += '- Document mentions directions but lacks specific content\n';
                report.applicationToFacts += '- Insufficient detail about what directions were actually given\n';
                report.requirementsSatisfied = 'UNCLEAR - direction content not established';
                report.deficiencies.push('No evidence of specific directions content as required by s.55D');
              } else {
                report.applicationToFacts += '- No reference to directions being given\n';
                report.applicationToFacts += '- Document does not establish s.55D directions requirement\n';
                report.requirementsSatisfied = 'NOT SATISFIED - no evidence directions given';
                report.deficiencies.push('CRITICAL: No evidence that directions were given per s.55D(1) requirement');
              }

              // Check for "in accordance with" compliance
              const hasDeviceMention = documentText.toLowerCase().includes('device') ||
                                      documentText.toLowerCase().includes('machine') ||
                                      documentText.toLowerCase().includes('approved');

              if (!hasDeviceMention) {
                report.deficiencies.push('No mention of approved device - cannot assess "in accordance with directions" compliance');
              }

              // Analyze deficiencies
              if (report.deficiencies.length > 0) {
                report.legalConsequences.push('Breath test result potentially inadmissible if not conducted "in accordance with directions"');
                report.legalConsequences.push('s.55D is mandatory procedural requirement - non-compliance vitiates test validity');
                report.legalConsequences.push('Lack of proof that directions given is evidentiary deficiency');
              }

              // Recommended argument
              if (report.requirementsSatisfied === 'NOT SATISFIED') {
                report.recommendedArgument = 'LITERAL/STRICT COMPLIANCE ARGUMENT: s.55D(1) expressly requires test be "in accordance with the directions" of person conducting test. Document contains NO evidence that any directions were actually given. Cannot have test "in accordance with" non-existent directions. This is mandatory procedural requirement - strict compliance required. Breath test result inadmissible.';
              } else if (report.requirementsSatisfied === 'UNCLEAR') {
                report.recommendedArgument = 'PURPOSIVE INTERPRETATION ARGUMENT: s.55D serves protective purpose - ensures person understands procedure and can meaningfully comply. Purpose requires proof that clear directions were actually communicated. Document fails to establish what directions were given or that subject understood them. Per Interpretation Act s.35(a), purposive construction requires actual communication - not present here.';
              } else {
                report.recommendedArgument = 'VERIFY STRICT COMPLIANCE: s.55D requires strict compliance with directions. Confirm: (1) directions actually given (oral or written); (2) directions were clear and comprehensible; (3) test conducted exactly in accordance with directions; (4) approved device used. Any material deviation may vitiate test.';
              }
            }

            // Generate report for Road Safety Act generally
            else if (provision.toLowerCase().includes('road safety act') || provision.toLowerCase().includes('rsa')) {
              report.plainText = 'Road Safety Act 1986 (Vic) - Comprehensive traffic and road safety legislation governing driving offences, testing procedures, and evidentiary requirements.';
              report.applicationToFacts = 'Road Safety Act provides statutory framework for breath testing regime. Key provisions: Part 5 (drink and drug driving), ss.49-56 (testing procedures), evidentiary provisions.';
              report.requirementsSatisfied = 'REQUIRES ANALYSIS - multiple provisions may apply';
              report.recommendedArgument = 'Apply purposive construction per Interpretation Act 1984 (Vic) s.35(a). RSA balances road safety objectives with procedural protections for accused. Strict compliance with testing procedures required to advance protective purpose.';
            }

            // Default report for other provisions
            else {
              report.plainText = `Statutory provision: ${provision}`;
              report.applicationToFacts = 'Analyze how provision applies to facts in documents. Determine whether statutory requirements satisfied.';
              report.requirementsSatisfied = 'REQUIRES DETAILED ANALYSIS';
              report.recommendedArgument = 'Apply modern interpretative approach: examine text (literal meaning), context (statutory scheme), and purpose (legislative intention). Prefer interpretation advancing statutory purpose.';
            }

            return report;
          };

          /**
           * MAIN STATUTORY INTERPRETATION FUNCTION - PHASE C
           * Orchestrates all interpretation analyses
           */
          const performStatutoryInterpretation = (phaseAResults, phaseBResults) => {
            // Extract key statutory provisions from both phases
            const allStatutoryRefs = [];

            phaseAResults.fileA.forEach(analysis => {
              analysis.findings.legalReferences.forEach(ref => {
                if (ref.type === 'Act Citation' || ref.type === 'Section Reference') {
                  allStatutoryRefs.push({ ref: ref.text, source: 'File A' });
                }
              });
            });

            phaseAResults.fileB.forEach(analysis => {
              analysis.findings.legalReferences.forEach(ref => {
                if (ref.type === 'Act Citation' || ref.type === 'Section Reference') {
                  allStatutoryRefs.push({ ref: ref.text, source: 'File B' });
                }
              });
            });

            // Apply Interpretation Act 1984 (Vic) rules
            const interpretationActAnalysis = {
              section35aPurposive: allStatutoryRefs.slice(0, 5).map(item =>
                applyPurposiveConstruction(item.ref, `Found in ${item.source}`)
              ),
              section36ExtrinsicMaterials: []
            };

            // Identify ambiguous provisions needing extrinsic materials
            const ambiguousPhrases = ['reason to believe', 'in accordance with', 'directions', 'as soon as practicable', 'satisfied that'];
            ambiguousPhrases.forEach(phrase => {
              const extrinsicAnalysis = identifyExtrinsicMaterialsNeeded(
                allStatutoryRefs[0]?.ref || 'Road Safety Act provisions',
                phrase
              );
              if (extrinsicAnalysis.isAmbiguous) {
                interpretationActAnalysis.section36ExtrinsicMaterials.push(extrinsicAnalysis);
              }
            });

            // Apply common law maxims
            const commonLawMaxims = {
              nosciturASociis: [
                applyNosciturASociis('reason to believe', 's.49 RSA context'),
                applyNosciturASociis('in accordance with', 's.55D RSA context'),
                applyNosciturASociis('directions', 's.55D RSA context')
              ],
              expressioUnius: [
                applyExpressioUnius('s.49(1)(a)-(h) RSA - circumstances authorizing preliminary breath test'),
                applyExpressioUnius('approved devices and prescribed procedures')
              ],
              generaliaSpecialibus: [
                applyGeneraliaSpecialibus('General police testing powers', 's.49 RSA specific preliminary test requirements'),
                applyGeneraliaSpecialibus('General testing provisions', 's.55D-55E RSA specific breath test directions')
              ],
              ejusdemGeneris: [
                applyEjusdemGeneris(['driving', 'in charge of', 'operating'], 'other similar control of vehicle')
              ]
            };

            // Build comprehensive ambiguity resolver
            const ambiguityResolutions = [
              resolveAmbiguity('reason to believe', fileContents.fileA + fileContents.fileB, 's.49 Road Safety Act'),
              resolveAmbiguity('in accordance with directions', fileContents.fileA + fileContents.fileB, 's.55D Road Safety Act'),
              resolveAmbiguity('directions', fileContents.fileA + fileContents.fileB, 's.55D(2) Road Safety Act')
            ];

            // Create harmonization analysis for conflicts
            const conflicts = [
              ...phaseBResults.discrepancies,
              ...phaseBResults.omissions
            ];
            const harmonizationAnalysis = harmonizeConflicts(conflicts, phaseAResults, phaseBResults);

            // Generate detailed provision reports
            const provisionReports = [
              generateProvisionReport('s.49 Road Safety Act 1986 (Vic)', fileContents.fileA, phaseAResults.fileA),
              generateProvisionReport('s.55D Road Safety Act 1986 (Vic)', fileContents.fileA, phaseAResults.fileA),
              generateProvisionReport('s.49 Road Safety Act 1986 (Vic)', fileContents.fileB, phaseAResults.fileB),
              generateProvisionReport('s.55D Road Safety Act 1986 (Vic)', fileContents.fileB, phaseAResults.fileB)
            ];

            return {
              interpretationAct1984: interpretationActAnalysis,
              commonLawMaxims: commonLawMaxims,
              ambiguityResolver: ambiguityResolutions,
              harmonization: harmonizationAnalysis,
              provisionReports: provisionReports,

              // Legacy compatibility - keep existing structure
              literalInterpretation: {
                approach: 'Textualist/Literal Analysis',
                findings: 'Plain meaning interpretation applied. See detailed provision reports for literal interpretation of key requirements.'
              },
              contextualInterpretation: {
                approach: 'Contextual Analysis',
                findings: 'Provisions interpreted within statutory context. See common law maxims (noscitur a sociis) for contextual analysis.'
              },
              purposiveInterpretation: {
                approach: 'Interpretation Act 1984 (Vic) s.35(a) - Purposive Construction',
                findings: 'Legislative purpose analyzed for each provision. See Section 35(a) analysis for detailed purposive interpretation.'
              },
              extrinsicAids: {
                availableAids: interpretationActAnalysis.section36ExtrinsicMaterials.length > 0
                  ? interpretationActAnalysis.section36ExtrinsicMaterials[0].suggestedMaterials
                  : ['Second reading speeches', 'Explanatory memoranda', 'Parliamentary debates', 'Prior judicial interpretation'],
                application: 'Per Interpretation Act 1984 (Vic) s.36, extrinsic materials may be consulted to confirm meaning or resolve ambiguity.'
              },
              interpretativePrinciples: [
                { principle: 'Interpretation Act 1984 (Vic) s.35(a)', application: 'Purposive construction - interpretation advancing legislative purpose preferred' },
                { principle: 'Interpretation Act 1984 (Vic) s.36', application: 'Extrinsic materials may be used to resolve ambiguity' },
                { principle: 'Noscitur a sociis', application: 'Words known by their company - interpret in context' },
                { principle: 'Expressio unius est exclusio alterius', application: 'Express mention excludes others' },
                { principle: 'Generalia specialibus non derogant', application: 'Specific provisions prevail over general' },
                { principle: 'Ejusdem generis', application: 'General words limited by specific examples' }
              ]
            };
          };

          const generateExecutiveSummary = (phaseA, phaseB, phaseC) => {
            const totalIssuesA = phaseA.fileA.reduce((sum, analysis) => sum + analysis.findings.potentialIssues.length, 0);
            const totalIssuesB = phaseA.fileB.reduce((sum, analysis) => sum + analysis.findings.potentialIssues.length, 0);
            
            return {
              overallAssessment: totalIssuesA + totalIssuesB === 0 ? 'No Critical Issues Identified' : 'Issues Requiring Attention Identified',
              criticalFindings: [
                `File A: ${totalIssuesA} potential issues identified across ${interpretivePresets.length} analytical presets`,
                `File B: ${totalIssuesB} potential issues identified across ${interpretivePresets.length} analytical presets`,
                `Cross-reference analysis: ${phaseB.discrepancies.length} discrepancies, ${phaseB.omissions.length} omissions`,
                `Governing framework: ${phaseB.governingFramework.length} statutory instruments identified`
              ],
              recommendations: [
                'Review all identified discrepancies for potential procedural defects',
                'Verify compliance with mandatory statutory requirements',
                'Consider extrinsic materials for ambiguity resolution where necessary',
                'Cross-check all statutory references against current legislation',
                'Ensure harmonious interpretation between documents where possible'
              ],
              nextSteps: [
                'Detailed review of high-severity issues',
                'Consultation of relevant case law for interpretative guidance',
                'Preparation of submissions addressing identified defects',
                'Verification of all factual assertions against evidence'
              ]
            };
          };

          const toggleSection = (sectionId) => {
            setExpandedSections(prev => ({
              ...prev,
              [sectionId]: !prev[sectionId]
            }));
          };

          const exportReport = () => {
            if (!analysisResults) return;
            
            const report = {
              timestamp: new Date().toISOString(),
              files: {
                fileA: files.fileA?.name,
                fileB: files.fileB?.name
              },
              analysis: analysisResults
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `forensic-analysis-${Date.now()}.json`;
            a.click();
          };

          // Progress Bar Component
          const ProgressBar = ({ progress, label, showPercentage = true }) => (
            <div style={{ width: '100%', marginBottom: '12px' }}>
              {label && (
                <div style={{
                  display: 'flex',
                  justifyContent: 'space-between',
                  marginBottom: '6px',
                  fontSize: '13px',
                  color: '#374151'
                }}>
                  <span>{label}</span>
                  {showPercentage && <span>{progress}%</span>}
                </div>
              )}
              <div style={{
                width: '100%',
                height: '8px',
                backgroundColor: '#e5e7eb',
                borderRadius: '4px',
                overflow: 'hidden',
                position: 'relative'
              }}>
                <div
                  className="fade-in"
                  style={{
                    width: `${progress}%`,
                    height: '100%',
                    background: 'linear-gradient(to right, #2563eb, #1d4ed8)',
                    borderRadius: '4px',
                    transition: 'width 0.3s ease-in-out',
                    position: 'relative',
                    overflow: 'hidden'
                  }}
                >
                  <div style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: 'linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)',
                    animation: 'shimmer 1.5s infinite'
                  }} />
                </div>
              </div>
            </div>
          );

          // Skeleton Loader Component
          const SkeletonLoader = ({ width = '100%', height = '20px', style = {} }) => (
            <div
              className="skeleton"
              style={{
                width,
                height,
                ...style
              }}
            />
          );

          // Enhanced Badge Component
          const Badge = ({ children, variant = 'default', size = 'md' }) => {
            const variants = {
              default: { bg: '#f3f4f6', color: '#374151' },
              success: { bg: '#dcfce7', color: '#166534' },
              warning: { bg: '#fef3c7', color: '#92400e' },
              error: { bg: '#fee2e2', color: '#991b1b' },
              info: { bg: '#dbeafe', color: '#1e40af' },
              primary: { bg: '#eff6ff', color: '#1e40af' }
            };

            const sizes = {
              sm: { padding: '2px 6px', fontSize: '11px' },
              md: { padding: '4px 10px', fontSize: '12px' },
              lg: { padding: '6px 14px', fontSize: '14px' }
            };

            const variantStyle = variants[variant] || variants.default;
            const sizeStyle = sizes[size] || sizes.md;

            return (
              <span style={{
                display: 'inline-block',
                ...sizeStyle,
                backgroundColor: variantStyle.bg,
                color: variantStyle.color,
                borderRadius: '9999px',
                fontWeight: '600',
                whiteSpace: 'nowrap'
              }}>
                {children}
              </span>
            );
          };

          const FileUploadZone = ({ fileKey, label }) => (
            <div style={{
              backgroundColor: 'white',
              borderRadius: '8px',
              boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
              padding: '24px',
              border: '2px dashed #d1d5db',
              transition: 'border-color 0.2s'
            }}>
              <div style={{ textAlign: 'center' }}>
                <div style={{ fontSize: '48px', marginBottom: '16px' }}>üìÑ</div>
                <h3 style={{ fontSize: '18px', fontWeight: '600', marginBottom: '8px' }}>{label}</h3>
                
                {isUploading[fileKey] ? (
                  <div className="fade-in" style={{ padding: '16px' }}>
                    <div style={{
                      fontSize: '32px',
                      marginBottom: '16px',
                      textAlign: 'center',
                      className: 'pulse'
                    }}>üì§</div>
                    <ProgressBar
                      progress={uploadProgress[fileKey]}
                      label="Uploading file..."
                      showPercentage={true}
                    />
                  </div>
                ) : !files[fileKey] ? (
                  <>
                    <div
                      onDragOver={handleDragOver}
                      onDrop={(e) => handleDrop(e, fileKey)}
                      style={{
                        marginBottom: '16px',
                        padding: '32px',
                        backgroundColor: '#f9fafb',
                        borderRadius: '8px'
                      }}
                    >
                      <p style={{ fontSize: '14px', color: '#6b7280', marginBottom: '8px' }}>Drag and drop file here</p>
                      <p style={{ fontSize: '12px', color: '#9ca3af' }}>or</p>
                    </div>

                    <button
                      onClick={() => fileKey === 'fileA' ? fileInputA.current.click() : fileInputB.current.click()}
                      style={{
                        backgroundColor: '#2563eb',
                        color: 'white',
                        padding: '8px 16px',
                        borderRadius: '8px',
                        border: 'none',
                        cursor: 'pointer',
                        width: '100%',
                        marginBottom: '8px',
                        fontSize: '14px',
                        fontWeight: '500'
                      }}
                    >
                      ‚¨ÜÔ∏è Choose File
                    </button>

                    <p style={{
                      fontSize: '11px',
                      color: '#6b7280',
                      textAlign: 'center',
                      marginBottom: '8px',
                      lineHeight: '1.4'
                    }}>
                      Supports: PDF, Images (OCR), Text files
                    </p>

                    <div style={{ marginTop: '16px' }}>
                      <input
                        type="text"
                        placeholder="Or paste URL to document"
                        style={{
                          width: '100%',
                          padding: '8px 12px',
                          border: '1px solid #d1d5db',
                          borderRadius: '8px',
                          fontSize: '14px'
                        }}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter' && e.target.value) {
                            handleUrlUpload(e.target.value, fileKey);
                          }
                        }}
                      />
                    </div>
                    
                    <input
                      type="file"
                      ref={fileKey === 'fileA' ? fileInputA : fileInputB}
                      onChange={(e) => handleFileUpload(e.target.files[0], fileKey)}
                      style={{ display: 'none' }}
                      accept=".txt,.doc,.docx,.pdf,.png,.jpg,.jpeg,.gif,.bmp,.tiff,image/*"
                    />
                  </>
                ) : (
                  <div className="fade-in" style={{
                    backgroundColor: '#f0fdf4',
                    padding: '16px',
                    borderRadius: '8px',
                    border: '1px solid #bbf7d0'
                  }}>
                    <div style={{
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      marginBottom: '8px'
                    }}>
                      <div style={{ display: 'flex', alignItems: 'center', flex: 1 }}>
                        <span style={{ fontSize: '20px', marginRight: '8px' }}>‚úÖ</span>
                        <div style={{ flex: 1 }}>
                          <div style={{
                            fontSize: '14px',
                            fontWeight: '600',
                            color: '#166534',
                            marginBottom: '4px'
                          }}>
                            {files[fileKey].name}
                          </div>
                          {files[fileKey].documentType && (
                            <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                              <Badge variant="success" size="sm">
                                {files[fileKey].documentType}
                              </Badge>
                              {files[fileKey].size && (
                                <span style={{ fontSize: '11px', color: '#6b7280' }}>
                                  {(files[fileKey].size / 1024).toFixed(1)} KB
                                </span>
                              )}
                            </div>
                          )}
                        </div>
                      </div>
                      <button
                        onClick={() => {
                          setFiles(prev => ({ ...prev, [fileKey]: null }));
                          setFileContents(prev => ({ ...prev, [fileKey]: '' }));
                        }}
                        style={{
                          color: '#dc2626',
                          fontSize: '13px',
                          background: 'none',
                          border: 'none',
                          cursor: 'pointer',
                          padding: '4px 8px',
                          fontWeight: '500'
                        }}
                        aria-label={`Remove ${files[fileKey].name}`}
                      >
                        ‚úï Remove
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );

          const AnalysisSection = ({ title, children, sectionId }) => {
            const isExpanded = expandedSections[sectionId];

            return (
              <div
                className="fade-in"
                style={{
                  backgroundColor: 'white',
                  borderRadius: '8px',
                  boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
                  marginBottom: '16px',
                  overflow: 'hidden'
                }}
              >
                <button
                  onClick={() => toggleSection(sectionId)}
                  style={{
                    width: '100%',
                    padding: '24px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    background: isExpanded ? '#f9fafb' : 'none',
                    border: 'none',
                    cursor: 'pointer',
                    fontSize: '18px',
                    fontWeight: '600',
                    textAlign: 'left'
                  }}
                  aria-expanded={isExpanded}
                  aria-controls={`section-${sectionId}`}
                  role="button"
                  tabIndex={0}
                  onKeyPress={(e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                      e.preventDefault();
                      toggleSection(sectionId);
                    }
                  }}
                >
                  <span>{title}</span>
                  <span
                    style={{
                      fontSize: '14px',
                      transition: 'transform 0.2s ease-in-out',
                      transform: isExpanded ? 'rotate(0deg)' : 'rotate(-90deg)'
                    }}
                  >
                    ‚ñº
                  </span>
                </button>

                {isExpanded && (
                  <div
                    id={`section-${sectionId}`}
                    className="fade-in"
                    style={{
                      padding: '0 24px 24px',
                      borderTop: '1px solid #e5e7eb'
                    }}
                    role="region"
                    aria-labelledby={`section-${sectionId}-title`}
                  >
                    {children}
                  </div>
                )}
              </div>
            );
          };

          return (
            <div style={{
              minHeight: '100vh',
              background: 'linear-gradient(to bottom right, #eff6ff, #f3f4f6)',
              padding: '24px'
            }}>
              <div style={{ maxWidth: '1280px', margin: '0 auto' }}>
                <div style={{
                  backgroundColor: 'white',
                  borderRadius: '12px',
                  boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                  padding: '32px',
                  marginBottom: '24px'
                }}>
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    marginBottom: '24px'
                  }}>
                    <div>
                      <h1 style={{
                        fontSize: '30px',
                        fontWeight: 'bold',
                        color: '#111827',
                        marginBottom: '8px'
                      }}>
                        Forensic Legal Document Analyzer
                      </h1>
                      <p style={{ color: '#6b7280' }}>
                        Multi-Layered Interpretive Analysis System for Evidentiary Documents
                      </p>
                    </div>
                    <div style={{ fontSize: '48px' }}>üëÅÔ∏è</div>
                  </div>

                  <div style={{
                    backgroundColor: '#eff6ff',
                    borderLeft: '4px solid #2563eb',
                    padding: '16px',
                    marginBottom: '24px'
                  }}>
                    <h3 style={{
                      fontWeight: '600',
                      color: '#1e3a8a',
                      marginBottom: '8px'
                    }}>System Capabilities:</h3>
                    <ul style={{
                      fontSize: '14px',
                      color: '#1e40af',
                      listStyle: 'none',
                      padding: 0
                    }}>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Phase A: Multi-preset forensic examination using {interpretivePresets.length} interpretive frameworks</li>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Phase B: Statutory framework identification and cross-reference analysis</li>
                      <li style={{ marginBottom: '4px' }}>‚Ä¢ Phase C: Comprehensive statutory interpretation applying modern purposive approach</li>
                      <li>‚Ä¢ Identifies legal flaws, factual inconsistencies, and procedural defects</li>
                    </ul>
                  </div>

                  <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
                    gap: '24px',
                    marginBottom: '24px'
                  }}>
                    <FileUploadZone fileKey="fileA" label="Document A (Primary Exhibit)" />
                    <FileUploadZone fileKey="fileB" label="Document B (Comparative Exhibit)" />
                  </div>

                  <div>
                    <button
                      onClick={simulateAnalysis}
                      disabled={!files.fileA || !files.fileB || analysisState === 'analyzing'}
                      style={{
                        width: '100%',
                        background: (!files.fileA || !files.fileB || analysisState === 'analyzing')
                          ? '#9ca3af'
                          : 'linear-gradient(to right, #2563eb, #1d4ed8)',
                        color: 'white',
                        padding: '16px',
                        borderRadius: '8px',
                        fontSize: '18px',
                        fontWeight: '600',
                        border: 'none',
                        cursor: (!files.fileA || !files.fileB || analysisState === 'analyzing') ? 'not-allowed' : 'pointer',
                        boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                        marginBottom: analysisState === 'analyzing' ? '12px' : '0'
                      }}
                      aria-label={analysisState === 'analyzing' ? 'Analysis in progress' : 'Start forensic analysis'}
                    >
                      {analysisState === 'analyzing' ? (
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                          <span className="spin">‚åõ</span>
                          <span>{currentPhase}</span>
                        </div>
                      ) : (
                        <>‚ö†Ô∏è Commence Forensic Analysis</>
                      )}
                    </button>
                    {analysisState === 'analyzing' && (
                      <div className="fade-in">
                        <ProgressBar
                          progress={analysisProgress}
                          showPercentage={true}
                        />
                      </div>
                    )}
                  </div>
                </div>

                {analysisResults && (
                  <div>
                    <div style={{
                      backgroundColor: 'white',
                      borderRadius: '12px',
                      boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
                      padding: '24px',
                      marginBottom: '16px'
                    }}>
                      <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        marginBottom: '16px'
                      }}>
                        <h2 style={{
                          fontSize: '24px',
                          fontWeight: 'bold',
                          color: '#111827'
                        }}>Analysis Report</h2>
                        <button
                          onClick={exportReport}
                          style={{
                            display: 'flex',
                            alignItems: 'center',
                            padding: '8px 16px',
                            backgroundColor: '#16a34a',
                            color: 'white',
                            borderRadius: '8px',
                            border: 'none',
                            cursor: 'pointer',
                            fontSize: '14px'
                          }}
                        >
                          ‚¨áÔ∏è Export Report
                        </button>
                      </div>

                      <div style={{
                        backgroundColor: '#fef3c7',
                        borderLeft: '4px solid #f59e0b',
                        padding: '16px',
                        marginBottom: '24px'
                      }}>
                        <h3 style={{
                          fontWeight: '600',
                          color: '#78350f',
                          marginBottom: '8px'
                        }}>Executive Summary</h3>
                        <p style={{
                          fontSize: '14px',
                          color: '#92400e',
                          marginBottom: '12px'
                        }}>
                          <strong>Overall Assessment:</strong> {analysisResults.summary.overallAssessment}
                        </p>
                        <div style={{ fontSize: '14px', color: '#92400e' }}>
                          <strong>Critical Findings:</strong>
                          <ul style={{ marginTop: '8px', paddingLeft: '20px' }}>
                            {analysisResults.summary.criticalFindings.map((finding, idx) => (
                              <li key={idx} style={{ marginBottom: '4px' }}>{finding}</li>
                            ))}
                          </ul>
                        </div>
                      </div>

                      {/* Visual Statistics Dashboard */}
                      <div className="fade-in" style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                        gap: '16px',
                        marginBottom: '24px'
                      }}>
                        {(() => {
                          const countIssuesBySeverity = (severity) => {
                            let count = 0;
                            ['fileA', 'fileB'].forEach(fileKey => {
                              if (analysisResults.phaseA[fileKey]) {
                                analysisResults.phaseA[fileKey].forEach(preset => {
                                  const issues = preset.findings.potentialIssues;
                                  if (Array.isArray(issues)) {
                                    count += issues.filter(i => i.severity === severity).length;
                                  }
                                });
                              }
                            });
                            return count;
                          };

                          const totalIssues = ['critical', 'high', 'medium', 'low']
                            .reduce((sum, severity) => sum + countIssuesBySeverity(severity), 0);

                          const stats = [
                            {
                              label: 'Critical Issues',
                              value: countIssuesBySeverity('critical'),
                              icon: 'üî¥',
                              color: '#fee2e2',
                              textColor: '#991b1b'
                            },
                            {
                              label: 'High Priority',
                              value: countIssuesBySeverity('high'),
                              icon: 'üü°',
                              color: '#fef3c7',
                              textColor: '#92400e'
                            },
                            {
                              label: 'Medium Priority',
                              value: countIssuesBySeverity('medium'),
                              icon: 'üîµ',
                              color: '#dbeafe',
                              textColor: '#1e40af'
                            },
                            {
                              label: 'Total Issues',
                              value: totalIssues,
                              icon: 'üìä',
                              color: '#f3f4f6',
                              textColor: '#374151'
                            }
                          ];

                          return stats.map((stat, idx) => (
                            <div
                              key={idx}
                              style={{
                                backgroundColor: stat.color,
                                padding: '20px',
                                borderRadius: '12px',
                                border: '1px solid rgba(0,0,0,0.1)',
                                textAlign: 'center'
                              }}
                            >
                              <div style={{ fontSize: '32px', marginBottom: '8px' }}>
                                {stat.icon}
                              </div>
                              <div style={{
                                fontSize: '28px',
                                fontWeight: 'bold',
                                color: stat.textColor,
                                marginBottom: '4px'
                              }}>
                                {stat.value}
                              </div>
                              <div style={{
                                fontSize: '13px',
                                fontWeight: '500',
                                color: stat.textColor,
                                opacity: 0.8
                              }}>
                                {stat.label}
                              </div>
                            </div>
                          ));
                        })()}
                      </div>
                    </div>

                    <AnalysisSection title="Phase A: Multi-Preset Forensic Examination" sectionId="phaseA">
                      <div style={{ marginTop: '16px' }}>
                        <div>
                          <h4 style={{
                            fontWeight: '600',
                            fontSize: '18px',
                            marginBottom: '12px'
                          }}>Document A Analysis</h4>
                          {analysisResults.phaseA.fileA.map((analysis, idx) => (
                            <div key={idx} style={{
                              backgroundColor: '#f9fafb',
                              padding: '16px',
                              borderRadius: '8px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#1e40af',
                                marginBottom: '8px'
                              }}>{analysis.preset}</h5>
                              <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                                gap: '16px',
                                fontSize: '14px'
                              }}>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Word Count:</strong> {analysis.findings.wordCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Line Count:</strong> {analysis.findings.lineCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Key Terms:</strong> {analysis.findings.keyTermsIdentified.length}</p>
                                </div>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Legal References:</strong> {analysis.findings.legalReferences.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Procedural Elements:</strong> {analysis.findings.proceduralElements.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Potential Issues:</strong> {analysis.findings.potentialIssues.length}</p>
                                </div>
                              </div>
                              {analysis.findings.potentialIssues.length > 0 && (
                                <div style={{
                                  marginTop: '12px',
                                  padding: '12px',
                                  backgroundColor: '#fef2f2',
                                  borderRadius: '4px',
                                  borderLeft: '4px solid #dc2626'
                                }}>
                                  <strong style={{ color: '#7f1d1d' }}>Issues Identified:</strong>
                                  <ul style={{
                                    marginTop: '8px',
                                    fontSize: '14px',
                                    color: '#991b1b',
                                    paddingLeft: '20px'
                                  }}>
                                    {analysis.findings.potentialIssues.map((issue, i) => (
                                      <li key={i} style={{ marginBottom: '4px' }}>
                                        [{issue.severity.toUpperCase()}] {issue.type}: {issue.description}
                                      </li>
                                    ))}
                                  </ul>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>

                        <div style={{ marginTop: '24px' }}>
                          <h4 style={{
                            fontWeight: '600',
                            fontSize: '18px',
                            marginBottom: '12px'
                          }}>Document B Analysis</h4>
                          {analysisResults.phaseA.fileB.map((analysis, idx) => (
                            <div key={idx} style={{
                              backgroundColor: '#f9fafb',
                              padding: '16px',
                              borderRadius: '8px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '500',
                                color: '#1e40af',
                                marginBottom: '8px'
                              }}>{analysis.preset}</h5>
                              <div style={{
                                display: 'grid',
                                gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
                                gap: '16px',
                                fontSize: '14px'
                              }}>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Word Count:</strong> {analysis.findings.wordCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Line Count:</strong> {analysis.findings.lineCount}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Key Terms:</strong> {analysis.findings.keyTermsIdentified.length}</p>
                                </div>
                                <div>
                                  <p style={{ color: '#6b7280' }}><strong>Legal References:</strong> {analysis.findings.legalReferences.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Procedural Elements:</strong> {analysis.findings.proceduralElements.length}</p>
                                  <p style={{ color: '#6b7280' }}><strong>Potential Issues:</strong> {analysis.findings.potentialIssues.length}</p>
                                </div>
                              </div>
                              {analysis.findings.potentialIssues.length > 0 && (
                                <div style={{
                                  marginTop: '12px',
                                  padding: '12px',
                                  backgroundColor: '#fef2f2',
                                  borderRadius: '4px',
                                  borderLeft: '4px solid #dc2626'
                                }}>
                                  <strong style={{ color: '#7f1d1d' }}>Issues Identified:</strong>
                                  <ul style={{
                                    marginTop: '8px',
                                    fontSize: '14px',
                                    color: '#991b1b',
                                    paddingLeft: '20px'
                                  }}>
                                    {analysis.findings.potentialIssues.map((issue, i) => (
                                      <li key={i} style={{ marginBottom: '4px' }}>
                                        [{issue.severity.toUpperCase()}] {issue.type}: {issue.description}
                                      </li>
                                    ))}
                                  </ul>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      </div>
                    </AnalysisSection>

                    <AnalysisSection title="Phase B: Victorian Criminal Compliance & Statutory Cross-Reference Analysis" sectionId="phaseB">
                      <div style={{ marginTop: '16px' }}>
                        <div style={{
                          backgroundColor: '#eff6ff',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#1e40af',
                            marginBottom: '12px'
                          }}>Governing Statutory Framework</h4>
                          {analysisResults.phaseB.governingFramework.length > 0 ? (
                            <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                              {analysisResults.phaseB.governingFramework.map((framework, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: 'white',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  fontSize: '14px'
                                }}>
                                  <p style={{
                                    fontWeight: '500',
                                    color: '#111827'
                                  }}>{framework.statute}</p>
                                  <p style={{ color: '#6b7280' }}>
                                    Source: {framework.source} | {framework.applicability}
                                  </p>
                                </div>
                              ))}
                            </div>
                          ) : (
                            <p style={{ fontSize: '14px', color: '#6b7280' }}>
                              No explicit statutory framework identified in documents
                            </p>
                          )}
                        </div>

                        {analysisResults.phaseB.discrepancies.length > 0 && (
                          <div style={{
                            backgroundColor: '#fef2f2',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #dc2626',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#7f1d1d',
                              marginBottom: '12px'
                            }}>Discrepancies Identified</h4>
                            <ul style={{ paddingLeft: '20px' }}>
                              {analysisResults.phaseB.discrepancies.map((disc, idx) => (
                                <li key={idx} style={{
                                  fontSize: '14px',
                                  color: '#991b1b',
                                  marginBottom: '8px'
                                }}>
                                  <strong>[{disc.severity?.toUpperCase()}]</strong> {disc.type}: {disc.description}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        {analysisResults.phaseB.omissions.length > 0 && (
                          <div style={{
                            backgroundColor: '#fef3c7',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #f59e0b',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#78350f',
                              marginBottom: '12px'
                            }}>Omissions Detected</h4>
                            <ul style={{ paddingLeft: '20px' }}>
                              {analysisResults.phaseB.omissions.slice(0, 10).map((omission, idx) => (
                                <li key={idx} style={{
                                  fontSize: '14px',
                                  color: '#92400e',
                                  marginBottom: '8px'
                                }}>
                                  {omission.type}: <strong>{omission.element}</strong> - {omission.status}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        {analysisResults.phaseB.consistencies.length > 0 && (
                          <div style={{
                            backgroundColor: '#f0fdf4',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #16a34a',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#14532d',
                              marginBottom: '12px'
                            }}>Consistencies Confirmed</h4>
                            <ul style={{ paddingLeft: '20px' }}>
                              {analysisResults.phaseB.consistencies.map((cons, idx) => (
                                <li key={idx} style={{
                                  fontSize: '14px',
                                  color: '#166534',
                                  marginBottom: '8px'
                                }}>
                                  {cons.type}: <strong>{cons.element}</strong> - {cons.status}
                                </li>
                              ))}
                            </ul>
                          </div>
                        )}

                        {/* Victorian Criminal Summary Matters Compliance */}
                        {analysisResults.phaseB.victorianCompliance && (
                          <div style={{
                            backgroundColor: '#f5f3ff',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #7c3aed',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#5b21b6',
                              marginBottom: '12px'
                            }}>Victorian Criminal Summary Matters Compliance</h4>
                            <p style={{
                              fontSize: '13px',
                              color: '#6b21a8',
                              marginBottom: '16px',
                              fontStyle: 'italic'
                            }}>
                              Comprehensive checks for CPA 2009 Part 3.3, RSA 1986, and Evidence Act 2008 (Vic)
                            </p>

                            {/* Document A Compliance */}
                            <div style={{ marginBottom: '16px' }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#1e40af',
                                fontSize: '14px',
                                marginBottom: '8px'
                              }}>Document A Compliance Issues</h5>
                              {analysisResults.phaseB.victorianCompliance.fileA.length > 0 ? (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                  {analysisResults.phaseB.victorianCompliance.fileA.map((issue, idx) => (
                                    <div key={idx} style={{
                                      backgroundColor: 'white',
                                      padding: '12px',
                                      borderRadius: '4px',
                                      borderLeft: `4px solid ${
                                        issue.severity === 'critical' ? '#dc2626' :
                                        issue.severity === 'high' ? '#ea580c' :
                                        issue.severity === 'medium' ? '#f59e0b' : '#84cc16'
                                      }`
                                    }}>
                                      <p style={{
                                        fontSize: '13px',
                                        fontWeight: '600',
                                        color: issue.severity === 'critical' ? '#7f1d1d' :
                                               issue.severity === 'high' ? '#9a3412' :
                                               issue.severity === 'medium' ? '#78350f' : '#365314',
                                        marginBottom: '4px'
                                      }}>
                                        [{issue.severity.toUpperCase()}] {issue.statute}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                                        <strong>Section:</strong> {issue.section}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}>
                                        <strong>Defect:</strong> {issue.defect}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#4b5563' }}>
                                        <strong>Remediation:</strong> {issue.remediation}
                                      </p>
                                    </div>
                                  ))}
                                </div>
                              ) : (
                                <p style={{ fontSize: '13px', color: '#10b981' }}>
                                  ‚úÖ No compliance issues detected in Document A
                                </p>
                              )}
                            </div>

                            {/* Document B Compliance */}
                            <div>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#1e40af',
                                fontSize: '14px',
                                marginBottom: '8px'
                              }}>Document B Compliance Issues</h5>
                              {analysisResults.phaseB.victorianCompliance.fileB.length > 0 ? (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                  {analysisResults.phaseB.victorianCompliance.fileB.map((issue, idx) => (
                                    <div key={idx} style={{
                                      backgroundColor: 'white',
                                      padding: '12px',
                                      borderRadius: '4px',
                                      borderLeft: `4px solid ${
                                        issue.severity === 'critical' ? '#dc2626' :
                                        issue.severity === 'high' ? '#ea580c' :
                                        issue.severity === 'medium' ? '#f59e0b' : '#84cc16'
                                      }`
                                    }}>
                                      <p style={{
                                        fontSize: '13px',
                                        fontWeight: '600',
                                        color: issue.severity === 'critical' ? '#7f1d1d' :
                                               issue.severity === 'high' ? '#9a3412' :
                                               issue.severity === 'medium' ? '#78350f' : '#365314',
                                        marginBottom: '4px'
                                      }}>
                                        [{issue.severity.toUpperCase()}] {issue.statute}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                                        <strong>Section:</strong> {issue.section}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}>
                                        <strong>Defect:</strong> {issue.defect}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#4b5563' }}>
                                        <strong>Remediation:</strong> {issue.remediation}
                                      </p>
                                    </div>
                                  ))}
                                </div>
                              ) : (
                                <p style={{ fontSize: '13px', color: '#10b981' }}>
                                  ‚úÖ No compliance issues detected in Document B
                                </p>
                              )}
                            </div>
                          </div>
                        )}

                        {/* Enhanced Omissions Report */}
                        {analysisResults.phaseB.omissionsReport && (
                          <div style={{
                            backgroundColor: '#fff7ed',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #ea580c',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#9a3412',
                              marginBottom: '12px'
                            }}>Comprehensive Omissions Report: Doc A vs Doc B</h4>

                            {/* Critical Victorian Criminal Requirements Omissions */}
                            {analysisResults.phaseB.omissionsReport.criticalOmissions.victorianCriminalRequirements.length > 0 && (
                              <div style={{ marginBottom: '16px' }}>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#dc2626',
                                  fontSize: '14px',
                                  marginBottom: '8px'
                                }}>üî¥ CRITICAL: Victorian Criminal Requirements</h5>
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                                  {analysisResults.phaseB.omissionsReport.criticalOmissions.victorianCriminalRequirements.map((omission, idx) => (
                                    <div key={idx} style={{
                                      backgroundColor: 'white',
                                      padding: '12px',
                                      borderRadius: '4px',
                                      borderLeft: '4px solid #dc2626'
                                    }}>
                                      <p style={{ fontSize: '13px', fontWeight: '600', color: '#7f1d1d', marginBottom: '4px' }}>
                                        {omission.element}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#6b7280', marginBottom: '4px' }}>
                                        <strong>Statute:</strong> {omission.statute}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#374151', marginBottom: '4px' }}>
                                        <strong>Present in:</strong> {omission.inDocument} | <strong>Omitted from:</strong> {omission.omittedFrom}
                                      </p>
                                      <p style={{ fontSize: '12px', color: '#991b1b' }}>
                                        <strong>Impact:</strong> {omission.impact}
                                      </p>
                                    </div>
                                  ))}
                                </div>
                              </div>
                            )}

                            {/* Statutory References Omissions */}
                            {(analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.length > 0 ||
                              analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.length > 0) && (
                              <div style={{ marginBottom: '16px' }}>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#ea580c',
                                  fontSize: '14px',
                                  marginBottom: '8px'
                                }}>üìã Statutory References</h5>

                                {analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.length > 0 && (
                                  <div style={{ marginBottom: '8px' }}>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc A but not Doc B:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.statutoryReferences.inANotInB.map((ref, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {ref.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}

                                {analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.length > 0 && (
                                  <div>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc B but not Doc A:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.statutoryReferences.inBNotInA.map((ref, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {ref.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                              </div>
                            )}

                            {/* Procedural Elements Omissions */}
                            {(analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.length > 0 ||
                              analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.length > 0) && (
                              <div>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#ea580c',
                                  fontSize: '14px',
                                  marginBottom: '8px'
                                }}>‚öñÔ∏è Procedural Elements</h5>

                                {analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.length > 0 && (
                                  <div style={{ marginBottom: '8px' }}>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc A but not Doc B:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.proceduralElements.inANotInB.map((elem, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {elem.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}

                                {analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.length > 0 && (
                                  <div>
                                    <p style={{ fontSize: '12px', fontWeight: '600', color: '#78350f', marginBottom: '4px' }}>
                                      In Doc B but not Doc A:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', margin: 0 }}>
                                      {analysisResults.phaseB.omissionsReport.proceduralElements.inBNotInA.map((elem, idx) => (
                                        <li key={idx} style={{ fontSize: '12px', color: '#92400e', marginBottom: '2px' }}>
                                          {elem.element}
                                        </li>
                                      ))}
                                    </ul>
                                  </div>
                                )}
                              </div>
                            )}
                          </div>
                        )}

                        {/* Compliance Matrix Table */}
                        {analysisResults.phaseB.complianceMatrix && analysisResults.phaseB.complianceMatrix.length > 0 && (
                          <div style={{
                            backgroundColor: 'white',
                            padding: '16px',
                            borderRadius: '8px',
                            boxShadow: '0 1px 3px rgba(0,0,0,0.12)',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#111827',
                              marginBottom: '12px'
                            }}>üìä Statutory Compliance Matrix: Doc A vs Doc B</h4>
                            <p style={{
                              fontSize: '13px',
                              color: '#6b7280',
                              marginBottom: '12px'
                            }}>
                              <span style={{
                                display: 'inline-block',
                                padding: '2px 8px',
                                borderRadius: '4px',
                                backgroundColor: '#d1fae5',
                                color: '#065f46',
                                marginRight: '8px',
                                fontSize: '11px'
                              }}>GREEN = Compliant</span>
                              <span style={{
                                display: 'inline-block',
                                padding: '2px 8px',
                                borderRadius: '4px',
                                backgroundColor: '#fef3c7',
                                color: '#78350f',
                                marginRight: '8px',
                                fontSize: '11px'
                              }}>YELLOW = Unclear</span>
                              <span style={{
                                display: 'inline-block',
                                padding: '2px 8px',
                                borderRadius: '4px',
                                backgroundColor: '#fee2e2',
                                color: '#991b1b',
                                fontSize: '11px'
                              }}>RED = Non-Compliant</span>
                            </p>

                            <div style={{ overflowX: 'auto' }}>
                              <table style={{
                                width: '100%',
                                borderCollapse: 'collapse',
                                fontSize: '13px'
                              }}>
                                <thead>
                                  <tr style={{ backgroundColor: '#f3f4f6', borderBottom: '2px solid #e5e7eb' }}>
                                    <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}>
                                      Statutory Provision
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600' }}>
                                      Doc A Compliance
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600' }}>
                                      Doc B Compliance
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}>
                                      Discrepancies
                                    </th>
                                    <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600' }}>
                                      Action Required
                                    </th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {analysisResults.phaseB.complianceMatrix.map((row, idx) => (
                                    <tr key={idx} style={{ borderBottom: '1px solid #e5e7eb' }}>
                                      <td style={{ padding: '12px', verticalAlign: 'top' }}>
                                        <strong>{row.statute}</strong>
                                        <br />
                                        <span style={{ fontSize: '11px', color: '#6b7280' }}>
                                          {row.section}
                                        </span>
                                      </td>
                                      <td style={{ padding: '12px', textAlign: 'center', verticalAlign: 'top' }}>
                                        <span style={{
                                          display: 'inline-block',
                                          padding: '4px 12px',
                                          borderRadius: '12px',
                                          fontSize: '11px',
                                          fontWeight: '600',
                                          backgroundColor: row.docACompliance === 'compliant' ? '#d1fae5' :
                                                          row.docACompliance === 'unclear' ? '#fef3c7' : '#fee2e2',
                                          color: row.docACompliance === 'compliant' ? '#065f46' :
                                                 row.docACompliance === 'unclear' ? '#78350f' : '#991b1b'
                                        }}>
                                          {row.docACompliance === 'compliant' ? '‚úÖ Compliant' :
                                           row.docACompliance === 'unclear' ? '‚ö†Ô∏è Unclear' : '‚ùå Non-Compliant'}
                                        </span>
                                      </td>
                                      <td style={{ padding: '12px', textAlign: 'center', verticalAlign: 'top' }}>
                                        <span style={{
                                          display: 'inline-block',
                                          padding: '4px 12px',
                                          borderRadius: '12px',
                                          fontSize: '11px',
                                          fontWeight: '600',
                                          backgroundColor: row.docBCompliance === 'compliant' ? '#d1fae5' :
                                                          row.docBCompliance === 'unclear' ? '#fef3c7' : '#fee2e2',
                                          color: row.docBCompliance === 'compliant' ? '#065f46' :
                                                 row.docBCompliance === 'unclear' ? '#78350f' : '#991b1b'
                                        }}>
                                          {row.docBCompliance === 'compliant' ? '‚úÖ Compliant' :
                                           row.docBCompliance === 'unclear' ? '‚ö†Ô∏è Unclear' : '‚ùå Non-Compliant'}
                                        </span>
                                      </td>
                                      <td style={{ padding: '12px', verticalAlign: 'top', fontSize: '12px', color: '#374151' }}>
                                        {row.discrepancies.length > 0 ? (
                                          row.discrepancies.map((disc, dIdx) => (
                                            <div key={dIdx} style={{ marginBottom: '4px' }}>
                                              ‚ö†Ô∏è {disc}
                                            </div>
                                          ))
                                        ) : (
                                          <span style={{ color: '#6b7280' }}>No discrepancies</span>
                                        )}
                                      </td>
                                      <td style={{ padding: '12px', verticalAlign: 'top', fontSize: '12px' }}>
                                        <span style={{
                                          color: row.actionRequired.includes('URGENT') ? '#991b1b' :
                                                 row.actionRequired.includes('Review') ? '#92400e' : '#166534'
                                        }}>
                                          {row.actionRequired}
                                        </span>
                                      </td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        )}
                      </div>
                    </AnalysisSection>

                    <AnalysisSection title="üîó Cross-Reference Matrix" sectionId="crossReference">
                      <CrossReferenceMatrix analysis={analysisResults} />
                    </AnalysisSection>

                    <AnalysisSection title="Phase C: Statutory Interpretation & Legislative Purpose" sectionId="phaseC">
                      <div style={{ marginTop: '16px' }}>

                        {/* INTERPRETATION ACT 1984 (VIC) ANALYSIS */}
                        {analysisResults.phaseC.interpretationAct1984 && (
                          <div style={{
                            backgroundColor: '#dcfce7',
                            border: '2px solid #16a34a',
                            padding: '16px',
                            borderRadius: '8px',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '700',
                              color: '#14532d',
                              marginBottom: '16px',
                              fontSize: '16px'
                            }}>‚öñÔ∏è INTERPRETATION ACT 1984 (VIC) - VICTORIAN STATUTORY INTERPRETATION</h4>

                            {/* Section 35(a) - Purposive Construction */}
                            <div style={{
                              backgroundColor: 'white',
                              padding: '14px',
                              borderRadius: '6px',
                              marginBottom: '12px',
                              borderLeft: '4px solid #16a34a'
                            }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#166534',
                                marginBottom: '12px'
                              }}>Section 35(a) - Purposive Construction Analysis</h5>
                              {analysisResults.phaseC.interpretationAct1984.section35aPurposive.map((analysis, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: '#f9fafb',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  marginBottom: '10px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#111827', marginBottom: '8px' }}>
                                    üìã Provision: {analysis.provision}
                                  </p>
                                  <div style={{ marginLeft: '12px' }}>
                                    <p style={{ marginBottom: '6px' }}>
                                      <strong style={{ color: '#1e40af' }}>Parliamentary Intention:</strong><br/>
                                      <span style={{ color: '#374151' }}>{analysis.parliamentaryIntention}</span>
                                    </p>
                                    <p style={{ marginBottom: '6px' }}>
                                      <strong style={{ color: '#7c2d12' }}>Mischief Addressed:</strong><br/>
                                      <span style={{ color: '#374151' }}>{analysis.mischiefAddressed}</span>
                                    </p>
                                    <p style={{ marginBottom: '6px' }}>
                                      <strong style={{ color: '#166534' }}>Purpose Advanced:</strong><br/>
                                      <span style={{ color: '#374151' }}>{analysis.purposeAdvanced}</span>
                                    </p>
                                    <p style={{
                                      backgroundColor: '#fef3c7',
                                      padding: '8px',
                                      borderRadius: '4px',
                                      marginTop: '8px'
                                    }}>
                                      <strong style={{ color: '#78350f' }}>‚ö° Recommendation:</strong><br/>
                                      <span style={{ color: '#78350f' }}>{analysis.recommendation}</span>
                                    </p>
                                  </div>
                                </div>
                              ))}
                            </div>

                            {/* Section 36 - Extrinsic Materials */}
                            {analysisResults.phaseC.interpretationAct1984.section36ExtrinsicMaterials.length > 0 && (
                              <div style={{
                                backgroundColor: 'white',
                                padding: '14px',
                                borderRadius: '6px',
                                borderLeft: '4px solid #7c3aed'
                              }}>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#5b21b6',
                                  marginBottom: '12px'
                                }}>Section 36 - Extrinsic Materials Analysis</h5>
                                {analysisResults.phaseC.interpretationAct1984.section36ExtrinsicMaterials.map((ext, idx) => (
                                  <div key={idx} style={{
                                    backgroundColor: '#f5f3ff',
                                    padding: '12px',
                                    borderRadius: '4px',
                                    marginBottom: '10px',
                                    fontSize: '13px'
                                  }}>
                                    <p style={{ fontWeight: '600', color: '#6b21a8', marginBottom: '6px' }}>
                                      üîç Ambiguous Phrase: "{ext.provision}"
                                    </p>
                                    <p style={{ marginBottom: '6px' }}>
                                      <strong>Ambiguity Type:</strong> <Badge variant="warning" size="sm">{ext.ambiguityType}</Badge>
                                    </p>
                                    <p style={{ marginBottom: '8px', color: '#374151' }}>
                                      <strong>Application Guidance:</strong><br/>
                                      {ext.applicationGuidance}
                                    </p>
                                    <div style={{
                                      backgroundColor: 'white',
                                      padding: '10px',
                                      borderRadius: '4px'
                                    }}>
                                      <p style={{ fontWeight: '600', marginBottom: '6px', fontSize: '12px' }}>
                                        üìö Suggested Extrinsic Materials:
                                      </p>
                                      <ul style={{ paddingLeft: '20px', fontSize: '12px', color: '#6b7280' }}>
                                        {ext.suggestedMaterials.map((mat, midx) => (
                                          <li key={midx} style={{ marginBottom: '4px' }}>{mat}</li>
                                        ))}
                                      </ul>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            )}
                          </div>
                        )}

                        {/* COMMON LAW MAXIMS */}
                        {analysisResults.phaseC.commonLawMaxims && (
                          <div style={{
                            backgroundColor: '#fef3c7',
                            border: '2px solid #f59e0b',
                            padding: '16px',
                            borderRadius: '8px',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '700',
                              color: '#78350f',
                              marginBottom: '16px',
                              fontSize: '16px'
                            }}>üìö COMMON LAW INTERPRETATION MAXIMS APPLIED</h4>

                            {/* Noscitur a sociis */}
                            <div style={{
                              backgroundColor: 'white',
                              padding: '14px',
                              borderRadius: '6px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#92400e',
                                marginBottom: '10px'
                              }}>Noscitur a sociis (Words Known by Company)</h5>
                              {analysisResults.phaseC.commonLawMaxims.nosciturASociis.map((maxim, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: '#fefce8',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  marginBottom: '8px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#854d0e' }}>"{maxim.phrase}"</p>
                                  <p style={{ marginTop: '6px', color: '#374151' }}>
                                    <strong>Context:</strong> {maxim.surroundingContext}
                                  </p>
                                  <p style={{ marginTop: '4px', color: '#374151' }}>
                                    <strong>Interpretation:</strong> {maxim.interpretation}
                                  </p>
                                  <p style={{
                                    marginTop: '6px',
                                    padding: '6px',
                                    backgroundColor: 'white',
                                    borderRadius: '4px',
                                    color: '#78350f'
                                  }}>
                                    <strong>‚öñÔ∏è Application:</strong> {maxim.application}
                                  </p>
                                </div>
                              ))}
                            </div>

                            {/* Expressio unius est exclusio alterius */}
                            <div style={{
                              backgroundColor: 'white',
                              padding: '14px',
                              borderRadius: '6px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#92400e',
                                marginBottom: '10px'
                              }}>Expressio unius est exclusio alterius (Express Mention Excludes Others)</h5>
                              {analysisResults.phaseC.commonLawMaxims.expressioUnius.map((maxim, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: '#fef2f2',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  marginBottom: '8px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#991b1b', marginBottom: '8px' }}>
                                    ‚úÖ Expressly Included:
                                  </p>
                                  <ul style={{ paddingLeft: '20px', marginBottom: '8px', fontSize: '12px' }}>
                                    {maxim.expresslyIncluded.map((item, iidx) => (
                                      <li key={iidx} style={{ color: '#374151', marginBottom: '3px' }}>{item}</li>
                                    ))}
                                  </ul>
                                  <p style={{ fontWeight: '600', color: '#991b1b', marginBottom: '4px' }}>
                                    ‚ùå Impliedly Excluded:
                                  </p>
                                  <p style={{ color: '#374151', marginBottom: '8px', fontStyle: 'italic' }}>
                                    {maxim.impliedlyExcluded}
                                  </p>
                                  <p style={{
                                    backgroundColor: '#fee2e2',
                                    padding: '6px',
                                    borderRadius: '4px',
                                    color: '#7f1d1d'
                                  }}>
                                    <strong>‚ö†Ô∏è Legal Consequence:</strong> {maxim.legalConsequence}
                                  </p>
                                  <p style={{ marginTop: '6px', fontSize: '12px', color: '#6b7280' }}>
                                    {maxim.example}
                                  </p>
                                </div>
                              ))}
                            </div>

                            {/* Generalia specialibus non derogant */}
                            <div style={{
                              backgroundColor: 'white',
                              padding: '14px',
                              borderRadius: '6px',
                              marginBottom: '12px'
                            }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#92400e',
                                marginBottom: '10px'
                              }}>Generalia specialibus non derogant (Specific Prevails Over General)</h5>
                              {analysisResults.phaseC.commonLawMaxims.generaliaSpecialibus.map((maxim, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: '#eff6ff',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ color: '#374151', marginBottom: '6px' }}>
                                    <strong>General Provision:</strong> {maxim.generalProvision}
                                  </p>
                                  <p style={{ color: '#374151', marginBottom: '6px' }}>
                                    <strong>Specific Provision:</strong> {maxim.specificProvision}
                                  </p>
                                  <p style={{
                                    backgroundColor: '#dbeafe',
                                    padding: '8px',
                                    borderRadius: '4px',
                                    fontWeight: '600',
                                    color: '#1e40af',
                                    marginBottom: '6px'
                                  }}>
                                    ‚öñÔ∏è Which Prevails: {maxim.whichPrevails}
                                  </p>
                                  <p style={{ color: '#374151', marginBottom: '6px' }}>
                                    <strong>Reasoning:</strong> {maxim.reasoning}
                                  </p>
                                  <p style={{ color: '#374151' }}>
                                    <strong>Practical Effect:</strong> {maxim.practicalEffect}
                                  </p>
                                </div>
                              ))}
                            </div>

                            {/* Ejusdem generis */}
                            <div style={{
                              backgroundColor: 'white',
                              padding: '14px',
                              borderRadius: '6px'
                            }}>
                              <h5 style={{
                                fontWeight: '600',
                                color: '#92400e',
                                marginBottom: '10px'
                              }}>Ejusdem generis (Of the Same Kind)</h5>
                              {analysisResults.phaseC.commonLawMaxims.ejusdemGeneris.map((maxim, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: '#f0fdf4',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ color: '#374151', marginBottom: '6px' }}>
                                    <strong>Specific Items:</strong> {maxim.specificItems.join(', ')}
                                  </p>
                                  <p style={{ color: '#374151', marginBottom: '6px' }}>
                                    <strong>General Term:</strong> {maxim.generalTerm}
                                  </p>
                                  <p style={{ color: '#166534', fontWeight: '500' }}>
                                    {maxim.interpretation}
                                  </p>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}

                        {/* COMPREHENSIVE AMBIGUITY RESOLVER */}
                        {analysisResults.phaseC.ambiguityResolver && analysisResults.phaseC.ambiguityResolver.length > 0 && (
                          <div style={{
                            backgroundColor: '#f0f9ff',
                            border: '2px solid #0284c7',
                            padding: '16px',
                            borderRadius: '8px',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '700',
                              color: '#075985',
                              marginBottom: '16px',
                              fontSize: '16px'
                            }}>üîç COMPREHENSIVE AMBIGUITY RESOLUTION</h4>

                            {analysisResults.phaseC.ambiguityResolver.map((resolution, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '16px',
                                borderRadius: '8px',
                                marginBottom: '14px',
                                border: '1px solid #bae6fd'
                              }}>
                                <h5 style={{
                                  fontWeight: '700',
                                  color: '#0c4a6e',
                                  marginBottom: '14px',
                                  fontSize: '15px',
                                  backgroundColor: '#e0f2fe',
                                  padding: '10px',
                                  borderRadius: '6px'
                                }}>
                                  üéØ Ambiguous Phrase: "{resolution.ambiguousPhrase}"
                                </h5>

                                {/* Three Interpretations */}
                                <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '12px', marginBottom: '14px' }}>

                                  {/* Literal Interpretation */}
                                  <div style={{
                                    backgroundColor: '#eff6ff',
                                    padding: '12px',
                                    borderRadius: '6px',
                                    borderLeft: '4px solid #2563eb'
                                  }}>
                                    <h6 style={{ fontWeight: '600', color: '#1e40af', marginBottom: '8px' }}>
                                      üìñ Literal Interpretation
                                    </h6>
                                    <p style={{ fontSize: '13px', marginBottom: '6px' }}>
                                      <strong>Meaning:</strong> {resolution.literalInterpretation.meaning}
                                    </p>
                                    <p style={{ fontSize: '13px', marginBottom: '6px' }}>
                                      <strong>Analysis:</strong> {resolution.literalInterpretation.analysis}
                                    </p>
                                    <p style={{ fontSize: '12px', color: '#16a34a', marginBottom: '4px' }}>
                                      ‚úÖ <strong>Strengths:</strong> {resolution.literalInterpretation.strengths}
                                    </p>
                                    <p style={{ fontSize: '12px', color: '#dc2626' }}>
                                      ‚ùå <strong>Weaknesses:</strong> {resolution.literalInterpretation.weaknesses}
                                    </p>
                                  </div>

                                  {/* Contextual Interpretation */}
                                  <div style={{
                                    backgroundColor: '#f5f3ff',
                                    padding: '12px',
                                    borderRadius: '6px',
                                    borderLeft: '4px solid #7c3aed'
                                  }}>
                                    <h6 style={{ fontWeight: '600', color: '#5b21b6', marginBottom: '8px' }}>
                                      üîó Contextual Interpretation
                                    </h6>
                                    <p style={{ fontSize: '13px', marginBottom: '6px' }}>
                                      <strong>Meaning:</strong> {resolution.contextualInterpretation.meaning}
                                    </p>
                                    <p style={{ fontSize: '13px', marginBottom: '6px' }}>
                                      <strong>Analysis:</strong> {resolution.contextualInterpretation.analysis}
                                    </p>
                                    <p style={{ fontSize: '13px', marginBottom: '6px', backgroundColor: 'white', padding: '8px', borderRadius: '4px' }}>
                                      <strong>Statutory Scheme:</strong> {resolution.contextualInterpretation.statutoryScheme}
                                    </p>
                                    <p style={{ fontSize: '12px', color: '#16a34a', marginBottom: '4px' }}>
                                      ‚úÖ <strong>Strengths:</strong> {resolution.contextualInterpretation.strengths}
                                    </p>
                                    <p style={{ fontSize: '12px', color: '#dc2626' }}>
                                      ‚ùå <strong>Weaknesses:</strong> {resolution.contextualInterpretation.weaknesses}
                                    </p>
                                  </div>

                                  {/* Purposive Interpretation */}
                                  <div style={{
                                    backgroundColor: '#f0fdf4',
                                    padding: '12px',
                                    borderRadius: '6px',
                                    borderLeft: '4px solid #16a34a'
                                  }}>
                                    <h6 style={{ fontWeight: '600', color: '#166534', marginBottom: '8px' }}>
                                      üéØ Purposive Interpretation (Vic s.35a)
                                    </h6>
                                    <p style={{ fontSize: '13px', marginBottom: '6px' }}>
                                      <strong>Meaning:</strong> {resolution.purposiveInterpretation.meaning}
                                    </p>
                                    <p style={{ fontSize: '13px', marginBottom: '6px' }}>
                                      <strong>Analysis:</strong> {resolution.purposiveInterpretation.analysis}
                                    </p>
                                    <p style={{ fontSize: '13px', marginBottom: '6px', backgroundColor: 'white', padding: '8px', borderRadius: '4px' }}>
                                      <strong>Legislative Purpose:</strong> {resolution.purposiveInterpretation.legislativePurpose}
                                    </p>
                                    <p style={{ fontSize: '13px', marginBottom: '6px', backgroundColor: 'white', padding: '8px', borderRadius: '4px' }}>
                                      <strong>Mischief Rule:</strong> {resolution.purposiveInterpretation.mischiefRule}
                                    </p>
                                    <p style={{ fontSize: '12px', color: '#16a34a', marginBottom: '4px' }}>
                                      ‚úÖ <strong>Strengths:</strong> {resolution.purposiveInterpretation.strengths}
                                    </p>
                                    <p style={{ fontSize: '12px', color: '#dc2626' }}>
                                      ‚ùå <strong>Weaknesses:</strong> {resolution.purposiveInterpretation.weaknesses}
                                    </p>
                                  </div>
                                </div>

                                {/* Court Preference and Recommendation */}
                                <div style={{
                                  backgroundColor: '#fef3c7',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '10px'
                                }}>
                                  <p style={{ fontWeight: '700', color: '#78350f', marginBottom: '6px' }}>
                                    ‚öñÔ∏è Victorian Court Preference:
                                  </p>
                                  <p style={{ fontSize: '14px', color: '#92400e' }}>
                                    {resolution.victorianCourtPreference}
                                  </p>
                                </div>

                                <div style={{
                                  backgroundColor: '#dcfce7',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '10px',
                                  border: '2px solid #16a34a'
                                }}>
                                  <p style={{ fontWeight: '700', color: '#166534', marginBottom: '6px' }}>
                                    ‚úÖ RECOMMENDED INTERPRETATION:
                                  </p>
                                  <p style={{ fontSize: '14px', color: '#14532d' }}>
                                    {resolution.recommendedInterpretation}
                                  </p>
                                </div>

                                {/* Case Law Principles */}
                                <div style={{
                                  backgroundColor: '#f9fafb',
                                  padding: '10px',
                                  borderRadius: '6px'
                                }}>
                                  <p style={{ fontWeight: '600', fontSize: '13px', marginBottom: '6px', color: '#374151' }}>
                                    üìö Applicable Case Law Principles:
                                  </p>
                                  <ul style={{ paddingLeft: '20px', fontSize: '12px', color: '#6b7280' }}>
                                    {resolution.caseLawPrinciples.map((principle, pidx) => (
                                      <li key={pidx} style={{ marginBottom: '4px' }}>{principle}</li>
                                    ))}
                                  </ul>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}

                        {/* HARMONIZATION ANALYSIS */}
                        {analysisResults.phaseC.harmonization && analysisResults.phaseC.harmonization.length > 0 && (
                          <div style={{
                            backgroundColor: '#fef2f2',
                            border: '2px solid #dc2626',
                            padding: '16px',
                            borderRadius: '8px',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '700',
                              color: '#991b1b',
                              marginBottom: '16px',
                              fontSize: '16px'
                            }}>‚öîÔ∏è DOCUMENT HARMONIZATION & CONFLICT RESOLUTION</h4>

                            {analysisResults.phaseC.harmonization.map((harm, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '14px',
                                borderRadius: '8px',
                                marginBottom: '12px',
                                border: '1px solid #fecaca'
                              }}>
                                <h5 style={{
                                  fontWeight: '600',
                                  color: '#7f1d1d',
                                  marginBottom: '12px',
                                  backgroundColor: '#fee2e2',
                                  padding: '10px',
                                  borderRadius: '6px'
                                }}>
                                  ‚ö†Ô∏è Conflict: {harm.conflict}
                                </h5>

                                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px', marginBottom: '12px' }}>
                                  <div style={{
                                    backgroundColor: '#dbeafe',
                                    padding: '10px',
                                    borderRadius: '6px',
                                    fontSize: '13px'
                                  }}>
                                    <p style={{ fontWeight: '600', color: '#1e40af', marginBottom: '6px' }}>
                                      üìÑ File A Position:
                                    </p>
                                    <p style={{ color: '#374151' }}>{harm.fileAPosition}</p>
                                  </div>
                                  <div style={{
                                    backgroundColor: '#f3e8ff',
                                    padding: '10px',
                                    borderRadius: '6px',
                                    fontSize: '13px'
                                  }}>
                                    <p style={{ fontWeight: '600', color: '#6b21a8', marginBottom: '6px' }}>
                                      üìÑ File B Position:
                                    </p>
                                    <p style={{ color: '#374151' }}>{harm.fileBPosition}</p>
                                  </div>
                                </div>

                                <div style={{
                                  backgroundColor: '#f9fafb',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '10px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#111827', marginBottom: '6px' }}>
                                    üîÑ Reconciliation Attempt:
                                  </p>
                                  <p style={{ color: '#374151' }}>{harm.reconciliationAttempt}</p>
                                </div>

                                <div style={{ marginBottom: '10px' }}>
                                  <Badge variant={harm.isReconcilable ? 'success' : 'error'}>
                                    {harm.isReconcilable ? '‚úÖ Reconcilable' : '‚ùå Irreconcilable Conflict'}
                                  </Badge>
                                </div>

                                <div style={{
                                  backgroundColor: '#fffbeb',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '10px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#78350f', marginBottom: '6px' }}>
                                    ‚öñÔ∏è Which Prevails:
                                  </p>
                                  <p style={{ color: '#92400e' }}>{harm.whichPrevails}</p>
                                </div>

                                <div style={{
                                  backgroundColor: '#f0f9ff',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '10px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#075985', marginBottom: '6px' }}>
                                    üìã Statutory Support:
                                  </p>
                                  <p style={{ color: '#374151' }}>{harm.statutorySupport}</p>
                                </div>

                                <div style={{
                                  backgroundColor: '#fee2e2',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '10px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#991b1b', marginBottom: '6px' }}>
                                    ‚ö†Ô∏è Legal Consequence:
                                  </p>
                                  <p style={{ color: '#7f1d1d' }}>{harm.legalConsequence}</p>
                                </div>

                                <div style={{
                                  backgroundColor: '#dcfce7',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  border: '2px solid #16a34a',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '700', color: '#166534', marginBottom: '6px' }}>
                                    üíº ARGUMENT APPROACH:
                                  </p>
                                  <p style={{ color: '#14532d', fontWeight: '500' }}>{harm.argumentApproach}</p>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}

                        {/* STATUTORY PROVISION REPORTS */}
                        {analysisResults.phaseC.provisionReports && analysisResults.phaseC.provisionReports.length > 0 && (
                          <div style={{
                            backgroundColor: '#f0fdf4',
                            border: '2px solid #16a34a',
                            padding: '16px',
                            borderRadius: '8px',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '700',
                              color: '#166534',
                              marginBottom: '16px',
                              fontSize: '16px'
                            }}>üìã DETAILED STATUTORY PROVISION INTERPRETATION REPORTS</h4>

                            {analysisResults.phaseC.provisionReports.map((report, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '16px',
                                borderRadius: '8px',
                                marginBottom: '14px',
                                border: '2px solid #bbf7d0'
                              }}>
                                <h5 style={{
                                  fontWeight: '700',
                                  color: '#14532d',
                                  marginBottom: '14px',
                                  fontSize: '15px',
                                  backgroundColor: '#dcfce7',
                                  padding: '12px',
                                  borderRadius: '6px'
                                }}>
                                  ‚öñÔ∏è {report.provision}
                                </h5>

                                <div style={{
                                  backgroundColor: '#f9fafb',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '12px',
                                  fontSize: '13px',
                                  fontFamily: 'monospace'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#111827', marginBottom: '8px' }}>
                                    üìú Plain Text of Provision:
                                  </p>
                                  <p style={{ color: '#374151', lineHeight: '1.6' }}>{report.plainText}</p>
                                </div>

                                <div style={{
                                  backgroundColor: '#eff6ff',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '12px',
                                  fontSize: '13px'
                                }}>
                                  <p style={{ fontWeight: '600', color: '#1e40af', marginBottom: '8px' }}>
                                    üîç Application to Facts in Documents:
                                  </p>
                                  <pre style={{
                                    color: '#374151',
                                    whiteSpace: 'pre-wrap',
                                    fontFamily: 'inherit',
                                    margin: 0
                                  }}>{report.applicationToFacts}</pre>
                                </div>

                                <div style={{
                                  backgroundColor: report.requirementsSatisfied?.includes('NOT SATISFIED') ? '#fee2e2' :
                                                   report.requirementsSatisfied?.includes('UNCLEAR') ? '#fef3c7' :
                                                   report.requirementsSatisfied?.includes('POTENTIALLY') ? '#e0f2fe' :
                                                   '#dcfce7',
                                  padding: '12px',
                                  borderRadius: '6px',
                                  marginBottom: '12px',
                                  border: '2px solid ' + (
                                    report.requirementsSatisfied?.includes('NOT SATISFIED') ? '#dc2626' :
                                    report.requirementsSatisfied?.includes('UNCLEAR') ? '#f59e0b' :
                                    '#16a34a'
                                  )
                                }}>
                                  <p style={{
                                    fontWeight: '700',
                                    color: report.requirementsSatisfied?.includes('NOT SATISFIED') ? '#991b1b' :
                                           report.requirementsSatisfied?.includes('UNCLEAR') ? '#78350f' :
                                           '#166534',
                                    fontSize: '14px'
                                  }}>
                                    {report.requirementsSatisfied?.includes('NOT SATISFIED') ? '‚ùå' :
                                     report.requirementsSatisfied?.includes('UNCLEAR') ? '‚ö†Ô∏è' :
                                     report.requirementsSatisfied?.includes('POTENTIALLY') ? '‚ö†Ô∏è' : '‚úÖ'}
                                    {' '}Requirements Satisfied: {report.requirementsSatisfied || 'UNKNOWN'}
                                  </p>
                                </div>

                                {report.deficiencies && report.deficiencies.length > 0 && (
                                  <div style={{
                                    backgroundColor: '#fee2e2',
                                    padding: '12px',
                                    borderRadius: '6px',
                                    marginBottom: '12px',
                                    border: '2px solid #dc2626'
                                  }}>
                                    <p style={{ fontWeight: '700', color: '#991b1b', marginBottom: '8px', fontSize: '14px' }}>
                                      üö® Deficiencies Identified:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', fontSize: '13px', color: '#7f1d1d' }}>
                                      {report.deficiencies.map((def, didx) => (
                                        <li key={didx} style={{ marginBottom: '6px', fontWeight: '500' }}>{def}</li>
                                      ))}
                                    </ul>
                                  </div>
                                )}

                                {report.legalConsequences && report.legalConsequences.length > 0 && (
                                  <div style={{
                                    backgroundColor: '#fef3c7',
                                    padding: '12px',
                                    borderRadius: '6px',
                                    marginBottom: '12px'
                                  }}>
                                    <p style={{ fontWeight: '700', color: '#78350f', marginBottom: '8px', fontSize: '14px' }}>
                                      ‚öñÔ∏è Legal Consequences:
                                    </p>
                                    <ul style={{ paddingLeft: '20px', fontSize: '13px', color: '#92400e' }}>
                                      {report.legalConsequences.map((cons, cidx) => (
                                        <li key={cidx} style={{ marginBottom: '6px' }}>{cons}</li>
                                      ))}
                                    </ul>
                                  </div>
                                )}

                                <div style={{
                                  backgroundColor: '#dcfce7',
                                  padding: '14px',
                                  borderRadius: '6px',
                                  border: '3px solid #16a34a'
                                }}>
                                  <p style={{ fontWeight: '700', color: '#166534', marginBottom: '10px', fontSize: '14px' }}>
                                    üíº RECOMMENDED ARGUMENT APPROACH:
                                  </p>
                                  <p style={{
                                    color: '#14532d',
                                    fontSize: '14px',
                                    lineHeight: '1.6',
                                    fontWeight: '500'
                                  }}>
                                    {report.recommendedArgument}
                                  </p>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}

                        {/* LEGACY INTERPRETATION SUMMARY (for backward compatibility) */}
                        <div style={{
                          backgroundColor: '#f9fafb',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#111827',
                            marginBottom: '12px'
                          }}>Summary of Interpretive Approaches</h4>

                          <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                            <div style={{
                              backgroundColor: 'white',
                              padding: '12px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #2563eb',
                              fontSize: '13px'
                            }}>
                              <h5 style={{ fontWeight: '500', color: '#1e40af', marginBottom: '6px' }}>
                                {analysisResults.phaseC.literalInterpretation.approach}
                              </h5>
                              <p style={{ color: '#374151' }}>{analysisResults.phaseC.literalInterpretation.findings}</p>
                            </div>

                            <div style={{
                              backgroundColor: 'white',
                              padding: '12px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #7c3aed',
                              fontSize: '13px'
                            }}>
                              <h5 style={{ fontWeight: '500', color: '#5b21b6', marginBottom: '6px' }}>
                                {analysisResults.phaseC.contextualInterpretation.approach}
                              </h5>
                              <p style={{ color: '#374151' }}>{analysisResults.phaseC.contextualInterpretation.findings}</p>
                            </div>

                            <div style={{
                              backgroundColor: 'white',
                              padding: '12px',
                              borderRadius: '4px',
                              borderLeft: '4px solid #16a34a',
                              fontSize: '13px'
                            }}>
                              <h5 style={{ fontWeight: '500', color: '#14532d', marginBottom: '6px' }}>
                                {analysisResults.phaseC.purposiveInterpretation.approach}
                              </h5>
                              <p style={{ color: '#374151' }}>{analysisResults.phaseC.purposiveInterpretation.findings}</p>
                            </div>
                          </div>
                        </div>

                        {/* INTERPRETIVE PRINCIPLES */}
                        <div style={{
                          backgroundColor: '#eff6ff',
                          padding: '16px',
                          borderRadius: '8px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#1e40af',
                            marginBottom: '12px'
                          }}>All Interpretive Principles Applied</h4>
                          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
                            {analysisResults.phaseC.interpretativePrinciples.map((principle, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '10px',
                                borderRadius: '4px',
                                fontSize: '13px'
                              }}>
                                <p style={{ fontWeight: '500', color: '#111827' }}>{principle.principle}</p>
                                <p style={{ color: '#6b7280', marginTop: '4px', fontSize: '12px' }}>{principle.application}</p>
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </AnalysisSection>

                    <AnalysisSection title="Recommendations & Next Steps" sectionId="recommendations">
                      <div style={{ marginTop: '16px' }}>
                        <div style={{
                          backgroundColor: '#eff6ff',
                          padding: '16px',
                          borderRadius: '8px',
                          marginBottom: '16px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#1e40af',
                            marginBottom: '12px'
                          }}>Strategic Recommendations</h4>
                          <ul style={{
                            fontSize: '14px',
                            color: '#1e40af',
                            paddingLeft: '20px'
                          }}>
                            {analysisResults.summary.recommendations.map((rec, idx) => (
                              <li key={idx} style={{ marginBottom: '8px' }}>{rec}</li>
                            ))}
                          </ul>
                        </div>

                        <div style={{
                          backgroundColor: '#f0fdf4',
                          padding: '16px',
                          borderRadius: '8px'
                        }}>
                          <h4 style={{
                            fontWeight: '600',
                            color: '#14532d',
                            marginBottom: '12px'
                          }}>Proposed Next Steps</h4>
                          <ol style={{
                            fontSize: '14px',
                            color: '#166534',
                            paddingLeft: '20px'
                          }}>
                            {analysisResults.summary.nextSteps.map((step, idx) => (
                              <li key={idx} style={{ marginBottom: '8px' }}>{step}</li>
                            ))}
                          </ol>
                        </div>
                      </div>
                    </AnalysisSection>

                    {historicalAnalyses.length > 0 && (
                      <AnalysisSection title="üìä Defect Evolution Timeline" sectionId="timeline">
                        <DefectTimeline analyses={historicalAnalyses} />
                      </AnalysisSection>
                    )}

                    {detectedPatterns && detectedPatterns.recurring.length > 0 && (
                      <AnalysisSection title="üîç Pattern Recognition Analysis" sectionId="patterns">
                        <div style={{ marginTop: '16px' }}>
                          <div style={{
                            backgroundColor: '#fef2f2',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: '4px solid #dc2626',
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: '#7f1d1d',
                              marginBottom: '12px'
                            }}>Recurring Issues Detected</h4>
                            <p style={{
                              fontSize: '14px',
                              color: '#991b1b',
                              marginBottom: '12px'
                            }}>
                              The following issues have occurred multiple times across your analyses, indicating systematic problems that require attention:
                            </p>

                            {detectedPatterns.recurring.map((pattern, idx) => (
                              <div key={idx} style={{
                                backgroundColor: 'white',
                                padding: '16px',
                                borderRadius: '8px',
                                marginBottom: '12px',
                                border: '1px solid #fecaca'
                              }}>
                                <div style={{
                                  display: 'flex',
                                  justifyContent: 'space-between',
                                  alignItems: 'start',
                                  marginBottom: '8px'
                                }}>
                                  <h5 style={{
                                    fontWeight: '600',
                                    color: '#991b1b',
                                    fontSize: '16px'
                                  }}>{pattern.type}</h5>
                                  <span style={{
                                    backgroundColor: '#dc2626',
                                    color: 'white',
                                    padding: '4px 12px',
                                    borderRadius: '12px',
                                    fontSize: '12px',
                                    fontWeight: '600'
                                  }}>
                                    {pattern.frequency}x
                                  </span>
                                </div>

                                <p style={{
                                  fontSize: '14px',
                                  color: '#6b7280',
                                  marginBottom: '8px'
                                }}>
                                  {pattern.description}
                                </p>

                                <div style={{
                                  display: 'flex',
                                  gap: '16px',
                                  fontSize: '12px',
                                  color: '#6b7280',
                                  marginBottom: '12px'
                                }}>
                                  <div>
                                    <strong>First Seen:</strong> {new Date(pattern.firstSeen).toLocaleDateString()}
                                  </div>
                                  <div>
                                    <strong>Last Seen:</strong> {new Date(pattern.lastSeen).toLocaleDateString()}
                                  </div>
                                </div>

                                <div style={{
                                  backgroundColor: '#fffbeb',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  borderLeft: '4px solid #f59e0b'
                                }}>
                                  <strong style={{ color: '#78350f', fontSize: '13px' }}>üí° Recommendation:</strong>
                                  <p style={{
                                    fontSize: '13px',
                                    color: '#92400e',
                                    marginTop: '4px'
                                  }}>
                                    {pattern.recommendation}
                                  </p>
                                </div>
                              </div>
                            ))}
                          </div>

                          {detectedPatterns.recurring.length === 0 && (
                            <div style={{
                              backgroundColor: '#f0fdf4',
                              padding: '16px',
                              borderRadius: '8px',
                              borderLeft: '4px solid #16a34a'
                            }}>
                              <p style={{
                                fontSize: '14px',
                                color: '#166534'
                              }}>
                                ‚úÖ No recurring patterns detected. Continue monitoring future analyses for emerging trends.
                              </p>
                            </div>
                          )}
                        </div>
                      </AnalysisSection>
                    )}

                    {contextualInsights && (
                      <AnalysisSection title="üß† Contextual Intelligence & Trend Analysis" sectionId="contextual">
                        <div style={{ marginTop: '16px' }}>
                          {/* Severity Comparison */}
                          <div style={{
                            backgroundColor: contextualInsights.severity.status === 'worse' ? '#fef2f2' :
                                           contextualInsights.severity.status === 'better' ? '#f0fdf4' : '#eff6ff',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: `4px solid ${
                              contextualInsights.severity.status === 'worse' ? '#dc2626' :
                              contextualInsights.severity.status === 'better' ? '#16a34a' : '#2563eb'
                            }`,
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: contextualInsights.severity.status === 'worse' ? '#7f1d1d' :
                                     contextualInsights.severity.status === 'better' ? '#14532d' : '#1e40af',
                              marginBottom: '12px'
                            }}>üìä Severity Comparison</h4>
                            <p style={{
                              fontSize: '14px',
                              color: contextualInsights.severity.status === 'worse' ? '#991b1b' :
                                     contextualInsights.severity.status === 'better' ? '#166534' : '#1e40af',
                              marginBottom: '8px'
                            }}>
                              {contextualInsights.severity.message}
                            </p>
                            {contextualInsights.severity.data && (
                              <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '8px' }}>
                                Current: {contextualInsights.severity.data.current} | Historical Average: {contextualInsights.severity.data.average}
                              </div>
                            )}
                          </div>

                          {/* Trend Analysis */}
                          <div style={{
                            backgroundColor: contextualInsights.trend.direction === 'worsening' ? '#fef2f2' :
                                           contextualInsights.trend.direction === 'improving' ? '#f0fdf4' : '#eff6ff',
                            padding: '16px',
                            borderRadius: '8px',
                            borderLeft: `4px solid ${
                              contextualInsights.trend.direction === 'worsening' ? '#dc2626' :
                              contextualInsights.trend.direction === 'improving' ? '#16a34a' : '#2563eb'
                            }`,
                            marginBottom: '16px'
                          }}>
                            <h4 style={{
                              fontWeight: '600',
                              color: contextualInsights.trend.direction === 'worsening' ? '#7f1d1d' :
                                     contextualInsights.trend.direction === 'improving' ? '#14532d' : '#1e40af',
                              marginBottom: '12px'
                            }}>üìà Trend Analysis</h4>
                            <p style={{
                              fontSize: '14px',
                              color: contextualInsights.trend.direction === 'worsening' ? '#991b1b' :
                                     contextualInsights.trend.direction === 'improving' ? '#166534' : '#1e40af'
                            }}>
                              {contextualInsights.trend.message}
                            </p>
                            {contextualInsights.trend.data && (
                              <div style={{ fontSize: '12px', color: '#6b7280', marginTop: '8px' }}>
                                Based on {contextualInsights.trend.data.samples} recent analyses
                              </div>
                            )}
                          </div>

                          {/* Smart Recommendations */}
                          {contextualInsights.recommendations && contextualInsights.recommendations.length > 0 && (
                            <div style={{
                              backgroundColor: '#fffbeb',
                              padding: '16px',
                              borderRadius: '8px',
                              borderLeft: '4px solid #f59e0b',
                              marginBottom: '16px'
                            }}>
                              <h4 style={{
                                fontWeight: '600',
                                color: '#78350f',
                                marginBottom: '12px'
                              }}>üí° Smart Recommendations</h4>
                              <p style={{
                                fontSize: '13px',
                                color: '#92400e',
                                marginBottom: '12px'
                              }}>
                                Based on analysis of current and historical data, here are intelligent recommendations:
                              </p>
                              {contextualInsights.recommendations.map((rec, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: 'white',
                                  padding: '12px',
                                  borderRadius: '4px',
                                  marginBottom: '8px',
                                  border: '1px solid #fde68a'
                                }}>
                                  <div style={{
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'start',
                                    marginBottom: '8px'
                                  }}>
                                    <strong style={{
                                      fontSize: '14px',
                                      color: '#78350f'
                                    }}>{rec.category}</strong>
                                    <span style={{
                                      padding: '2px 8px',
                                      borderRadius: '8px',
                                      fontSize: '11px',
                                      fontWeight: '600',
                                      backgroundColor: rec.priority === 'high' ? '#fee2e2' :
                                                      rec.priority === 'medium' ? '#fef3c7' : '#dbeafe',
                                      color: rec.priority === 'high' ? '#991b1b' :
                                             rec.priority === 'medium' ? '#92400e' : '#1e40af'
                                    }}>
                                      {rec.priority.toUpperCase()}
                                    </span>
                                  </div>
                                  <p style={{
                                    fontSize: '13px',
                                    color: '#374151',
                                    marginBottom: '6px'
                                  }}>
                                    {rec.recommendation}
                                  </p>
                                  <p style={{
                                    fontSize: '12px',
                                    color: '#6b7280',
                                    fontStyle: 'italic'
                                  }}>
                                    Expected Impact: {rec.impact}
                                  </p>
                                </div>
                              ))}
                            </div>
                          )}

                          {/* Novel Issues */}
                          {contextualInsights.novelIssues && contextualInsights.novelIssues.length > 0 && (
                            <div style={{
                              backgroundColor: '#fef3c7',
                              padding: '16px',
                              borderRadius: '8px',
                              borderLeft: '4px solid #f59e0b'
                            }}>
                              <h4 style={{
                                fontWeight: '600',
                                color: '#78350f',
                                marginBottom: '12px'
                              }}>üÜï Novel Issues Detected</h4>
                              <p style={{
                                fontSize: '13px',
                                color: '#92400e',
                                marginBottom: '12px'
                              }}>
                                The following issue types have not been seen in previous analyses:
                              </p>
                              {contextualInsights.novelIssues.map((issue, idx) => (
                                <div key={idx} style={{
                                  backgroundColor: 'white',
                                  padding: '10px',
                                  borderRadius: '4px',
                                  marginBottom: '8px',
                                  border: '1px solid #fde68a'
                                }}>
                                  <div style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px',
                                    marginBottom: '4px'
                                  }}>
                                    <span style={{
                                      padding: '2px 8px',
                                      borderRadius: '8px',
                                      fontSize: '11px',
                                      fontWeight: '600',
                                      backgroundColor: getColorForSeverity(issue.severity),
                                      border: '1px solid #e5e7eb'
                                    }}>
                                      {issue.severity.toUpperCase()}
                                    </span>
                                    <strong style={{ fontSize: '13px', color: '#111827' }}>
                                      {issue.type}
                                    </strong>
                                  </div>
                                  <p style={{ fontSize: '12px', color: '#6b7280' }}>
                                    {issue.description}
                                  </p>
                                  <p style={{ fontSize: '11px', color: '#9ca3af', marginTop: '4px' }}>
                                    Detected in: {issue.preset}
                                  </p>
                                </div>
                              ))}
                            </div>
                          )}
                        </div>
                      </AnalysisSection>
                    )}
                  </div>
                )}
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ForensicLegalAnalyzer />);
    </script>
</body>
</html>
